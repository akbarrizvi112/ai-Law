"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   Queue: () => (/* binding */ Queue)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n\n\n\n\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    return runs.map((run)=>{\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime\n            },\n            metadata: {\n                ...envVars,\n                ...envVars.revision_id || run.revision_id ? {\n                    revision_id: run.revision_id ?? envVars.revision_id\n                } : {},\n                ...metadata\n            }\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = ()=>{\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation)=>{\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_4__[\"default\"](str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nclass Queue {\n    constructor(){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve)=>{\n            this.items.push([\n                item,\n                resolve\n            ]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while(popped.length < upToN && this.items.length){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            } else {\n                break;\n            }\n        }\n        return [\n            popped.map((it)=>it[0]),\n            ()=>popped.forEach((it)=>it[1]())\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429\n        });\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms)\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            const sampled = [];\n            for (const run of runs){\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while(this.autoBatchQueue.size >= 0){\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                    runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n                });\n            } finally{\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            throw new Error(\"Failed to retrieve server info.\");\n        }\n        return response.json();\n    }\n    async batchEndpointIsSupported() {\n        try {\n            this.serverInfo = await this._getServerInfo();\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true)\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post){\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch){\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const sizeLimitBytes = this.serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        let currentBatchSizeBytes = 0;\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                const stringifiedBatchItem = JSON.stringify(batchItem);\n                if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {\n                    await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n                    currentBatchSizeBytes = 0;\n                    batchChunks.post = [];\n                    batchChunks.patch = [];\n                }\n                currentBatchSizeBytes += stringifiedBatchItem.length;\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns(JSON.stringify(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }, true);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param executionOrder - The execution order to filter by.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, traceFilter, treeFilter, limit } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType } = {}) {\n        const body = {\n            name,\n            description\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)){\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = {\n                ...sourceInfo_,\n                ...feedbackResult.evaluatorInfo\n            };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            feedbackConfig\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms)\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE2QjtBQUN5QjtBQUNzQztBQUNpQjtBQUNwRTtBQUN6QyxlQUFlUSw4QkFBOEJDLElBQUk7SUFDN0MsTUFBTUMsYUFBYSxNQUFNSixvRUFBcUJBO0lBQzlDLE1BQU1LLFVBQVVOLDBFQUEyQkE7SUFDM0MsT0FBT0ksS0FBS0csR0FBRyxDQUFDLENBQUNDO1FBQ2IsTUFBTUMsUUFBUUQsSUFBSUMsS0FBSyxJQUFJLENBQUM7UUFDNUIsTUFBTUMsV0FBV0QsTUFBTUMsUUFBUTtRQUMvQkYsSUFBSUMsS0FBSyxHQUFHO1lBQ1IsR0FBR0EsS0FBSztZQUNSRSxTQUFTO2dCQUNMLEdBQUdOLFVBQVU7Z0JBQ2IsR0FBR0ksT0FBT0UsT0FBTztZQUNyQjtZQUNBRCxVQUFVO2dCQUNOLEdBQUdKLE9BQU87Z0JBQ1YsR0FBSUEsUUFBUU0sV0FBVyxJQUFJSixJQUFJSSxXQUFXLEdBQ3BDO29CQUFFQSxhQUFhSixJQUFJSSxXQUFXLElBQUlOLFFBQVFNLFdBQVc7Z0JBQUMsSUFDdEQsQ0FBQyxDQUFDO2dCQUNSLEdBQUdGLFFBQVE7WUFDZjtRQUNKO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKO0FBQ0EsTUFBTUsseUJBQXlCO0lBQzNCLE1BQU1DLGtCQUFrQmYscUVBQXNCQSxDQUFDO0lBQy9DLElBQUllLG9CQUFvQkMsV0FBVztRQUMvQixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUMsV0FBV0g7SUFDaEMsSUFBSUUsZUFBZSxLQUFLQSxlQUFlLEdBQUc7UUFDdEMsTUFBTSxJQUFJRSxNQUFNLENBQUMscUVBQXFFLEVBQUVGLGFBQWEsQ0FBQztJQUMxRztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTUcsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxjQUFjRCxJQUFJRSxPQUFPLENBQUMsV0FBVyxJQUFJQSxPQUFPLENBQUMsWUFB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QVdKLFlBQVlLLE1BQU07Z0JBQ25FalcsSUFBSSxDQUFDLGFBQWEsR0FBRzRWO1lBQ3pCO1FBQ0osT0FDSztZQUNENVYsSUFBSSxDQUFDLGFBQWEsR0FBRztnQkFDakIrVixPQUFPO1lBQ1g7UUFDSjtRQUNBLE1BQU1qVyxXQUFXLE1BQU0sSUFBSSxDQUFDcUQsTUFBTSxDQUFDc0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMzQixNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUM3RTRCLFFBQVE7WUFDUnpELFNBQVM7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE9BQU87Z0JBQUUsZ0JBQWdCO1lBQW1CO1lBQy9EbEIsTUFBTTRGLEtBQUtDLFNBQVMsQ0FBQzdGO1lBQ3JCNEUsUUFBUUMsWUFBWUMsT0FBTyxDQUFDLElBQUksQ0FBQzVCLFVBQVU7UUFDL0M7UUFDQSxNQUFNM0MsU0FBUyxNQUFNVCxTQUFTa0YsSUFBSTtRQUNsQyxPQUFPekU7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPMlYsNEJBQTRCdkwsS0FBSyxFQUFFO1FBQ3RDOUosV0FBVzhKO1FBQ1gsTUFBTXRCLFNBQVMsSUFBSW5FLGdCQUFnQjtZQUFFb0osUUFBUTNEO1FBQU07UUFDbkQsV0FBVyxNQUFNd0wsVUFBVSxJQUFJLENBQUNsUixhQUFhLENBQUMsb0JBQW9Cb0UsUUFBUztZQUN2RSxPQUFPOE07UUFDWDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ZWQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUsIGlzTGFuZ0NoYWluTWVzc2FnZSwgfSBmcm9tIFwiLi91dGlscy9tZXNzYWdlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5hc3luYyBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhydW5zKSB7XG4gICAgY29uc3QgcnVudGltZUVudiA9IGF3YWl0IGdldFJ1bnRpbWVFbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGVudlZhcnMgPSBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEoKTtcbiAgICByZXR1cm4gcnVucy5tYXAoKHJ1bikgPT4ge1xuICAgICAgICBjb25zdCBleHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICAgICAgcnVuLmV4dHJhID0ge1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAgICAgLi4ucnVudGltZUVudixcbiAgICAgICAgICAgICAgICAuLi5leHRyYT8ucnVudGltZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIC4uLmVudlZhcnMsXG4gICAgICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgcnVuLnJldmlzaW9uX2lkXG4gICAgICAgICAgICAgICAgICAgID8geyByZXZpc2lvbl9pZDogcnVuLnJldmlzaW9uX2lkID8/IGVudlZhcnMucmV2aXNpb25faWQgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfSk7XG59XG5jb25zdCBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVFJBQ0lOR19TQU1QTElOR19SQVRFXCIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGVTdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBwYXJzZUZsb2F0KHNhbXBsaW5nUmF0ZVN0cik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZSA8IDAgfHwgc2FtcGxpbmdSYXRlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExBTkdDSEFJTl9UUkFDSU5HX1NBTVBMSU5HX1JBVEUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEgaWYgc2V0LiBHb3Q6ICR7c2FtcGxpbmdSYXRlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxpbmdSYXRlO1xufTtcbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5jb25zdCBpc0xvY2FsaG9zdCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBzdHJpcHBlZFVybCA9IHVybC5yZXBsYWNlKFwiaHR0cDovL1wiLCBcIlwiKS5yZXBsYWNlKFwiaHR0cHM6Ly9cIiwgXCJcIik7XG4gICAgY29uc3QgaG9zdG5hbWUgPSBzdHJpcHBlZFVybC5zcGxpdChcIi9cIilbMF0uc3BsaXQoXCI6XCIpWzBdO1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09IFwibG9jYWxob3N0XCIgfHwgaG9zdG5hbWUgPT09IFwiMTI3LjAuMC4xXCIgfHwgaG9zdG5hbWUgPT09IFwiOjoxXCIpO1xufTtcbmNvbnN0IHJhaXNlRm9yU3RhdHVzID0gYXN5bmMgKHJlc3BvbnNlLCBvcGVyYXRpb24pID0+IHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byAke29wZXJhdGlvbn06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9ICR7Ym9keX1gKTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFV1aWQoc3RyKSB7XG4gICAgaWYgKCF1dWlkLnZhbGlkYXRlKHN0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWApO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZTQyOSA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZT8uc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIikgPz8gXCIzMFwiLCAxMCkgKiAxMDAwO1xuICAgICAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXIpKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBkaXJlY3RseSBhZnRlciBjYWxsaW5nIHRoaXMgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byBleGlzdGluZyBzdGF0dXMgY2hlY2tzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCBjbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIC8vIHRoaXMuaXRlbXMucHVzaCBpcyBzeW5jaHJvbm91cyB3aXRoIHByb21pc2UgY3JlYXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvUHJvbWlzZVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChbaXRlbSwgcmVzb2x2ZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9wKHVwVG9OKSB7XG4gICAgICAgIGlmICh1cFRvTiA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBpdGVtcyB0byBwb3Agb2ZmIG1heSBub3QgYmUgbGVzcyB0aGFuIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcHBlZCA9IFtdO1xuICAgICAgICB3aGlsZSAocG9wcGVkLmxlbmd0aCA8IHVwVG9OICYmIHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcG9wcGVkLm1hcCgoaXQpID0+IGl0WzBdKSwgKCkgPT4gcG9wcGVkLmZvckVhY2goKGl0KSA9PiBpdFsxXSgpKV07XG4gICAgfVxufVxuLy8gMjAgTUJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyMDk3MTUyMDtcbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEluZ2VzdENhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nU2FtcGxlUmF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzYW1wbGVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoRW5kcG9pbnRTdXBwb3J0ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBRdWV1ZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMTAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUaW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaEluaXRpYWxEZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAyNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcnZlckluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IENsaWVudC5nZXREZWZhdWx0Q2xpZW50Q29uZmlnKCk7XG4gICAgICAgIHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPSBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlKCk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpVXJsID8/IGRlZmF1bHRDb25maWcuYXBpVXJsKSA/PyBcIlwiO1xuICAgICAgICB0aGlzLmFwaUtleSA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaUtleSA/PyBkZWZhdWx0Q29uZmlnLmFwaUtleSk7XG4gICAgICAgIHRoaXMud2ViVXJsID0gdHJpbVF1b3Rlcyhjb25maWcud2ViVXJsID8/IGRlZmF1bHRDb25maWcud2ViVXJsKTtcbiAgICAgICAgdGhpcy50aW1lb3V0X21zID0gY29uZmlnLnRpbWVvdXRfbXMgPz8gMTIwMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KTtcbiAgICAgICAgdGhpcy5iYXRjaEluZ2VzdENhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICAuLi4oY29uZmlnLmNhbGxlck9wdGlvbnMgPz8ge30pLFxuICAgICAgICAgICAgb25GYWlsZWRSZXNwb25zZUhvb2s6IGhhbmRsZTQyOSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlkZUlucHV0cyA9IGNvbmZpZy5oaWRlSW5wdXRzID8/IGRlZmF1bHRDb25maWcuaGlkZUlucHV0cztcbiAgICAgICAgdGhpcy5oaWRlT3V0cHV0cyA9IGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQgPVxuICAgICAgICAgICAgY29uZmlnLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0ID8/IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIik7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz9cbiAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICBjb25zdCBoaWRlSW5wdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9ISURFX09VVFBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICAgIHdlYlVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGlkZUlucHV0czogaGlkZUlucHV0cyxcbiAgICAgICAgICAgIGhpZGVPdXRwdXRzOiBoaWRlT3V0cHV0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0SG9zdFVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL2xvY2FsaG9zdFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmluY2x1ZGVzKFwiL2FwaVwiKSAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5lbmRzV2l0aChcImFwaVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJkZXZcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBgbGFuZ3NtaXRoLWpzLyR7X192ZXJzaW9uX199YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgcHJvY2Vzc0lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlSW5wdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBwcm9jZXNzT3V0cHV0cyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZU91dHB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIHByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhydW4pIHtcbiAgICAgICAgY29uc3QgcnVuUGFyYW1zID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHJ1blBhcmFtcy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW5QYXJhbXMuaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuUGFyYW1zLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1blBhcmFtcy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcXVlcnlQYXJhbXM/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc1N0cmluZ31gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKl9nZXRQYWdpbmF0ZWQocGF0aCwgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCkpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcImxpbWl0XCIpKSB8fCAxMDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zYW1wbGVkUG9zdFV1aWRzLmhhcyhydW4uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuYWRkKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbYmF0Y2gsIGRvbmVdID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wb3AodGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCk7XG4gICAgICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RSdW5zKHtcbiAgICAgICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0sIGltbWVkaWF0ZWx5VHJpZ2dlckJhdGNoKSB7XG4gICAgICAgIGNvbnN0IG9sZFRpbWVvdXQgPSB0aGlzLmF1dG9CYXRjaFRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9CYXRjaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoaW1tZWRpYXRlbHlUcmlnZ2VyQmF0Y2ggfHxcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlcnJvciB3b3VsZCBoYXBwZW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIGlzIHVuY2F0Y2hhYmxlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0c2lkZS4gU28ganVzdCBsb2cgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfSwgb2xkVGltZW91dFxuICAgICAgICAgICAgICAgID8gdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXV0b0JhdGNoSW5pdGlhbERlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2luZm9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHNlcnZlciBpbmZvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaEVuZHBvaW50SXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUnVuKHJ1bikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtydW5dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb25fbmFtZSA9IHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGRlbGV0ZSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh7XG4gICAgICAgICAgICBzZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSA/PyBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjcmVhdGVcIixcbiAgICAgICAgICAgICAgICBpdGVtOiBydW5DcmVhdGUsXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRSdW5DcmVhdGVQYXJhbXMgPSBhd2FpdCBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhbXG4gICAgICAgICAgICBydW5DcmVhdGUsXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXJnZWRSdW5DcmVhdGVQYXJhbXNbMF0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcnVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9KSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gcnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdO1xuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBydW5VcGRhdGVzPy5tYXAoKHVwZGF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSkgPz8gW107XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdCYXRjaCA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkQ3JlYXRlUGFyYW1zKSxcbiAgICAgICAgICAgIHBhdGNoOiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZFVwZGF0ZVBhcmFtcywgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMocHJlcGFyZWRDcmVhdGVQYXJhbXMpO1xuICAgICAgICBpZiAodGhpcy5iYXRjaEVuZHBvaW50U3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hFbmRwb2ludFN1cHBvcnRlZCA9IGF3YWl0IHRoaXMuYmF0Y2hFbmRwb2ludElzU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoRW5kcG9pbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVwYXJlZENyZWF0ZVBhcmFtIG9mIHJhd0JhdGNoLnBvc3QpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJ1bihwcmVwYXJlZENyZWF0ZVBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcGFyZWRVcGRhdGVQYXJhbSBvZiByYXdCYXRjaC5wYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlZFVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVSdW4ocHJlcGFyZWRVcGRhdGVQYXJhbS5pZCwgcHJlcGFyZWRVcGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gdGhpcy5zZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVM7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1wicG9zdFwiLCBcInBhdGNoXCJdKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hJdGVtcyA9IHJhd0JhdGNoW2tleV0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoYmF0Y2hJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEJhdGNoSXRlbSA9IEpTT04uc3RyaW5naWZ5KGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCYXRjaFNpemVCeXRlcyA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJhdGNoU2l6ZUJ5dGVzICsgc3RyaW5naWZpZWRCYXRjaEl0ZW0ubGVuZ3RoID4gc2l6ZUxpbWl0Qnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhKU09OLnN0cmluZ2lmeShiYXRjaENodW5rcykpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaENodW5rcy5wb3N0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQ2h1bmtzLnBhdGNoID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCYXRjaFNpemVCeXRlcyArPSBzdHJpbmdpZmllZEJhdGNoSXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmF0Y2hDaHVua3Nba2V5XS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hDaHVua3MucG9zdC5sZW5ndGggPiAwIHx8IGJhdGNoQ2h1bmtzLnBhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoSlNPTi5zdHJpbmdpZnkoYmF0Y2hDaHVua3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcG9zdEJhdGNoSW5nZXN0UnVucyhib2R5KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYmF0Y2ggY3JlYXRlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiYgZGF0YS5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgYmF0Y2ggYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgYmxvY2sgdG8gZW5zdXJlIHRyYWNlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnMgZnJvbSB0aGUgTGFuZ1NtaXRoIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHBhcmVudFJ1bklkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gdHJhY2VJZCAtIFRoZSBJRCBvZiB0aGUgdHJhY2UgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VFeGFtcGxlSWQgLSBUaGUgSUQgb2YgdGhlIHJlZmVyZW5jZSBleGFtcGxlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBleGVjdXRpb25PcmRlciAtIFRoZSBleGVjdXRpb24gb3JkZXIgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcnVucyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxSdW4+fSAtIFRoZSBydW5zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHByb2plY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBMTE0gYW5kIENoYXQgcnVucyBpbiB0aGUgbGFzdCAyNCBob3Vyc1xuICAgICAqIGNvbnN0IHRvZGF5c0xMTVJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSxcbiAgICAgKiAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHRyYWNlcyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCByb290UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXhlY3V0aW9uX29yZGVyOiAxLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgd2l0aG91dCBlcnJvcnNcbiAgICAgKiBjb25zdCBjb3JyZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXJyb3I6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgYnkgcnVuIElEXG4gICAgICogY29uc3QgcnVuSWRzID0gW1xuICAgICAqICAgXCJhMzYwOTJkMi00YWQ1LTRmYjQtOWMwZC0wZGJhOWEyZWQ4MzZcIixcbiAgICAgKiAgIFwiOTM5OGU2YmUtOTY0Zi00YWE0LThhZTktYWQ3OGNkNGI3MDc0XCIsXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBzZWxlY3RlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBydW5faWRzOiBydW5JZHMgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIFwiY2hhaW5cIiB0eXBlIHJ1bnMgdGhhdCB0b29rIG1vcmUgdGhhbiAxMCBzZWNvbmRzIGFuZCBoYWQgYHRvdGFsX3Rva2Vuc2AgZ3JlYXRlciB0aGFuIDUwMDBcbiAgICAgKiBjb25zdCBjaGFpblJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChlcShydW5fdHlwZSwgXCJjaGFpblwiKSwgZ3QobGF0ZW5jeSwgMTApLCBndCh0b3RhbF90b2tlbnMsIDUwMDApKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgY2FsbGVkIFwiZXh0cmFjdG9yXCIgd2hvc2Ugcm9vdCBvZiB0aGUgdHJhY2Ugd2FzIGFzc2lnbmVkIGZlZWRiYWNrIFwidXNlcl9zY29yZVwiIHNjb3JlIG9mIDFcbiAgICAgKiBjb25zdCBnb29kRXh0cmFjdG9yUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnZXEobmFtZSwgXCJleHRyYWN0b3JcIiknLFxuICAgICAqICAgdHJhY2VGaWx0ZXI6ICdhbmQoZXEoZmVlZGJhY2tfa2V5LCBcInVzZXJfc2NvcmVcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAxKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHRoYXQgc3RhcnRlZCBhZnRlciBhIHNwZWNpZmljIHRpbWVzdGFtcCBhbmQgZWl0aGVyIGhhdmUgXCJlcnJvclwiIG5vdCBlcXVhbCB0byBudWxsIG9yIGEgXCJDb3JyZWN0bmVzc1wiIGZlZWRiYWNrIHNjb3JlIGVxdWFsIHRvIDBcbiAgICAgKiBjb25zdCBjb21wbGV4UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGd0KHN0YXJ0X3RpbWUsIFwiMjAyMy0wNy0xNVQxMjozNDo1NlpcIiksIG9yKG5lcShlcnJvciwgbnVsbCksIGFuZChlcShmZWVkYmFja19rZXksIFwiQ29ycmVjdG5lc3NcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAwLjApKSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB3aGVyZSBgdGFnc2AgaW5jbHVkZSBcImV4cGVyaW1lbnRhbFwiIG9yIFwiYmV0YVwiIGFuZCBgbGF0ZW5jeWAgaXMgZ3JlYXRlciB0aGFuIDIgc2Vjb25kc1xuICAgICAqIGNvbnN0IHRhZ2dlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChvcihoYXModGFncywgXCJleHBlcmltZW50YWxcIiksIGhhcyh0YWdzLCBcImJldGFcIikpLCBndChsYXRlbmN5LCAyKSknLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHBhcmVudFJ1bklkLCB0cmFjZUlkLCByZWZlcmVuY2VFeGFtcGxlSWQsIHN0YXJ0VGltZSwgZXhlY3V0aW9uT3JkZXIsIHJ1blR5cGUsIGVycm9yLCBpZCwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGxpbWl0LCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbk9yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgZGF0YXNldFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24gJHtwcm9qZWN0TmFtZX06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9qZWN0ICR7cHJvamVjdElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWRffWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRhaWwgJiYgcmVzdWx0LmRldGFpbC5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0ICR7ZmlsZU5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgQ1NWOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGFzZXQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0cywgb3V0cHV0cywgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBjcmVhdGVkQXQsIGV4YW1wbGVJZCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IGNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgc291cmNlUnVuSWRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzID8gb3V0cHV0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzID8gZXhhbXBsZUlkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcyA/IHNvdXJjZVJ1bklkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWRFeGFtcGxlcyksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkLCB1cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlcy8ke2V4YW1wbGVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGV4YW1wbGUgJHtleGFtcGxlSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVSdW4ocnVuLCBldmFsdWF0b3IsIHsgc291cmNlSW5mbywgbG9hZENoaWxkUnVucywgcmVmZXJlbmNlRXhhbXBsZSwgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gPz8ge307XG4gICAgICAgIGlmIChmZWVkYmFja1Jlc3VsdC5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4uc291cmNlSW5mb18sIC4uLmZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZCA9IGZlZWRiYWNrUmVzdWx0LnRhcmdldFJ1bklkID8/IHJ1bl8uaWQ7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBmZWVkYmFja1Jlc3VsdC5rZXksIHtcbiAgICAgICAgICAgIHNjb3JlOiBmZWVkYmFja1Jlc3VsdD8uc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZTogZmVlZGJhY2tSZXN1bHQ/LnZhbHVlLFxuICAgICAgICAgICAgY29tbWVudDogZmVlZGJhY2tSZXN1bHQ/LmNvbW1lbnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiBmZWVkYmFja1Jlc3VsdD8uY29ycmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgZmVlZGJhY2tTb3VyY2VUeXBlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICBzb3VyY2VSdW5JZDogZmVlZGJhY2tSZXN1bHQ/LnNvdXJjZVJ1bklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBmZWVkYmFja0NvbmZpZywgfSkge1xuICAgICAgICBjb25zdCBmZWVkYmFja19zb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBmZWVkYmFja1NvdXJjZVR5cGUgPz8gXCJhcGlcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzb3VyY2VJbmZvID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlUnVuSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0pIHtcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdID0geyBydW5faWQ6IHNvdXJjZVJ1bklkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0/LnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdLnJ1bl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2sgPSB7XG4gICAgICAgICAgICBpZDogZmVlZGJhY2tJZCA/PyB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlOiBmZWVkYmFja19zb3VyY2UsXG4gICAgICAgICAgICBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGZlZWRiYWNrXCIpO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZmVlZGJhY2tcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VuIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYXV0aG9yaXplIGZlZWRiYWNrIG1ldHJpY3Mgd2l0aG91dFxuICAgICAqIG5lZWRpbmcgYW4gQVBJIGtleS4gVGhpcyBpcyB1c2VmdWwgZm9yIGdpdmluZyBicm93c2VyLWJhc2VkXG4gICAgICogYXBwbGljYXRpb25zIHRoZSBhYmlsaXR5IHRvIHN1Ym1pdCBmZWVkYmFjayB3aXRob3V0IG5lZWRpbmdcbiAgICAgKiB0byBleHBvc2UgYW4gQVBJIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBydW5JZCAtIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSBmZWVkYmFja0tleSAtIFRoZSBmZWVkYmFjayBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5leHBpcmF0aW9uIC0gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGZWVkYmFja0luZ2VzdFRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4ocnVuSWQsIGZlZWRiYWNrS2V5LCB7IGV4cGlyYXRpb24sIGZlZWRiYWNrQ29uZmlnLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBmZWVkYmFja19rZXk6IGZlZWRiYWNrS2V5LFxuICAgICAgICAgICAgZmVlZGJhY2tfY29uZmlnOiBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2F0XCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cGlyYXRpb24/LmhvdXJzIHx8IGV4cGlyYXRpb24/Lm1pbnV0ZXMgfHwgZXhwaXJhdGlvbj8uZGF5cykge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0ge1xuICAgICAgICAgICAgICAgIGhvdXJzOiAzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay90b2tlbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbnMgZm9yIGEgZ2l2ZW4gcnVuIElELlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBpdGVyYWJsZSBvZiBGZWVkYmFja0luZ2VzdFRva2VuIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RQcmVzaWduZWRGZWVkYmFja1Rva2VucyhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHJ1bl9pZDogcnVuSWQgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdG9rZW5zIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFjay90b2tlbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHRva2VucztcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiQXN5bmNDYWxsZXIiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImlzTGFuZ0NoYWluTWVzc2FnZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJfX3ZlcnNpb25fXyIsIm1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGVzIiwicnVucyIsInJ1bnRpbWVFbnYiLCJlbnZWYXJzIiwibWFwIiwicnVuIiwiZXh0cmEiLCJtZXRhZGF0YSIsInJ1bnRpbWUiLCJyZXZpc2lvbl9pZCIsImdldFRyYWNpbmdTYW1wbGluZ1JhdGUiLCJzYW1wbGluZ1JhdGVTdHIiLCJ1bmRlZmluZWQiLCJzYW1wbGluZ1JhdGUiLCJwYXJzZUZsb2F0IiwiRXJyb3IiLCJpc0xvY2FsaG9zdCIsInVybCIsInN0cmlwcGVkVXJsIiwicmVwbGFjZSIsImhvc3RuYW1lIiwic3BsaXQiLCJyYWlzZUZvclN0YXR1cyIsInJlc3BvbnNlIiwib3BlcmF0aW9uIiwiYm9keSIsInRleHQiLCJvayIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJ0b0FycmF5IiwiaXRlcmFibGUiLCJyZXN1bHQiLCJpdGVtIiwicHVzaCIsInRyaW1RdW90ZXMiLCJzdHIiLCJ0cmltIiwiYXNzZXJ0VXVpZCIsInZhbGlkYXRlIiwiaGFuZGxlNDI5IiwicmV0cnlBZnRlciIsInBhcnNlSW50IiwiaGVhZGVycyIsImdldCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIlF1ZXVlIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwic2l6ZSIsIml0ZW1zIiwibGVuZ3RoIiwicG9wIiwidXBUb04iLCJwb3BwZWQiLCJzaGlmdCIsIml0IiwiZm9yRWFjaCIsIkRFRkFVTFRfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyIsIkNsaWVudCIsImNvbmZpZyIsIlNldCIsImRlZmF1bHRDb25maWciLCJnZXREZWZhdWx0Q2xpZW50Q29uZmlnIiwidHJhY2luZ1NhbXBsZVJhdGUiLCJhcGlVcmwiLCJhcGlLZXkiLCJ3ZWJVcmwiLCJ0aW1lb3V0X21zIiwiY2FsbGVyIiwiY2FsbGVyT3B0aW9ucyIsImJhdGNoSW5nZXN0Q2FsbGVyIiwib25GYWlsZWRSZXNwb25zZUhvb2siLCJoaWRlSW5wdXRzIiwiaGlkZU91dHB1dHMiLCJhdXRvQmF0Y2hUcmFjaW5nIiwicGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQiLCJnZXRIb3N0VXJsIiwiaW5jbHVkZXMiLCJlbmRzV2l0aCIsInByb2Nlc3NJbnB1dHMiLCJpbnB1dHMiLCJwcm9jZXNzT3V0cHV0cyIsIm91dHB1dHMiLCJwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMiLCJydW5QYXJhbXMiLCJfZ2V0UmVzcG9uc2UiLCJwYXRoIiwicXVlcnlQYXJhbXMiLCJwYXJhbXNTdHJpbmciLCJ0b1N0cmluZyIsImNhbGwiLCJmZXRjaCIsIm1ldGhvZCIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIl9nZXQiLCJqc29uIiwiX2dldFBhZ2luYXRlZCIsIlVSTFNlYXJjaFBhcmFtcyIsIm9mZnNldCIsIk51bWJlciIsImxpbWl0Iiwic2V0IiwiU3RyaW5nIiwiX2dldEN1cnNvclBhZ2luYXRlZExpc3QiLCJyZXF1ZXN0TWV0aG9kIiwiZGF0YUtleSIsImJvZHlQYXJhbXMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VCb2R5IiwiY3Vyc29ycyIsIm5leHQiLCJjdXJzb3IiLCJfZmlsdGVyRm9yU2FtcGxpbmciLCJwYXRjaCIsInNhbXBsZWQiLCJzYW1wbGVkUG9zdFV1aWRzIiwiaGFzIiwiaWQiLCJkZWxldGUiLCJNYXRoIiwicmFuZG9tIiwiYWRkIiwiZHJhaW5BdXRvQmF0Y2hRdWV1ZSIsImF1dG9CYXRjaFF1ZXVlIiwiYmF0Y2giLCJkb25lIiwiYmF0Y2hJbmdlc3RSdW5zIiwicnVuQ3JlYXRlcyIsImZpbHRlciIsImFjdGlvbiIsInJ1blVwZGF0ZXMiLCJwcm9jZXNzUnVuT3BlcmF0aW9uIiwiaW1tZWRpYXRlbHlUcmlnZ2VyQmF0Y2giLCJvbGRUaW1lb3V0IiwiYXV0b0JhdGNoVGltZW91dCIsImNsZWFyVGltZW91dCIsIml0ZW1Qcm9taXNlIiwiY2F0Y2giLCJjb25zb2xlIiwiZXJyb3IiLCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMiLCJhdXRvQmF0Y2hJbml0aWFsRGVsYXlNcyIsIl9nZXRTZXJ2ZXJJbmZvIiwiQWNjZXB0IiwiYmF0Y2hFbmRwb2ludElzU3VwcG9ydGVkIiwic2VydmVySW5mbyIsImUiLCJjcmVhdGVSdW4iLCJzZXNzaW9uX25hbWUiLCJwcm9qZWN0X25hbWUiLCJydW5DcmVhdGUiLCJzdGFydF90aW1lIiwiRGF0ZSIsIm5vdyIsInRyYWNlX2lkIiwiZG90dGVkX29yZGVyIiwibWVyZ2VkUnVuQ3JlYXRlUGFyYW1zIiwicHJlcGFyZWRDcmVhdGVQYXJhbXMiLCJjcmVhdGUiLCJwcmVwYXJlZFVwZGF0ZVBhcmFtcyIsInVwZGF0ZSIsImNyZWF0ZUJ5SWQiLCJyZWR1Y2UiLCJwYXJhbXMiLCJzdGFuZGFsb25lVXBkYXRlcyIsInVwZGF0ZVBhcmFtIiwidmFsdWVzIiwicmF3QmF0Y2giLCJwb3N0IiwiYmF0Y2hFbmRwb2ludFN1cHBvcnRlZCIsInByZXBhcmVkQ3JlYXRlUGFyYW0iLCJwcmVwYXJlZFVwZGF0ZVBhcmFtIiwidXBkYXRlUnVuIiwic2l6ZUxpbWl0Qnl0ZXMiLCJiYXRjaF9pbmdlc3RfY29uZmlnIiwic2l6ZV9saW1pdF9ieXRlcyIsImJhdGNoQ2h1bmtzIiwiY3VycmVudEJhdGNoU2l6ZUJ5dGVzIiwiayIsImtleSIsImJhdGNoSXRlbXMiLCJyZXZlcnNlIiwiYmF0Y2hJdGVtIiwic3RyaW5naWZpZWRCYXRjaEl0ZW0iLCJfcG9zdEJhdGNoSW5nZXN0UnVucyIsInJ1bklkIiwiZGF0YSIsImVuZF90aW1lIiwicGFyZW50X3J1bl9pZCIsInJlYWRSdW4iLCJsb2FkQ2hpbGRSdW5zIiwiY2hpbGRfcnVuX2lkcyIsIl9sb2FkQ2hpbGRSdW5zIiwiZ2V0UnVuVXJsIiwicHJvamVjdE9wdHMiLCJzZXNzaW9uSWQiLCJzZXNzaW9uX2lkIiwicHJvamVjdE5hbWUiLCJyZWFkUHJvamVjdCIsInByb2plY3RJZCIsInByb2plY3QiLCJ0ZW5hbnRJZCIsIl9nZXRUZW5hbnRJZCIsInJ1bl8iLCJhcHBfcGF0aCIsImJhc2VVcmwiLCJjaGlsZFJ1bnMiLCJsaXN0UnVucyIsInRyZWVtYXAiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiY2hpbGRSdW4iLCJjaGlsZF9ydW5zIiwicHJvcHMiLCJwYXJlbnRSdW5JZCIsInRyYWNlSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsInJ1blR5cGUiLCJxdWVyeSIsInRyYWNlRmlsdGVyIiwidHJlZUZpbHRlciIsInByb2plY3RJZHMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9qZWN0TmFtZXMiLCJwcm9qZWN0SWRzXyIsImFsbCIsIm5hbWUiLCJ0aGVuIiwic2Vzc2lvbiIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGUiLCJ0cmFjZV9maWx0ZXIiLCJ0cmVlX2ZpbHRlciIsImV4ZWN1dGlvbl9vcmRlciIsInBhcmVudF9ydW4iLCJ0b0lTT1N0cmluZyIsInRyYWNlIiwic2hhcmVSdW4iLCJzaGFyZUlkIiwicnVuX2lkIiwic2hhcmVfdG9rZW4iLCJ2NCIsInVuc2hhcmVSdW4iLCJyZWFkUnVuU2hhcmVkTGluayIsImxpc3RTaGFyZWRSdW5zIiwic2hhcmVUb2tlbiIsInJ1bklkcyIsImFwcGVuZCIsInJlYWREYXRhc2V0U2hhcmVkU2NoZW1hIiwiZGF0YXNldElkIiwiZGF0YXNldE5hbWUiLCJkYXRhc2V0IiwicmVhZERhdGFzZXQiLCJzaGFyZVNjaGVtYSIsInNoYXJlRGF0YXNldCIsImRhdGFzZXRfaWQiLCJ1bnNoYXJlRGF0YXNldCIsInJlYWRTaGFyZWREYXRhc2V0IiwiY3JlYXRlUHJvamVjdCIsImRlc2NyaXB0aW9uIiwidXBzZXJ0IiwicHJvamVjdEV4dHJhIiwicmVmZXJlbmNlRGF0YXNldElkIiwidXBzZXJ0XyIsImVuZHBvaW50IiwidXBkYXRlUHJvamVjdCIsImVuZFRpbWUiLCJoYXNQcm9qZWN0IiwiaW5jbHVkZVN0YXRzIiwiX3RlbmFudElkIiwicHJvamVjdHMiLCJ0ZW5hbnRfaWQiLCJsaXN0UHJvamVjdHMiLCJuYW1lQ29udGFpbnMiLCJyZWZlcmVuY2VEYXRhc2V0TmFtZSIsInJlZmVyZW5jZUZyZWUiLCJkZWxldGVQcm9qZWN0IiwicHJvamVjdElkXyIsInVwbG9hZENzdiIsImNzdkZpbGUiLCJmaWxlTmFtZSIsImlucHV0S2V5cyIsIm91dHB1dEtleXMiLCJkYXRhVHlwZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJkZXRhaWwiLCJjcmVhdGVEYXRhc2V0IiwiZGF0YV90eXBlIiwicmVhZERhdGFzZXRPcGVuYWlGaW5ldHVuaW5nIiwiZGF0YXNldFRleHQiLCJsaW5lIiwicGFyc2UiLCJsaXN0RGF0YXNldHMiLCJkYXRhc2V0SWRzIiwiZGF0YXNldE5hbWVDb250YWlucyIsImlkXyIsImRhdGFzZXRzIiwiZGVsZXRlRGF0YXNldCIsImRhdGFzZXRJZF8iLCJjcmVhdGVFeGFtcGxlIiwiY3JlYXRlZEF0IiwiZXhhbXBsZUlkIiwiY3JlYXRlZEF0XyIsImNyZWF0ZWRfYXQiLCJjcmVhdGVFeGFtcGxlcyIsInNvdXJjZVJ1bklkcyIsImV4YW1wbGVJZHMiLCJmb3JtYXR0ZWRFeGFtcGxlcyIsImlucHV0IiwiaWR4Iiwic291cmNlX3J1bl9pZCIsImNyZWF0ZUxMTUV4YW1wbGUiLCJnZW5lcmF0aW9uIiwib3B0aW9ucyIsIm91dHB1dCIsImNyZWF0ZUNoYXRFeGFtcGxlIiwiZ2VuZXJhdGlvbnMiLCJmaW5hbElucHV0IiwibWVzc2FnZSIsImZpbmFsT3V0cHV0IiwicmVhZEV4YW1wbGUiLCJsaXN0RXhhbXBsZXMiLCJleGFtcGxlcyIsImRlbGV0ZUV4YW1wbGUiLCJ1cGRhdGVFeGFtcGxlIiwiZXZhbHVhdGVSdW4iLCJldmFsdWF0b3IiLCJzb3VyY2VJbmZvIiwicmVmZXJlbmNlRXhhbXBsZSIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwiZmVlZGJhY2tSZXN1bHQiLCJzb3VyY2VJbmZvXyIsImV2YWx1YXRvckluZm8iLCJ0YXJnZXRSdW5JZCIsImNyZWF0ZUZlZWRiYWNrIiwic2NvcmUiLCJjb21tZW50IiwiY29ycmVjdGlvbiIsImZlZWRiYWNrU291cmNlVHlwZSIsInNvdXJjZVJ1bklkIiwiZmVlZGJhY2tJZCIsImZlZWRiYWNrQ29uZmlnIiwiZmVlZGJhY2tfc291cmNlIiwidHlwZSIsImZlZWRiYWNrIiwidXBkYXRlRmVlZGJhY2siLCJmZWVkYmFja1VwZGF0ZSIsInJlYWRGZWVkYmFjayIsImRlbGV0ZUZlZWRiYWNrIiwibGlzdEZlZWRiYWNrIiwiZmVlZGJhY2tLZXlzIiwiZmVlZGJhY2tTb3VyY2VUeXBlcyIsImpvaW4iLCJmZWVkYmFja3MiLCJjcmVhdGVQcmVzaWduZWRGZWVkYmFja1Rva2VuIiwiZmVlZGJhY2tLZXkiLCJleHBpcmF0aW9uIiwiZmVlZGJhY2tfa2V5IiwiZmVlZGJhY2tfY29uZmlnIiwiaG91cnMiLCJtaW51dGVzIiwiZGF5cyIsImxpc3RQcmVzaWduZWRGZWVkYmFja1Rva2VucyIsInRva2VucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.1.11\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFDSTtBQUN6QyxpQ0FBaUM7QUFDMUIsTUFBTUUsY0FBYyxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/YWEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmV4cG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwiLi9ydW5fdHJlZXMuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjEuMTFcIjtcbiJdLCJuYW1lcyI6WyJDbGllbnQiLCJSdW5UcmVlIiwiX192ZXJzaW9uX18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n\n\n\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) + runId;\n}\nclass RunTree {\n    constructor(config){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = RunTree.getDefaultConfig();\n        const client = config.client ?? new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static fromRunnableConfig(config, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = config?.callbacks;\n        let parentRun;\n        let projectName;\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n        }\n        const deduppedTags = [\n            ...new Set((parentRun?.tags ?? []).concat(config?.tags ?? []))\n        ];\n        const dedupedMetadata = {\n            ...parentRun?.extra?.metadata,\n            ...config?.metadata\n        };\n        const rt = new RunTree({\n            name: props?.name ?? \"<lambda>\",\n            parent_run: parentRun,\n            tags: deduppedTags,\n            extra: {\n                metadata: dedupedMetadata\n            },\n            project_name: projectName\n        });\n        return rt;\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    async createChild(config) {\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client\n        });\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now()) {\n        this.outputs = outputs;\n        this.error = error;\n        this.end_time = endTime;\n    }\n    async _convertToCreate(run, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        const runtimeEnv = await (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n        for (const [k, v] of Object.entries(runtimeEnv)){\n            if (!runExtra.runtime[k]) {\n                runExtra.runtime[k] = v;\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = await Promise.all(run.child_runs.map((child_run)=>this._convertToCreate(child_run, excludeChildRuns)));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        const runCreate = await this._convertToCreate(this, true);\n        await this.client.createRun(runCreate);\n        if (!excludeChildRuns) {\n            warnOnce(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n            for (const childRun of this.child_runs){\n                await childRun.postRun(false);\n            }\n        }\n    }\n    async patchRun() {\n        const runUpdate = {\n            end_time: this.end_time,\n            error: this.error,\n            outputs: this.outputs,\n            parent_run_id: this.parent_run?.id,\n            reference_example_id: this.reference_example_id,\n            extra: this.extra,\n            events: this.events,\n            dotted_order: this.dotted_order,\n            trace_id: this.trace_id,\n            tags: this.tags\n        };\n        await this.client.updateRun(this.id, runUpdate);\n    }\n}\nfunction isRunTree(x) {\n    return x !== undefined && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>{\n        return typeof callback.name === \"string\" && callback.name === \"langchain_tracer\";\n    });\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return x !== undefined && typeof x.callbacks === \"object\" && // Callback manager with a langchain tracer\n    (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(x.callbacks));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDa0Q7QUFDMUM7QUFDckMsTUFBTUksaUJBQWlCLENBQUM7QUFDeEIsU0FBU0MsU0FBU0MsT0FBTztJQUNyQixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0o7QUFDQSxTQUFTRyxxQkFBcUJDLEtBQUs7SUFDL0IsT0FBT0EsTUFBTUMsT0FBTyxDQUFDLFVBQVU7QUFDbkM7QUFDTyxTQUFTQywyQkFBMkJDLEtBQUssRUFBRUMsS0FBSztJQUNuRCxPQUFRTCxxQkFBcUIsQ0FBQyxFQUFFLElBQUlNLEtBQUtGLE9BQU9HLFdBQVcsR0FBR0MsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUM1RUg7QUFDUjtBQUNPLE1BQU1JO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxNQUFNO1lBQzlCQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxZQUFZO1lBQ3BDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxnQkFBZ0I7WUFDeENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFVBQVU7WUFDbENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7WUFDbkNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtR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LEVBQUVoRSxTQUFTO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzPzUxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50IH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5mdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gICAgaWYgKCF3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQpIHtcbiAgICByZXR1cm4gKHN0cmlwTm9uQWxwaGFudW1lcmljKGAke25ldyBEYXRlKGVwb2NoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKX0wMDBaYCkgK1xuICAgICAgICBydW5JZCk7XG59XG5leHBvcnQgY2xhc3MgUnVuVHJlZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuX3R5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmVudF9ydW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hpbGRfcnVuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuZF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4dHJhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VyaWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvdHRlZF9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbmZpZy5jbGllbnQgPz8gbmV3IENsaWVudCgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnLCBjbGllbnQgfSk7XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQgPz8gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb3R0ZWRPcmRlciA9IGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KHRoaXMuc3RhcnRfdGltZSwgdGhpcy5pZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9ydW4uZG90dGVkX29yZGVyICsgXCIuXCIgKyBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bm5hYmxlQ29uZmlnKGNvbmZpZywgcHJvcHMpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYW5kbGUgdGhlIGNhbGxiYWNrIG1hbmFnZXIgY2FzZSBmb3Igbm93XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IGNvbmZpZz8uY2FsbGJhY2tzO1xuICAgICAgICBsZXQgcGFyZW50UnVuO1xuICAgICAgICBsZXQgcHJvamVjdE5hbWU7XG4gICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJ1bklkID0gY2FsbGJhY2tNYW5hZ2VyPy5nZXRQYXJlbnRSdW5JZD8uKCkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxhbmdDaGFpblRyYWNlciA9IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlcnM/LmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXI/Lm5hbWUgPT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICAgICAgcGFyZW50UnVuID0gbGFuZ0NoYWluVHJhY2VyPy5nZXRSdW4/LihwYXJlbnRSdW5JZCk7XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA9IGxhbmdDaGFpblRyYWNlcj8ucHJvamVjdE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVkdXBwZWRUYWdzID0gW1xuICAgICAgICAgICAgLi4ubmV3IFNldCgocGFyZW50UnVuPy50YWdzID8/IFtdKS5jb25jYXQoY29uZmlnPy50YWdzID8/IFtdKSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGRlZHVwZWRNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLnBhcmVudFJ1bj8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4uY29uZmlnPy5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICBuYW1lOiBwcm9wcz8ubmFtZSA/PyBcIjxsYW1iZGE+XCIsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW4sXG4gICAgICAgICAgICB0YWdzOiBkZWR1cHBlZFRhZ3MsXG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBkZWR1cGVkTWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydDtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpID8/XG4gICAgICAgICAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBhcGlfdXJsOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/IFwiaHR0cDovL2xvY2FsaG9zdDoxOTg0XCIsXG4gICAgICAgICAgICBhcGlfa2V5OiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0FQSV9LRVlcIiksXG4gICAgICAgICAgICBjYWxsZXJfb3B0aW9uczoge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgc2VyaWFsaXplZDoge30sXG4gICAgICAgICAgICBpbnB1dHM6IHt9LFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGlsZChjb25maWcpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiB0aGlzLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoaWxkX3J1bnMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dHMsIGVycm9yLCBlbmRUaW1lID0gRGF0ZS5ub3coKSkge1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZW5kX3RpbWUgPSBlbmRUaW1lO1xuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcnVuRXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgICAgIGlmICghcnVuRXh0cmEucnVudGltZSkge1xuICAgICAgICAgICAgcnVuRXh0cmEucnVudGltZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBhd2FpdCBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocnVudGltZUVudikpIHtcbiAgICAgICAgICAgIGlmICghcnVuRXh0cmEucnVudGltZVtrXSkge1xuICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWVba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZF9ydW5zO1xuICAgICAgICBsZXQgcGFyZW50X3J1bl9pZDtcbiAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBjaGlsZF9ydW5zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuLmNoaWxkX3J1bnMubWFwKChjaGlsZF9ydW4pID0+IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZShjaGlsZF9ydW4sIGV4Y2x1ZGVDaGlsZFJ1bnMpKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiBydW5FeHRyYSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJ1bi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW4ucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogY2hpbGRfcnVucyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcnVuQ3JlYXRlID0gYXdhaXQgdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHRydWUpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocnVuQ3JlYXRlKTtcbiAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcIlBvc3Rpbmcgd2l0aCBleGNsdWRlQ2hpbGRSdW5zPWZhbHNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgdGhpcy5jaGlsZF9ydW5zKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGF0Y2hSdW4oKSB7XG4gICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXG4gICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiB0aGlzLnBhcmVudF9ydW4/LmlkLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogdGhpcy5leHRyYSxcbiAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHRoaXMudHJhY2VfaWQsXG4gICAgICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnVwZGF0ZVJ1bih0aGlzLmlkLCBydW5VcGRhdGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1J1blRyZWUoeCkge1xuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiB4LmNyZWF0ZUNoaWxkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIHgucG9zdFJ1biA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHgpICYmXG4gICAgICAgIHguc29tZSgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGNhbGxiYWNrLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgIH0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlQ29uZmlnTGlrZSh4KSB7XG4gICAgLy8gQ2hlY2sgdGhhdCBpdCdzIGFuIG9iamVjdCB3aXRoIGEgY2FsbGJhY2tzIGFyZ1xuICAgIC8vIHRoYXQgaGFzIGVpdGhlciBhIENhbGxiYWNrTWFuYWdlckxpa2Ugb2JqZWN0IHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyIHdpdGhpbiBpdFxuICAgIC8vIG9yIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgeC5jYWxsYmFja3MgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgLy8gQ2FsbGJhY2sgbWFuYWdlciB3aXRoIGEgbGFuZ2NoYWluIHRyYWNlclxuICAgICAgICAoY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHguY2FsbGJhY2tzPy5oYW5kbGVycykgfHxcbiAgICAgICAgICAgIC8vIE9yIGl0J3MgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgICAgICAgICAgY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlKHguY2FsbGJhY2tzKSkpO1xufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwiQ2xpZW50Iiwid2FybmVkTWVzc2FnZXMiLCJ3YXJuT25jZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsInN0cmlwTm9uQWxwaGFudW1lcmljIiwiaW5wdXQiLCJyZXBsYWNlIiwiY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQiLCJlcG9jaCIsInJ1bklkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJSdW5UcmVlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiZGVmYXVsdENvbmZpZyIsImdldERlZmF1bHRDb25maWciLCJjbGllbnQiLCJhc3NpZ24iLCJ0cmFjZV9pZCIsInBhcmVudF9ydW4iLCJpZCIsImRvdHRlZF9vcmRlciIsImN1cnJlbnREb3R0ZWRPcmRlciIsInN0YXJ0X3RpbWUiLCJmcm9tUnVubmFibGVDb25maWciLCJwcm9wcyIsImNhbGxiYWNrTWFuYWdlciIsImNhbGxiYWNrcyIsInBhcmVudFJ1biIsInByb2plY3ROYW1lIiwicGFyZW50UnVuSWQiLCJnZXRQYXJlbnRSdW5JZCIsImxhbmdDaGFpblRyYWNlciIsImhhbmRsZXJzIiwiZmluZCIsImhhbmRsZXIiLCJuYW1lIiwiZ2V0UnVuIiwiZGVkdXBwZWRUYWdzIiwiU2V0IiwidGFncyIsImNvbmNhdCIsImRlZHVwZWRNZXRhZGF0YSIsImV4dHJhIiwibWV0YWRhdGEiLCJydCIsInByb2plY3RfbmFtZSIsInY0IiwicnVuX3R5cGUiLCJjaGlsZF9ydW5zIiwiYXBpX3VybCIsImFwaV9rZXkiLCJjYWxsZXJfb3B0aW9ucyIsIm5vdyIsInNlcmlhbGl6ZWQiLCJpbnB1dHMiLCJjcmVhdGVDaGlsZCIsImNoaWxkIiwicHVzaCIsImVuZCIsIm91dHB1dHMiLCJlcnJvciIsImVuZFRpbWUiLCJlbmRfdGltZSIsIl9jb252ZXJ0VG9DcmVhdGUiLCJydW4iLCJleGNsdWRlQ2hpbGRSdW5zIiwicnVuRXh0cmEiLCJydW50aW1lIiwicnVudGltZUVudiIsImsiLCJ2IiwiZW50cmllcyIsInBhcmVudF9ydW5faWQiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY2hpbGRfcnVuIiwidW5kZWZpbmVkIiwicGVyc2lzdGVkUnVuIiwicmVmZXJlbmNlX2V4YW1wbGVfaWQiLCJzZXNzaW9uX25hbWUiLCJwb3N0UnVuIiwicnVuQ3JlYXRlIiwiY3JlYXRlUnVuIiwiY2hpbGRSdW4iLCJwYXRjaFJ1biIsInJ1blVwZGF0ZSIsImV2ZW50cyIsInVwZGF0ZVJ1biIsImlzUnVuVHJlZSIsIngiLCJjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiY2FsbGJhY2siLCJpc1J1bm5hYmxlQ29uZmlnTGlrZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        const PQueue =  true ? p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"] : p_queue__WEBPACK_IMPORTED_MODULE_1__;\n        this.queue = new PQueue({\n            concurrency: this.maxConcurrency\n        });\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                async onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response = error?.response;\n                    const status = response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                        if (onFailedResponseHook) {\n                            await onFailedResponseHook(response);\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>fetch(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNHO0FBQ2hDLE1BQU1FLGtCQUFrQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxnQkFBZ0I7SUFDbEI7Q0FDSDtBQUNEOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1DO0lBQ1RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxrQkFBa0I7WUFDMUNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLHdCQUF3QjtZQUNoREMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUdQLE9BQU9PLGNBQWMsSUFBSUM7UUFDL0MsSUFBSSxDQUFDQyxVQUFVLEdBQUdULE9BQU9TLFVBQVUsSUFBSTtRQUN2QyxNQUFNQyxTQUFTLEtBQXNCZixHQUFHQSwrQ0FBaUIsR0FBR0Esb0NBQVNBO1FBQ3JFLElBQUksQ0FBQ2lCLEtBQUssR0FBRyxJQUFJRixPQUFPO1lBQUVHLGFBQWEsSUFBSSxDQUFDTixjQUFjO1FBQUM7UUFDM0QsSUFBSSxDQUFDTyxvQkFBb0IsR0FBR2QsUUFBUWM7SUFDeEM7SUFDQSw4REFBOEQ7SUFDOURDLEtBQUtDLFFBQVEsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDcEIsTUFBTUgsdUJBQXVCLElBQUksQ0FBQ0Esb0JBQW9CO1FBQ3RELE9BQU8sSUFBSSxDQUFDRixLQUFLLENBQUNNLEdBQUcsQ0FBQyxJQUFNeEIsb0NBQU1BLENBQUMsSUFBTXNCLFlBQVlDLE1BQU1FLEtBQUssQ0FBQyxDQUFDQztvQkFDOUQsdURBQXVEO29CQUN2RCxJQUFJQSxpQkFBaUJDLE9BQU87d0JBQ3hCLE1BQU1EO29CQUNWLE9BQ0s7d0JBQ0QsTUFBTSxJQUFJQyxNQUFNRDtvQkFDcEI7Z0JBQ0osSUFBSTtnQkFDQSxNQUFNRSxpQkFBZ0JGLEtBQUs7b0JBQ3ZCLElBQUlBLE1BQU1HLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLGFBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxtQkFDekJKLE1BQU1HLE9BQU8sQ0FBQ0MsVUFBVSxDQUFDLGVBQWU7d0JBQ3hDLE1BQU1KO29CQUNWO29CQUNBLDhEQUE4RDtvQkFDOUQsSUFBSUEsT0FBT0ssU0FBUyxnQkFBZ0I7d0JBQ2hDLE1BQU1MO29CQUNWO29CQUNBLDhEQUE4RDtvQkFDOUQsTUFBTU0sV0FBV04sT0FBT007b0JBQ3hCLE1BQU1DLFNBQVNELFVBQVVDO29CQUN6QixJQUFJQSxRQUFRO3dCQUNSLElBQUkvQixnQkFBZ0JnQyxRQUFRLENBQUMsQ0FBQ0QsU0FBUzs0QkFDbkMsTUFBTVA7d0JBQ1YsT0FDSyxJQUFJdkIsY0FBYytCLFFBQVEsQ0FBQyxDQUFDRCxTQUFTOzRCQUN0Qzt3QkFDSjt3QkFDQSxJQUFJYixzQkFBc0I7NEJBQ3RCLE1BQU1BLHFCQUFxQlk7d0JBQy9CO29CQUNKO2dCQUNKO2dCQUNBLHFEQUFxRDtnQkFDckQsOEJBQThCO2dCQUM5QkcsU0FBUyxJQUFJLENBQUNwQixVQUFVO2dCQUN4QnFCLFdBQVc7WUFDZixJQUFJO1lBQUVDLGdCQUFnQjtRQUFLO0lBQy9CO0lBQ0EsOERBQThEO0lBQzlEQyxnQkFBZ0JDLE9BQU8sRUFBRWpCLFFBQVEsRUFBRSxHQUFHQyxJQUFJLEVBQUU7UUFDeEMsbURBQW1EO1FBQ25ELHdFQUF3RTtRQUN4RSxJQUFJZ0IsUUFBUUMsTUFBTSxFQUFFO1lBQ2hCLE9BQU9DLFFBQVFDLElBQUksQ0FBQztnQkFDaEIsSUFBSSxDQUFDckIsSUFBSSxDQUFDQyxhQUFhQztnQkFDdkIsSUFBSWtCLFFBQVEsQ0FBQ0UsR0FBR0M7b0JBQ1pMLFFBQVFDLE1BQU0sRUFBRUssaUJBQWlCLFNBQVM7d0JBQ3RDRCxPQUFPLElBQUlqQixNQUFNO29CQUNyQjtnQkFDSjthQUNIO1FBQ0w7UUFDQSxPQUFPLElBQUksQ0FBQ04sSUFBSSxDQUFDQyxhQUFhQztJQUNsQztJQUNBdUIsTUFBTSxHQUFHdkIsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFNeUIsU0FBU3ZCLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBU0EsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQ3ZGO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanM/YThkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDMsXG4gICAgNDA0LFxuICAgIDQwNSxcbiAgICA0MDYsXG4gICAgNDA3LFxuICAgIDQwOCwgLy8gUmVxdWVzdCBUaW1lb3V0XG5dO1xuY29uc3QgU1RBVFVTX0lHTk9SRSA9IFtcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZFJlc3BvbnNlSG9va1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICBjb25zdCBQUXVldWUgPSBcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QgPyBQUXVldWVNb2QuZGVmYXVsdCA6IFBRdWV1ZU1vZDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWUoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vayA9IHBhcmFtcz8ub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBvbkZhaWxlZFJlc3BvbnNlSG9vayA9IHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3I/LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTVEFUVVNfSUdOT1JFLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmFpbGVkUmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvbkZhaWxlZFJlc3BvbnNlSG9vayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IGZldGNoKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gKHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInBSZXRyeSIsIlBRdWV1ZU1vZCIsIlNUQVRVU19OT19SRVRSWSIsIlNUQVRVU19JR05PUkUiLCJBc3luY0NhbGxlciIsImNvbnN0cnVjdG9yIiwicGFyYW1zIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIm1heENvbmN1cnJlbmN5IiwiSW5maW5pdHkiLCJtYXhSZXRyaWVzIiwiUFF1ZXVlIiwiZGVmYXVsdCIsInF1ZXVlIiwiY29uY3VycmVuY3kiLCJvbkZhaWxlZFJlc3BvbnNlSG9vayIsImNhbGwiLCJjYWxsYWJsZSIsImFyZ3MiLCJhZGQiLCJjYXRjaCIsImVycm9yIiwiRXJyb3IiLCJvbkZhaWxlZEF0dGVtcHQiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsImNvZGUiLCJyZXNwb25zZSIsInN0YXR1cyIsImluY2x1ZGVzIiwicmV0cmllcyIsInJhbmRvbWl6ZSIsInRocm93T25UaW1lb3V0IiwiY2FsbFdpdGhPcHRpb25zIiwib3B0aW9ucyIsInNpZ25hbCIsIlByb21pc2UiLCJyYWNlIiwiXyIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJvayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nasync function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQ25CO0FBQzFDLElBQUlDO0FBQ0csTUFBTUMsWUFBWSxJQUFNLE1BQTZCLElBQUksQ0FBc0MsQ0FBQztBQUNoRyxNQUFNRyxjQUFjLElBQU0sT0FBT0MsZUFBZSxZQUNuREEsV0FBV0MsV0FBVyxJQUN0QkQsV0FBV0MsV0FBVyxDQUFDQyxJQUFJLEtBQUssNkJBQTZCO0FBQzFELE1BQU1DLFVBQVUsSUFBTSxNQUEwRCxJQUNsRixPQUFPQyxjQUFjLGVBQ2pCQSxDQUFBQSxVQUFVQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxjQUMxQkYsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsUUFBTyxFQUFJO0FBQ3BELHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDdEIsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFNBQVMsWUFBWTtBQUN4RCxnREFBZ0Q7QUFDekMsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFlBQVksZUFDM0MsT0FBT0EsUUFBUUMsUUFBUSxLQUFLLGVBQzVCLE9BQU9ELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGVBQ2pDLENBQUNMLFNBQVM7QUFDUCxNQUFNTSxTQUFTO0lBQ2xCLElBQUlsQixXQUFXO1FBQ1gsT0FBT0E7SUFDWDtJQUNBLElBQUlDLGFBQWE7UUFDYkQsWUFBWTtJQUNoQixPQUNLLElBQUljLFVBQVU7UUFDZmQsWUFBWTtJQUNoQixPQUNLLElBQUlJLGVBQWU7UUFDcEJKLFlBQVk7SUFDaEIsT0FDSyxJQUFJUSxXQUFXO1FBQ2hCUixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVksVUFBVTtRQUNmWixZQUFZO0lBQ2hCLE9BQ0s7UUFDREEsWUFBWTtJQUNoQjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGLElBQUltQjtBQUNHLGVBQWVDO0lBQ2xCLElBQUlELHVCQUF1QkUsV0FBVztRQUNs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NEIsdUJBQXVCMUMsSUFBSSxFQUFFMkIsS0FBSztJQUM5QyxJQUFJLE9BQU9uQixZQUFZLGFBQWE7UUFDaEMsMENBQTBDO1FBQzFDQSxRQUFRTyxHQUFHLENBQUNmLEtBQUssR0FBRzJCO0lBQ3hCO0FBQ0o7QUFDQSxJQUFJZ0I7QUFDSjs7OztDQUlDLEdBQ00sU0FBUzFCO0lBQ1osSUFBSTBCLHFCQUFxQjdCLFdBQVc7UUFDaEMsT0FBTzZCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTTlCLE9BQU82QixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU0wsdUJBQXVCMUI7UUFDdEMsSUFBSStCLFdBQVdoQyxXQUFXO1lBQ3RCK0IsSUFBSSxDQUFDOUIsSUFBSSxHQUFHK0I7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lbnYuanM/YTc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbmxpbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlXG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xubGV0IGdsb2JhbEVudjtcbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsRW52KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFbnY7XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxFbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgc2RrOiBcImxhbmdzbWl0aC1qc1wiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IF9fdmVyc2lvbl9fLFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFNlbnNpdGl2ZSBrZXlzIChjb250YWluaW5nIHRoZSB3b3JkIFwia2V5XCIsIFwidG9rZW5cIiwgb3IgXCJzZWNyZXRcIikgaGF2ZSB0aGVpciB2YWx1ZXMgcmVkYWN0ZWQgZm9yIHNlY3VyaXR5LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnMoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldEVudmlyb25tZW50VmFyaWFibGVzKCkgfHwge307XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBlbnZWYXJzKSB7XG4gICAgICAgIGlmICgoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgfHxcbiAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGVudlZhcnNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbnZWYXJzW2tleV07XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICsgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICsgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdDaGFpbi1zcGVjaWZpYyBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtcbiAgICAgICAgXCJMQU5HQ0hBSU5fQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG4iXSwibmFtZXMiOlsiX192ZXJzaW9uX18iLCJnbG9iYWxFbnYiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImlzV2ViV29ya2VyIiwiZ2xvYmFsVGhpcyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImlzSnNEb20iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsImlzRGVubyIsIkRlbm8iLCJpc05vZGUiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwiZ2V0RW52IiwicnVudGltZUVudmlyb25tZW50IiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwidW5kZWZpbmVkIiwiZW52IiwicmVsZWFzZUVudiIsImdldFNoYXMiLCJsaWJyYXJ5IiwicnVudGltZSIsInNkayIsInNka192ZXJzaW9uIiwiZ2V0TGFuZ0NoYWluRW52VmFycyIsImFsbEVudlZhcnMiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImVudlZhcnMiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwidG9Mb3dlckNhc2UiLCJzbGljZSIsInJlcGVhdCIsImxlbmd0aCIsImdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSIsImV4Y2x1ZGVkIiwicmVkdWNlIiwiYWNjIiwiU3RyaW5nIiwiZSIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJzZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiY2FjaGVkQ29tbWl0U0hBcyIsImNvbW1vbl9yZWxlYXNlX2VudnMiLCJzaGFzIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(message) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFBbUJDLE9BQU87SUFDdEMsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanM/NDczYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIl0sIm5hbWVzIjpbImlzTGFuZ0NoYWluTWVzc2FnZSIsIm1lc3NhZ2UiLCJfZ2V0VHlwZSIsImNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlIiwiY29udmVydGVkIiwidHlwZSIsImRhdGEiLCJjb250ZW50IiwiYWRkaXRpb25hbF9rd2FyZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvaW5kZXguanM/MTgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvaW5kZXguanMnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ })

};
;