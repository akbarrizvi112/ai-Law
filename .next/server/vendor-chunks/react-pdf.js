"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-pdf";
exports.ids = ["vendor-chunks/react-pdf"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = root.pdfjsLib = factory();\n    else {}\n})(globalThis, ()=>{\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            /* 1 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.VerbosityLevel = exports1.Util = exports1.UnknownErrorException = exports1.UnexpectedResponseException = exports1.TextRenderingMode = exports1.RenderingIntentFlag = exports1.PromiseCapability = exports1.PermissionFlag = exports1.PasswordResponses = exports1.PasswordException = exports1.PageActionEventType = exports1.OPS = exports1.MissingPDFException = exports1.MAX_IMAGE_SIZE_TO_CACHE = exports1.LINE_FACTOR = exports1.LINE_DESCENT_FACTOR = exports1.InvalidPDFException = exports1.ImageKind = exports1.IDENTITY_MATRIX = exports1.FormatError = exports1.FeatureTest = exports1.FONT_IDENTITY_MATRIX = exports1.DocumentActionEventType = exports1.CMapCompressionType = exports1.BaseException = exports1.BASELINE_FACTOR = exports1.AnnotationType = exports1.AnnotationReplyType = exports1.AnnotationPrefix = exports1.AnnotationMode = exports1.AnnotationFlag = exports1.AnnotationFieldFlag = exports1.AnnotationEditorType = exports1.AnnotationEditorPrefix = exports1.AnnotationEditorParamsType = exports1.AnnotationBorderStyleType = exports1.AnnotationActionEventType = exports1.AbortException = void 0;\n                exports1.assert = assert;\n                exports1.bytesToString = bytesToString;\n                exports1.createValidAbsoluteUrl = createValidAbsoluteUrl;\n                exports1.getModificationDate = getModificationDate;\n                exports1.getUuid = getUuid;\n                exports1.getVerbosityLevel = getVerbosityLevel;\n                exports1.info = info;\n                exports1.isArrayBuffer = isArrayBuffer;\n                exports1.isArrayEqual = isArrayEqual;\n                exports1.isNodeJS = void 0;\n                exports1.normalizeUnicode = normalizeUnicode;\n                exports1.objectFromMap = objectFromMap;\n                exports1.objectSize = objectSize;\n                exports1.setVerbosityLevel = setVerbosityLevel;\n                exports1.shadow = shadow;\n                exports1.string32 = string32;\n                exports1.stringToBytes = stringToBytes;\n                exports1.stringToPDFString = stringToPDFString;\n                exports1.stringToUTF8String = stringToUTF8String;\n                exports1.unreachable = unreachable;\n                exports1.utf8StringToString = utf8StringToString;\n                exports1.warn = warn;\n                const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n                exports1.isNodeJS = isNodeJS;\n                const IDENTITY_MATRIX = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n                exports1.IDENTITY_MATRIX = IDENTITY_MATRIX;\n                const FONT_IDENTITY_MATRIX = [\n                    0.001,\n                    0,\n                    0,\n                    0.001,\n                    0,\n                    0\n                ];\n                exports1.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n                const MAX_IMAGE_SIZE_TO_CACHE = 10e6;\n                exports1.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;\n                const LINE_FACTOR = 1.35;\n                exports1.LINE_FACTOR = LINE_FACTOR;\n                const LINE_DESCENT_FACTOR = 0.35;\n                exports1.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\n                const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\n                exports1.BASELINE_FACTOR = BASELINE_FACTOR;\n                const RenderingIntentFlag = {\n                    ANY: 0x01,\n                    DISPLAY: 0x02,\n                    PRINT: 0x04,\n                    SAVE: 0x08,\n                    ANNOTATIONS_FORMS: 0x10,\n                    ANNOTATIONS_STORAGE: 0x20,\n                    ANNOTATIONS_DISABLE: 0x40,\n                    OPLIST: 0x100\n                };\n                exports1.RenderingIntentFlag = RenderingIntentFlag;\n                const AnnotationMode = {\n                    DISABLE: 0,\n                    ENABLE: 1,\n                    ENABLE_FORMS: 2,\n                    ENABLE_STORAGE: 3\n                };\n                exports1.AnnotationMode = AnnotationMode;\n                const AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\n                exports1.AnnotationEditorPrefix = AnnotationEditorPrefix;\n                const AnnotationEditorType = {\n                    DISABLE: -1,\n                    NONE: 0,\n                    FREETEXT: 3,\n                    STAMP: 13,\n                    INK: 15\n                };\n                exports1.AnnotationEditorType = AnnotationEditorType;\n                const AnnotationEditorParamsType = {\n                    RESIZE: 1,\n                    CREATE: 2,\n                    FREETEXT_SIZE: 11,\n                    FREETEXT_COLOR: 12,\n                    FREETEXT_OPACITY: 13,\n                    INK_COLOR: 21,\n                    INK_THICKNESS: 22,\n                    INK_OPACITY: 23\n                };\n                exports1.AnnotationEditorParamsType = AnnotationEditorParamsType;\n                const PermissionFlag = {\n                    PRINT: 0x04,\n                    MODIFY_CONTENTS: 0x08,\n                    COPY: 0x10,\n                    MODIFY_ANNOTATIONS: 0x20,\n                    FILL_INTERACTIVE_FORMS: 0x100,\n                    COPY_FOR_ACCESSIBILITY: 0x200,\n                    ASSEMBLE: 0x400,\n                    PRINT_HIGH_QUALITY: 0x800\n                };\n                exports1.PermissionFlag = PermissionFlag;\n                const TextRenderingMode = {\n                    FILL: 0,\n                    STROKE: 1,\n                    FILL_STROKE: 2,\n                    INVISIBLE: 3,\n                    FILL_ADD_TO_PATH: 4,\n                    STROKE_ADD_TO_PATH: 5,\n                    FILL_STROKE_ADD_TO_PATH: 6,\n                    ADD_TO_PATH: 7,\n                    FILL_STROKE_MASK: 3,\n                    ADD_TO_PATH_FLAG: 4\n                };\n                exports1.TextRenderingMode = TextRenderingMode;\n                const ImageKind = {\n                    GRAYSCALE_1BPP: 1,\n                    RGB_24BPP: 2,\n                    RGBA_32BPP: 3\n                };\n                exports1.ImageKind = ImageKind;\n                const AnnotationType = {\n                    TEXT: 1,\n                    LINK: 2,\n                    FREETEXT: 3,\n                    LINE: 4,\n                    SQUARE: 5,\n                    CIRCLE: 6,\n                    POLYGON: 7,\n                    POLYLINE: 8,\n                    HIGHLIGHT: 9,\n                    UNDERLINE: 10,\n                    SQUIGGLY: 11,\n                    STRIKEOUT: 12,\n                    STAMP: 13,\n                    CARET: 14,\n                    INK: 15,\n                    POPUP: 16,\n                    FILEATTACHMENT: 17,\n                    SOUND: 18,\n                    MOVIE: 19,\n                    WIDGET: 20,\n                    SCREEN: 21,\n                    PRINTERMARK: 22,\n                    TRAPNET: 23,\n                    WATERMARK: 24,\n                    THREED: 25,\n                    REDACT: 26\n                };\n                exports1.AnnotationType = AnnotationType;\n                const AnnotationReplyType = {\n                    GROUP: \"Group\",\n                    REPLY: \"R\"\n                };\n                exports1.AnnotationReplyType = AnnotationReplyType;\n                const AnnotationFlag = {\n                    INVISIBLE: 0x01,\n                    HIDDEN: 0x02,\n                    PRINT: 0x04,\n                    NOZOOM: 0x08,\n                    NOROTATE: 0x10,\n                    NOVIEW: 0x20,\n                    READONLY: 0x40,\n                    LOCKED: 0x80,\n                    TOGGLENOVIEW: 0x100,\n                    LOCKEDCONTENTS: 0x200\n                };\n                exports1.AnnotationFlag = AnnotationFlag;\n                const AnnotationFieldFlag = {\n                    READONLY: 0x0000001,\n                    REQUIRED: 0x0000002,\n                    NOEXPORT: 0x0000004,\n                    MULTILINE: 0x0001000,\n                    PASSWORD: 0x0002000,\n                    NOTOGGLETOOFF: 0x0004000,\n                    RADIO: 0x0008000,\n                    PUSHBUTTON: 0x0010000,\n                    COMBO: 0x0020000,\n                    EDIT: 0x0040000,\n                    SORT: 0x0080000,\n                    FILESELECT: 0x0100000,\n                    MULTISELECT: 0x0200000,\n                    DONOTSPELLCHECK: 0x0400000,\n                    DONOTSCROLL: 0x0800000,\n                    COMB: 0x1000000,\n                    RICHTEXT: 0x2000000,\n                    RADIOSINUNISON: 0x2000000,\n                    COMMITONSELCHANGE: 0x4000000\n                };\n                exports1.AnnotationFieldFlag = AnnotationFieldFlag;\n                const AnnotationBorderStyleType = {\n                    SOLID: 1,\n                    DASHED: 2,\n                    BEVELED: 3,\n                    INSET: 4,\n                    UNDERLINE: 5\n                };\n                exports1.AnnotationBorderStyleType = AnnotationBorderStyleType;\n                const AnnotationActionEventType = {\n                    E: \"Mouse Enter\",\n                    X: \"Mouse Exit\",\n                    D: \"Mouse Down\",\n                    U: \"Mouse Up\",\n                    Fo: \"Focus\",\n                    Bl: \"Blur\",\n                    PO: \"PageOpen\",\n                    PC: \"PageClose\",\n                    PV: \"PageVisible\",\n                    PI: \"PageInvisible\",\n                    K: \"Keystroke\",\n                    F: \"Format\",\n                    V: \"Validate\",\n                    C: \"Calculate\"\n                };\n                exports1.AnnotationActionEventType = AnnotationActionEventType;\n                const DocumentActionEventType = {\n                    WC: \"WillClose\",\n                    WS: \"WillSave\",\n                    DS: \"DidSave\",\n                    WP: \"WillPrint\",\n                    DP: \"DidPrint\"\n                };\n                exports1.DocumentActionEventType = DocumentActionEventType;\n                const PageActionEventType = {\n                    O: \"PageOpen\",\n                    C: \"PageClose\"\n                };\n                exports1.PageActionEventType = PageActionEventType;\n                const VerbosityLevel = {\n                    ERRORS: 0,\n                    WARNINGS: 1,\n                    INFOS: 5\n                };\n                exports1.VerbosityLevel = VerbosityLevel;\n                const CMapCompressionType = {\n                    NONE: 0,\n                    BINARY: 1\n                };\n                exports1.CMapCompressionType = CMapCompressionType;\n                const OPS = {\n                    dependency: 1,\n                    setLineWidth: 2,\n                    setLineCap: 3,\n                    setLineJoin: 4,\n                    setMiterLimit: 5,\n                    setDash: 6,\n                    setRenderingIntent: 7,\n                    setFlatness: 8,\n                    setGState: 9,\n                    save: 10,\n                    restore: 11,\n                    transform: 12,\n                    moveTo: 13,\n                    lineTo: 14,\n                    curveTo: 15,\n                    curveTo2: 16,\n                    curveTo3: 17,\n                    closePath: 18,\n                    rectangle: 19,\n                    stroke: 20,\n                    closeStroke: 21,\n                    fill: 22,\n                    eoFill: 23,\n                    fillStroke: 24,\n                    eoFillStroke: 25,\n                    closeFillStroke: 26,\n                    closeEOFillStroke: 27,\n                    endPath: 28,\n                    clip: 29,\n                    eoClip: 30,\n                    beginText: 31,\n                    endText: 32,\n                    setCharSpacing: 33,\n                    setWordSpacing: 34,\n                    setHScale: 35,\n                    setLeading: 36,\n                    setFont: 37,\n                    setTextRenderingMode: 38,\n                    setTextRise: 39,\n                    moveText: 40,\n                    setLeadingMoveText: 41,\n                    setTextMatrix: 42,\n                    nextLine: 43,\n                    showText: 44,\n                    showSpacedText: 45,\n                    nextLineShowText: 46,\n                    nextLineSetSpacingShowText: 47,\n                    setCharWidth: 48,\n                    setCharWidthAndBounds: 49,\n                    setStrokeColorSpace: 50,\n                    setFillColorSpace: 51,\n                    setStrokeColor: 52,\n                    setStrokeColorN: 53,\n                    setFillColor: 54,\n                    setFillColorN: 55,\n                    setStrokeGray: 56,\n                    setFillGray: 57,\n                    setStrokeRGBColor: 58,\n                    setFillRGBColor: 59,\n                    setStrokeCMYKColor: 60,\n                    setFillCMYKColor: 61,\n                    shadingFill: 62,\n                    beginInlineImage: 63,\n                    beginImageData: 64,\n                    endInlineImage: 65,\n                    paintXObject: 66,\n                    markPoint: 67,\n                    markPointProps: 68,\n                    beginMarkedContent: 69,\n                    beginMarkedContentProps: 70,\n                    endMarkedContent: 71,\n                    beginCompat: 72,\n                    endCompat: 73,\n                    paintFormXObjectBegin: 74,\n                    paintFormXObjectEnd: 75,\n                    beginGroup: 76,\n                    endGroup: 77,\n                    beginAnnotation: 80,\n                    endAnnotation: 81,\n                    paintImageMaskXObject: 83,\n                    paintImageMaskXObjectGroup: 84,\n                    paintImageXObject: 85,\n                    paintInlineImageXObject: 86,\n                    paintInlineImageXObjectGroup: 87,\n                    paintImageXObjectRepeat: 88,\n                    paintImageMaskXObjectRepeat: 89,\n                    paintSolidColorImageMask: 90,\n                    constructPath: 91\n                };\n                exports1.OPS = OPS;\n                const PasswordResponses = {\n                    NEED_PASSWORD: 1,\n                    INCORRECT_PASSWORD: 2\n                };\n                exports1.PasswordResponses = PasswordResponses;\n                let verbosity = VerbosityLevel.WARNINGS;\n                function setVerbosityLevel(level) {\n                    if (Number.isInteger(level)) {\n                        verbosity = level;\n                    }\n                }\n                function getVerbosityLevel() {\n                    return verbosity;\n                }\n                function info(msg) {\n                    if (verbosity >= VerbosityLevel.INFOS) {\n                        console.log(`Info: ${msg}`);\n                    }\n                }\n                function warn(msg) {\n                    if (verbosity >= VerbosityLevel.WARNINGS) {\n                        console.log(`Warning: ${msg}`);\n                    }\n                }\n                function unreachable(msg) {\n                    throw new Error(msg);\n                }\n                function assert(cond, msg) {\n                    if (!cond) {\n                        unreachable(msg);\n                    }\n                }\n                function _isValidProtocol(url) {\n                    switch(url?.protocol){\n                        case \"http:\":\n                        case \"https:\":\n                        case \"ftp:\":\n                        case \"mailto:\":\n                        case \"tel:\":\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n                    if (!url) {\n                        return null;\n                    }\n                    try {\n                        if (options && typeof url === \"string\") {\n                            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                                const dots = url.match(/\\./g);\n                                if (dots?.length >= 2) {\n                                    url = `http://${url}`;\n                                }\n                            }\n                            if (options.tryConvertEncoding) {\n                                try {\n                                    url = stringToUTF8String(url);\n                                } catch  {}\n                            }\n                        }\n                        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                        if (_isValidProtocol(absoluteUrl)) {\n                            return absoluteUrl;\n                        }\n                    } catch  {}\n                    return null;\n                }\n                function shadow(obj, prop, value, nonSerializable = false) {\n                    Object.defineProperty(obj, prop, {\n                        value,\n                        enumerable: !nonSerializable,\n                        configurable: true,\n                        writable: false\n                    });\n                    return value;\n                }\n                const BaseException = function BaseExceptionClosure() {\n                    function BaseException(message, name) {\n                        if (this.constructor === BaseException) {\n                            unreachable(\"Cannot initialize BaseException.\");\n                        }\n                        this.message = message;\n                        this.name = name;\n                    }\n                    BaseException.prototype = new Error();\n                    BaseException.constructor = BaseException;\n                    return BaseException;\n                }();\n                exports1.BaseException = BaseException;\n                class PasswordException extends BaseException {\n                    constructor(msg, code){\n                        super(msg, \"PasswordException\");\n                        this.code = code;\n                    }\n                }\n                exports1.PasswordException = PasswordException;\n                class UnknownErrorException extends BaseException {\n                    constructor(msg, details){\n                        super(msg, \"UnknownErrorException\");\n                        this.details = details;\n                    }\n                }\n                exports1.UnknownErrorException = UnknownErrorException;\n                class InvalidPDFException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"InvalidPDFException\");\n                    }\n                }\n                exports1.InvalidPDFException = InvalidPDFException;\n                class MissingPDFException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"MissingPDFException\");\n                    }\n                }\n                exports1.MissingPDFException = MissingPDFException;\n                class UnexpectedResponseException extends BaseException {\n                    constructor(msg, status){\n                        super(msg, \"UnexpectedResponseException\");\n                        this.status = status;\n                    }\n                }\n                exports1.UnexpectedResponseException = UnexpectedResponseException;\n                class FormatError extends BaseException {\n                    constructor(msg){\n                        super(msg, \"FormatError\");\n                    }\n                }\n                exports1.FormatError = FormatError;\n                class AbortException extends BaseException {\n                    constructor(msg){\n                        super(msg, \"AbortException\");\n                    }\n                }\n                exports1.AbortException = AbortException;\n                function bytesToString(bytes) {\n                    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n                        unreachable(\"Invalid argument for bytesToString\");\n                    }\n                    const length = bytes.length;\n                    const MAX_ARGUMENT_COUNT = 8192;\n                    if (length < MAX_ARGUMENT_COUNT) {\n                        return String.fromCharCode.apply(null, bytes);\n                    }\n                    const strBuf = [];\n                    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n                        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n                        const chunk = bytes.subarray(i, chunkEnd);\n                        strBuf.push(String.fromCharCode.apply(null, chunk));\n                    }\n                    return strBuf.join(\"\");\n                }\n                function stringToBytes(str) {\n                    if (typeof str !== \"string\") {\n                        unreachable(\"Invalid argument for stringToBytes\");\n                    }\n                    const length = str.length;\n                    const bytes = new Uint8Array(length);\n                    for(let i = 0; i < length; ++i){\n                        bytes[i] = str.charCodeAt(i) & 0xff;\n                    }\n                    return bytes;\n                }\n                function string32(value) {\n                    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n                }\n                function objectSize(obj) {\n                    return Object.keys(obj).length;\n                }\n                function objectFromMap(map) {\n                    const obj = Object.create(null);\n                    for (const [key, value] of map){\n                        obj[key] = value;\n                    }\n                    return obj;\n                }\n                function isLittleEndian() {\n                    const buffer8 = new Uint8Array(4);\n                    buffer8[0] = 1;\n                    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n                    return view32[0] === 1;\n                }\n                function isEvalSupported() {\n                    try {\n                        new Function(\"\");\n                        return true;\n                    } catch  {\n                        return false;\n                    }\n                }\n                class FeatureTest {\n                    static get isLittleEndian() {\n                        return shadow(this, \"isLittleEndian\", isLittleEndian());\n                    }\n                    static get isEvalSupported() {\n                        return shadow(this, \"isEvalSupported\", isEvalSupported());\n                    }\n                    static get isOffscreenCanvasSupported() {\n                        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n                    }\n                    static get platform() {\n                        if (typeof navigator === \"undefined\") {\n                            return shadow(this, \"platform\", {\n                                isWin: false,\n                                isMac: false\n                            });\n                        }\n                        return shadow(this, \"platform\", {\n                            isWin: navigator.platform.includes(\"Win\"),\n                            isMac: navigator.platform.includes(\"Mac\")\n                        });\n                    }\n                    static get isCSSRoundSupported() {\n                        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n                    }\n                }\n                exports1.FeatureTest = FeatureTest;\n                const hexNumbers = [\n                    ...Array(256).keys()\n                ].map((n)=>n.toString(16).padStart(2, \"0\"));\n                class Util {\n                    static makeHexColor(r, g, b) {\n                        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n                    }\n                    static scaleMinMax(transform, minMax) {\n                        let temp;\n                        if (transform[0]) {\n                            if (transform[0] < 0) {\n                                temp = minMax[0];\n                                minMax[0] = minMax[1];\n                                minMax[1] = temp;\n                            }\n                            minMax[0] *= transform[0];\n                            minMax[1] *= transform[0];\n                            if (transform[3] < 0) {\n                                temp = minMax[2];\n                                minMax[2] = minMax[3];\n                                minMax[3] = temp;\n                            }\n                            minMax[2] *= transform[3];\n                            minMax[3] *= transform[3];\n                        } else {\n                            temp = minMax[0];\n                            minMax[0] = minMax[2];\n                            minMax[2] = temp;\n                            temp = minMax[1];\n                            minMax[1] = minMax[3];\n                            minMax[3] = temp;\n                            if (transform[1] < 0) {\n                                temp = minMax[2];\n                                minMax[2] = minMax[3];\n                                minMax[3] = temp;\n                            }\n                            minMax[2] *= transform[1];\n                            minMax[3] *= transform[1];\n                            if (transform[2] < 0) {\n                                temp = minMax[0];\n                                minMax[0] = minMax[1];\n                                minMax[1] = temp;\n                            }\n                            minMax[0] *= transform[2];\n                            minMax[1] *= transform[2];\n                        }\n                        minMax[0] += transform[4];\n                        minMax[1] += transform[4];\n                        minMax[2] += transform[5];\n                        minMax[3] += transform[5];\n                    }\n                    static transform(m1, m2) {\n                        return [\n                            m1[0] * m2[0] + m1[2] * m2[1],\n                            m1[1] * m2[0] + m1[3] * m2[1],\n                            m1[0] * m2[2] + m1[2] * m2[3],\n                            m1[1] * m2[2] + m1[3] * m2[3],\n                            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n                            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n                        ];\n                    }\n                    static applyTransform(p, m) {\n                        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n                        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n                        return [\n                            xt,\n                            yt\n                        ];\n                    }\n                    static applyInverseTransform(p, m) {\n                        const d = m[0] * m[3] - m[1] * m[2];\n                        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n                        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n                        return [\n                            xt,\n                            yt\n                        ];\n                    }\n                    static getAxialAlignedBoundingBox(r, m) {\n                        const p1 = this.applyTransform(r, m);\n                        const p2 = this.applyTransform(r.slice(2, 4), m);\n                        const p3 = this.applyTransform([\n                            r[0],\n                            r[3]\n                        ], m);\n                        const p4 = this.applyTransform([\n                            r[2],\n                            r[1]\n                        ], m);\n                        return [\n                            Math.min(p1[0], p2[0], p3[0], p4[0]),\n                            Math.min(p1[1], p2[1], p3[1], p4[1]),\n                            Math.max(p1[0], p2[0], p3[0], p4[0]),\n                            Math.max(p1[1], p2[1], p3[1], p4[1])\n                        ];\n                    }\n                    static inverseTransform(m) {\n                        const d = m[0] * m[3] - m[1] * m[2];\n                        return [\n                            m[3] / d,\n                            -m[1] / d,\n                            -m[2] / d,\n                            m[0] / d,\n                            (m[2] * m[5] - m[4] * m[3]) / d,\n                            (m[4] * m[1] - m[5] * m[0]) / d\n                        ];\n                    }\n                    static singularValueDecompose2dScale(m) {\n                        const transpose = [\n                            m[0],\n                            m[2],\n                            m[1],\n                            m[3]\n                        ];\n                        const a = m[0] * transpose[0] + m[1] * transpose[2];\n                        const b = m[0] * transpose[1] + m[1] * transpose[3];\n                        const c = m[2] * transpose[0] + m[3] * transpose[2];\n                        const d = m[2] * transpose[1] + m[3] * transpose[3];\n                        const first = (a + d) / 2;\n                        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n                        const sx = first + second || 1;\n                        const sy = first - second || 1;\n                        return [\n                            Math.sqrt(sx),\n                            Math.sqrt(sy)\n                        ];\n                    }\n                    static normalizeRect(rect) {\n                        const r = rect.slice(0);\n                        if (rect[0] > rect[2]) {\n                            r[0] = rect[2];\n                            r[2] = rect[0];\n                        }\n                        if (rect[1] > rect[3]) {\n                            r[1] = rect[3];\n                            r[3] = rect[1];\n                        }\n                        return r;\n                    }\n                    static intersect(rect1, rect2) {\n                        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n                        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n                        if (xLow > xHigh) {\n                            return null;\n                        }\n                        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n                        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n                        if (yLow > yHigh) {\n                            return null;\n                        }\n                        return [\n                            xLow,\n                            yLow,\n                            xHigh,\n                            yHigh\n                        ];\n                    }\n                    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n                        const tvalues = [], bounds = [\n                            [],\n                            []\n                        ];\n                        let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n                        for(let i = 0; i < 2; ++i){\n                            if (i === 0) {\n                                b = 6 * x0 - 12 * x1 + 6 * x2;\n                                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                                c = 3 * x1 - 3 * x0;\n                            } else {\n                                b = 6 * y0 - 12 * y1 + 6 * y2;\n                                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                                c = 3 * y1 - 3 * y0;\n                            }\n                            if (Math.abs(a) < 1e-12) {\n                                if (Math.abs(b) < 1e-12) {\n                                    continue;\n                                }\n                                t = -c / b;\n                                if (0 < t && t < 1) {\n                                    tvalues.push(t);\n                                }\n                                continue;\n                            }\n                            b2ac = b * b - 4 * c * a;\n                            sqrtb2ac = Math.sqrt(b2ac);\n                            if (b2ac < 0) {\n                                continue;\n                            }\n                            t1 = (-b + sqrtb2ac) / (2 * a);\n                            if (0 < t1 && t1 < 1) {\n                                tvalues.push(t1);\n                            }\n                            t2 = (-b - sqrtb2ac) / (2 * a);\n                            if (0 < t2 && t2 < 1) {\n                                tvalues.push(t2);\n                            }\n                        }\n                        let j = tvalues.length, mt;\n                        const jlen = j;\n                        while(j--){\n                            t = tvalues[j];\n                            mt = 1 - t;\n                            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n                            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n                        }\n                        bounds[0][jlen] = x0;\n                        bounds[1][jlen] = y0;\n                        bounds[0][jlen + 1] = x3;\n                        bounds[1][jlen + 1] = y3;\n                        bounds[0].length = bounds[1].length = jlen + 2;\n                        return [\n                            Math.min(...bounds[0]),\n                            Math.min(...bounds[1]),\n                            Math.max(...bounds[0]),\n                            Math.max(...bounds[1])\n                        ];\n                    }\n                }\n                exports1.Util = Util;\n                const PDFStringTranslateTable = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2d8,\n                    0x2c7,\n                    0x2c6,\n                    0x2d9,\n                    0x2dd,\n                    0x2db,\n                    0x2da,\n                    0x2dc,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2022,\n                    0x2020,\n                    0x2021,\n                    0x2026,\n                    0x2014,\n                    0x2013,\n                    0x192,\n                    0x2044,\n                    0x2039,\n                    0x203a,\n                    0x2212,\n                    0x2030,\n                    0x201e,\n                    0x201c,\n                    0x201d,\n                    0x2018,\n                    0x2019,\n                    0x201a,\n                    0x2122,\n                    0xfb01,\n                    0xfb02,\n                    0x141,\n                    0x152,\n                    0x160,\n                    0x178,\n                    0x17d,\n                    0x131,\n                    0x142,\n                    0x153,\n                    0x161,\n                    0x17e,\n                    0,\n                    0x20ac\n                ];\n                function stringToPDFString(str) {\n                    if (str[0] >= \"\\xef\") {\n                        let encoding;\n                        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n                            encoding = \"utf-16be\";\n                        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n                            encoding = \"utf-16le\";\n                        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n                            encoding = \"utf-8\";\n                        }\n                        if (encoding) {\n                            try {\n                                const decoder = new TextDecoder(encoding, {\n                                    fatal: true\n                                });\n                                const buffer = stringToBytes(str);\n                                return decoder.decode(buffer);\n                            } catch (ex) {\n                                warn(`stringToPDFString: \"${ex}\".`);\n                            }\n                        }\n                    }\n                    const strBuf = [];\n                    for(let i = 0, ii = str.length; i < ii; i++){\n                        const code = PDFStringTranslateTable[str.charCodeAt(i)];\n                        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n                    }\n                    return strBuf.join(\"\");\n                }\n                function stringToUTF8String(str) {\n                    return decodeURIComponent(escape(str));\n                }\n                function utf8StringToString(str) {\n                    return unescape(encodeURIComponent(str));\n                }\n                function isArrayBuffer(v) {\n                    return typeof v === \"object\" && v?.byteLength !== undefined;\n                }\n                function isArrayEqual(arr1, arr2) {\n                    if (arr1.length !== arr2.length) {\n                        return false;\n                    }\n                    for(let i = 0, ii = arr1.length; i < ii; i++){\n                        if (arr1[i] !== arr2[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function getModificationDate(date = new Date()) {\n                    const buffer = [\n                        date.getUTCFullYear().toString(),\n                        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n                        date.getUTCDate().toString().padStart(2, \"0\"),\n                        date.getUTCHours().toString().padStart(2, \"0\"),\n                        date.getUTCMinutes().toString().padStart(2, \"0\"),\n                        date.getUTCSeconds().toString().padStart(2, \"0\")\n                    ];\n                    return buffer.join(\"\");\n                }\n                class PromiseCapability {\n                    #settled;\n                    constructor(){\n                        this.#settled = false;\n                        this.promise = new Promise((resolve, reject)=>{\n                            this.resolve = (data)=>{\n                                this.#settled = true;\n                                resolve(data);\n                            };\n                            this.reject = (reason)=>{\n                                this.#settled = true;\n                                reject(reason);\n                            };\n                        });\n                    }\n                    get settled() {\n                        return this.#settled;\n                    }\n                }\n                exports1.PromiseCapability = PromiseCapability;\n                let NormalizeRegex = null;\n                let NormalizationMap = null;\n                function normalizeUnicode(str) {\n                    if (!NormalizeRegex) {\n                        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n                        NormalizationMap = new Map([\n                            [\n                                \"ﬅ\",\n                                \"ſt\"\n                            ]\n                        ]);\n                    }\n                    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>{\n                        return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n                    });\n                }\n                function getUuid() {\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n                        return crypto.randomUUID();\n                    }\n                    const buf = new Uint8Array(32);\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n                        crypto.getRandomValues(buf);\n                    } else {\n                        for(let i = 0; i < 32; i++){\n                            buf[i] = Math.floor(Math.random() * 255);\n                        }\n                    }\n                    return bytesToString(buf);\n                }\n                const AnnotationPrefix = \"pdfjs_internal_id_\";\n                exports1.AnnotationPrefix = AnnotationPrefix;\n            /***/ },\n            /* 2 */ /***/ (__unused_webpack_module, exports, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\n                Object.defineProperty(exports, \"SVGGraphics\", {\n                    enumerable: true,\n                    get: function() {\n                        return _displaySvg.SVGGraphics;\n                    }\n                });\n                exports.build = void 0;\n                exports.getDocument = getDocument;\n                exports.version = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _annotation_storage = __w_pdfjs_require__(3);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _font_loader = __w_pdfjs_require__(9);\n                var _displayNode_utils = __w_pdfjs_require__(10);\n                var _canvas = __w_pdfjs_require__(11);\n                var _worker_options = __w_pdfjs_require__(14);\n                var _message_handler = __w_pdfjs_require__(15);\n                var _metadata = __w_pdfjs_require__(16);\n                var _optional_content_config = __w_pdfjs_require__(17);\n                var _transport_stream = __w_pdfjs_require__(18);\n                var _displayFetch_stream = __w_pdfjs_require__(19);\n                var _displayNetwork = __w_pdfjs_require__(22);\n                var _displayNode_stream = __w_pdfjs_require__(23);\n                var _displaySvg = __w_pdfjs_require__(24);\n                var _xfa_text = __w_pdfjs_require__(25);\n                const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n                const RENDERING_CANCELLED_TIMEOUT = 100;\n                const DELAYED_CLEANUP_TIMEOUT = 5000;\n                const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\n                exports.DefaultCanvasFactory = DefaultCanvasFactory;\n                const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\n                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n                const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;\n                exports.DefaultFilterFactory = DefaultFilterFactory;\n                const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\n                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n                function getDocument(src) {\n                    if (typeof src === \"string\" || src instanceof URL) {\n                        src = {\n                            url: src\n                        };\n                    } else if ((0, _util.isArrayBuffer)(src)) {\n                        src = {\n                            data: src\n                        };\n                    }\n                    if (typeof src !== \"object\") {\n                        throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n                    }\n                    if (!src.url && !src.data && !src.range) {\n                        throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n                    }\n                    const task = new PDFDocumentLoadingTask();\n                    const { docId } = task;\n                    const url = src.url ? getUrlProp(src.url) : null;\n                    const data = src.data ? getDataProp(src.data) : null;\n                    const httpHeaders = src.httpHeaders || null;\n                    const withCredentials = src.withCredentials === true;\n                    const password = src.password ?? null;\n                    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n                    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n                    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n                    const verbosity = src.verbosity;\n                    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n                    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n                    const cMapPacked = src.cMapPacked !== false;\n                    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n                    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n                    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n                    const ignoreErrors = src.stopAtErrors !== true;\n                    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n                    const isEvalSupported = src.isEvalSupported !== false;\n                    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;\n                    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n                    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _util.isNodeJS;\n                    const fontExtraProperties = src.fontExtraProperties === true;\n                    const enableXfa = src.enableXfa === true;\n                    const ownerDocument = src.ownerDocument || globalThis.document;\n                    const disableRange = src.disableRange === true;\n                    const disableStream = src.disableStream === true;\n                    const disableAutoFetch = src.disableAutoFetch === true;\n                    const pdfBug = src.pdfBug === true;\n                    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n                    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;\n                    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n                    const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n                        ownerDocument\n                    });\n                    const filterFactory = src.filterFactory || new DefaultFilterFactory({\n                        docId,\n                        ownerDocument\n                    });\n                    const styleElement = null;\n                    (0, _util.setVerbosityLevel)(verbosity);\n                    const transportFactory = {\n                        canvasFactory,\n                        filterFactory\n                    };\n                    if (!useWorkerFetch) {\n                        transportFactory.cMapReaderFactory = new CMapReaderFactory({\n                            baseUrl: cMapUrl,\n                            isCompressed: cMapPacked\n                        });\n                        transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n                            baseUrl: standardFontDataUrl\n                        });\n                    }\n                    if (!worker) {\n                        const workerParams = {\n                            verbosity,\n                            port: _worker_options.GlobalWorkerOptions.workerPort\n                        };\n                        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n                        task._worker = worker;\n                    }\n                    const fetchDocParams = {\n                        docId,\n                        apiVersion: \"3.11.174\",\n                        data,\n                        password,\n                        disableAutoFetch,\n                        rangeChunkSize,\n                        length,\n                        docBaseUrl,\n                        enableXfa,\n                        evaluatorOptions: {\n                            maxImageSize,\n                            disableFontFace,\n                            ignoreErrors,\n                            isEvalSupported,\n                            isOffscreenCanvasSupported,\n                            canvasMaxAreaInBytes,\n                            fontExtraProperties,\n                            useSystemFonts,\n                            cMapUrl: useWorkerFetch ? cMapUrl : null,\n                            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n                        }\n                    };\n                    const transportParams = {\n                        ignoreErrors,\n                        isEvalSupported,\n                        disableFontFace,\n                        fontExtraProperties,\n                        enableXfa,\n                        ownerDocument,\n                        disableAutoFetch,\n                        pdfBug,\n                        styleElement\n                    };\n                    worker.promise.then(function() {\n                        if (task.destroyed) {\n                            throw new Error(\"Loading aborted\");\n                        }\n                        const workerIdPromise = _fetchDocument(worker, fetchDocParams);\n                        const networkStreamPromise = new Promise(function(resolve) {\n                            let networkStream;\n                            if (rangeTransport) {\n                                networkStream = new _transport_stream.PDFDataTransportStream({\n                                    length,\n                                    initialData: rangeTransport.initialData,\n                                    progressiveDone: rangeTransport.progressiveDone,\n                                    contentDispositionFilename: rangeTransport.contentDispositionFilename,\n                                    disableRange,\n                                    disableStream\n                                }, rangeTransport);\n                            } else if (!data) {\n                                const createPDFNetworkStream = (params)=>{\n                                    if (_util.isNodeJS) {\n                                        return new _displayNode_stream.PDFNodeStream(params);\n                                    }\n                                    return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);\n                                };\n                                networkStream = createPDFNetworkStream({\n                                    url,\n                                    length,\n                                    httpHeaders,\n                                    withCredentials,\n                                    rangeChunkSize,\n                                    disableRange,\n                                    disableStream\n                                });\n                            }\n                            resolve(networkStream);\n                        });\n                        return Promise.all([\n                            workerIdPromise,\n                            networkStreamPromise\n                        ]).then(function([workerId, networkStream]) {\n                            if (task.destroyed) {\n                                throw new Error(\"Loading aborted\");\n                            }\n                            const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n                            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n                            task._transport = transport;\n                            messageHandler.send(\"Ready\", null);\n                        });\n                    }).catch(task._capability.reject);\n                    return task;\n                }\n                async function _fetchDocument(worker, source) {\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [\n                        source.data.buffer\n                    ] : null);\n                    if (worker.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    return workerId;\n                }\n                function getUrlProp(val) {\n                    if (val instanceof URL) {\n                        return val.href;\n                    }\n                    try {\n                        return new URL(val, window.location).href;\n                    } catch  {\n                        if (_util.isNodeJS && typeof val === \"string\") {\n                            return val;\n                        }\n                    }\n                    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n                }\n                function getDataProp(val) {\n                    if (_util.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n                        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n                    }\n                    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n                        return val;\n                    }\n                    if (typeof val === \"string\") {\n                        return (0, _util.stringToBytes)(val);\n                    }\n                    if (typeof val === \"object\" && !isNaN(val?.length) || (0, _util.isArrayBuffer)(val)) {\n                        return new Uint8Array(val);\n                    }\n                    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n                }\n                class PDFDocumentLoadingTask {\n                    static #docId = 0;\n                    constructor(){\n                        this._capability = new _util.PromiseCapability();\n                        this._transport = null;\n                        this._worker = null;\n                        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n                        this.destroyed = false;\n                        this.onPassword = null;\n                        this.onProgress = null;\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    async destroy() {\n                        this.destroyed = true;\n                        try {\n                            if (this._worker?.port) {\n                                this._worker._pendingDestroy = true;\n                            }\n                            await this._transport?.destroy();\n                        } catch (ex) {\n                            if (this._worker?.port) {\n                                delete this._worker._pendingDestroy;\n                            }\n                            throw ex;\n                        }\n                        this._transport = null;\n                        if (this._worker) {\n                            this._worker.destroy();\n                            this._worker = null;\n                        }\n                    }\n                }\n                exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n                class PDFDataRangeTransport {\n                    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n                        this.length = length;\n                        this.initialData = initialData;\n                        this.progressiveDone = progressiveDone;\n                        this.contentDispositionFilename = contentDispositionFilename;\n                        this._rangeListeners = [];\n                        this._progressListeners = [];\n                        this._progressiveReadListeners = [];\n                        this._progressiveDoneListeners = [];\n                        this._readyCapability = new _util.PromiseCapability();\n                    }\n                    addRangeListener(listener) {\n                        this._rangeListeners.push(listener);\n                    }\n                    addProgressListener(listener) {\n                        this._progressListeners.push(listener);\n                    }\n                    addProgressiveReadListener(listener) {\n                        this._progressiveReadListeners.push(listener);\n                    }\n                    addProgressiveDoneListener(listener) {\n                        this._progressiveDoneListeners.push(listener);\n                    }\n                    onDataRange(begin, chunk) {\n                        for (const listener of this._rangeListeners){\n                            listener(begin, chunk);\n                        }\n                    }\n                    onDataProgress(loaded, total) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressListeners){\n                                listener(loaded, total);\n                            }\n                        });\n                    }\n                    onDataProgressiveRead(chunk) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveReadListeners){\n                                listener(chunk);\n                            }\n                        });\n                    }\n                    onDataProgressiveDone() {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener of this._progressiveDoneListeners){\n                                listener();\n                            }\n                        });\n                    }\n                    transportReady() {\n                        this._readyCapability.resolve();\n                    }\n                    requestDataRange(begin, end) {\n                        (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n                    }\n                    abort() {}\n                }\n                exports.PDFDataRangeTransport = PDFDataRangeTransport;\n                class PDFDocumentProxy {\n                    constructor(pdfInfo, transport){\n                        this._pdfInfo = pdfInfo;\n                        this._transport = transport;\n                        Object.defineProperty(this, \"getJavaScript\", {\n                            value: ()=>{\n                                (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getJavaScript`, \" + \"please use `PDFDocumentProxy.getJSActions` instead.\");\n                                return this.getJSActions().then((js)=>{\n                                    if (!js) {\n                                        return js;\n                                    }\n                                    const jsArr = [];\n                                    for(const name in js){\n                                        jsArr.push(...js[name]);\n                                    }\n                                    return jsArr;\n                                });\n                            }\n                        });\n                    }\n                    get annotationStorage() {\n                        return this._transport.annotationStorage;\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get numPages() {\n                        return this._pdfInfo.numPages;\n                    }\n                    get fingerprints() {\n                        return this._pdfInfo.fingerprints;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    get allXfaHtml() {\n                        return this._transport._htmlForXfa;\n                    }\n                    getPage(pageNumber) {\n                        return this._transport.getPage(pageNumber);\n                    }\n                    getPageIndex(ref) {\n                        return this._transport.getPageIndex(ref);\n                    }\n                    getDestinations() {\n                        return this._transport.getDestinations();\n                    }\n                    getDestination(id) {\n                        return this._transport.getDestination(id);\n                    }\n                    getPageLabels() {\n                        return this._transport.getPageLabels();\n                    }\n                    getPageLayout() {\n                        return this._transport.getPageLayout();\n                    }\n                    getPageMode() {\n                        return this._transport.getPageMode();\n                    }\n                    getViewerPreferences() {\n                        return this._transport.getViewerPreferences();\n                    }\n                    getOpenAction() {\n                        return this._transport.getOpenAction();\n                    }\n                    getAttachments() {\n                        return this._transport.getAttachments();\n                    }\n                    getJSActions() {\n                        return this._transport.getDocJSActions();\n                    }\n                    getOutline() {\n                        return this._transport.getOutline();\n                    }\n                    getOptionalContentConfig() {\n                        return this._transport.getOptionalContentConfig();\n                    }\n                    getPermissions() {\n                        return this._transport.getPermissions();\n                    }\n                    getMetadata() {\n                        return this._transport.getMetadata();\n                    }\n                    getMarkInfo() {\n                        return this._transport.getMarkInfo();\n                    }\n                    getData() {\n                        return this._transport.getData();\n                    }\n                    saveDocument() {\n                        return this._transport.saveDocument();\n                    }\n                    getDownloadInfo() {\n                        return this._transport.downloadInfoCapability.promise;\n                    }\n                    cleanup(keepLoadedFonts = false) {\n                        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n                    }\n                    destroy() {\n                        return this.loadingTask.destroy();\n                    }\n                    get loadingParams() {\n                        return this._transport.loadingParams;\n                    }\n                    get loadingTask() {\n                        return this._transport.loadingTask;\n                    }\n                    getFieldObjects() {\n                        return this._transport.getFieldObjects();\n                    }\n                    hasJSActions() {\n                        return this._transport.hasJSActions();\n                    }\n                    getCalculationOrderIds() {\n                        return this._transport.getCalculationOrderIds();\n                    }\n                }\n                exports.PDFDocumentProxy = PDFDocumentProxy;\n                class PDFPageProxy {\n                    #delayedCleanupTimeout;\n                    #pendingCleanup;\n                    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n                        this.#delayedCleanupTimeout = null;\n                        this.#pendingCleanup = false;\n                        this._pageIndex = pageIndex;\n                        this._pageInfo = pageInfo;\n                        this._transport = transport;\n                        this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n                        this._pdfBug = pdfBug;\n                        this.commonObjs = transport.commonObjs;\n                        this.objs = new PDFObjects();\n                        this._maybeCleanupAfterRender = false;\n                        this._intentStates = new Map();\n                        this.destroyed = false;\n                    }\n                    get pageNumber() {\n                        return this._pageIndex + 1;\n                    }\n                    get rotate() {\n                        return this._pageInfo.rotate;\n                    }\n                    get ref() {\n                        return this._pageInfo.ref;\n                    }\n                    get userUnit() {\n                        return this._pageInfo.userUnit;\n                    }\n                    get view() {\n                        return this._pageInfo.view;\n                    }\n                    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n                        return new _display_utils.PageViewport({\n                            viewBox: this.view,\n                            scale,\n                            rotation,\n                            offsetX,\n                            offsetY,\n                            dontFlip\n                        });\n                    }\n                    getAnnotations({ intent = \"display\" } = {}) {\n                        const intentArgs = this._transport.getRenderingIntent(intent);\n                        return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n                    }\n                    getJSActions() {\n                        return this._transport.getPageJSActions(this._pageIndex);\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    async getXfa() {\n                        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n                    }\n                    render({ canvasContext, viewport, intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null }) {\n                        this._stats?.time(\"Overall\");\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        if (!optionalContentConfigPromise) {\n                            optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n                        }\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n                        if (!intentState.displayReadyCapability) {\n                            intentState.displayReadyCapability = new _util.PromiseCapability();\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        const complete = (error)=>{\n                            intentState.renderTasks.delete(internalRenderTask);\n                            if (this._maybeCleanupAfterRender || intentPrint) {\n                                this.#pendingCleanup = true;\n                            }\n                            this.#tryCleanup(!intentPrint);\n                            if (error) {\n                                internalRenderTask.capability.reject(error);\n                                this._abortOperatorList({\n                                    intentState,\n                                    reason: error instanceof Error ? error : new Error(error)\n                                });\n                            } else {\n                                internalRenderTask.capability.resolve();\n                            }\n                            this._stats?.timeEnd(\"Rendering\");\n                            this._stats?.timeEnd(\"Overall\");\n                        };\n                        const internalRenderTask = new InternalRenderTask({\n                            callback: complete,\n                            params: {\n                                canvasContext,\n                                viewport,\n                                transform,\n                                background\n                            },\n                            objs: this.objs,\n                            commonObjs: this.commonObjs,\n                            annotationCanvasMap,\n                            operatorList: intentState.operatorList,\n                            pageIndex: this._pageIndex,\n                            canvasFactory: this._transport.canvasFactory,\n                            filterFactory: this._transport.filterFactory,\n                            useRequestAnimationFrame: !intentPrint,\n                            pdfBug: this._pdfBug,\n                            pageColors\n                        });\n                        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n                        const renderTask = internalRenderTask.task;\n                        Promise.all([\n                            intentState.displayReadyCapability.promise,\n                            optionalContentConfigPromise\n                        ]).then(([transparency, optionalContentConfig])=>{\n                            if (this.destroyed) {\n                                complete();\n                                return;\n                            }\n                            this._stats?.time(\"Rendering\");\n                            internalRenderTask.initializeGraphics({\n                                transparency,\n                                optionalContentConfig\n                            });\n                            internalRenderTask.operatorListChanged();\n                        }).catch(complete);\n                        return renderTask;\n                    }\n                    getOperatorList({ intent = \"display\", annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null } = {}) {\n                        function operatorListChanged() {\n                            if (intentState.operatorList.lastChunk) {\n                                intentState.opListReadCapability.resolve(intentState.operatorList);\n                                intentState.renderTasks.delete(opListTask);\n                            }\n                        }\n                        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n                        let intentState = this._intentStates.get(intentArgs.cacheKey);\n                        if (!intentState) {\n                            intentState = Object.create(null);\n                            this._intentStates.set(intentArgs.cacheKey, intentState);\n                        }\n                        let opListTask;\n                        if (!intentState.opListReadCapability) {\n                            opListTask = Object.create(null);\n                            opListTask.operatorListChanged = operatorListChanged;\n                            intentState.opListReadCapability = new _util.PromiseCapability();\n                            (intentState.renderTasks ||= new Set()).add(opListTask);\n                            intentState.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs);\n                        }\n                        return intentState.opListReadCapability.promise;\n                    }\n                    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n                        const TEXT_CONTENT_CHUNK_SIZE = 100;\n                        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n                            pageIndex: this._pageIndex,\n                            includeMarkedContent: includeMarkedContent === true,\n                            disableNormalization: disableNormalization === true\n                        }, {\n                            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n                            size (textContent) {\n                                return textContent.items.length;\n                            }\n                        });\n                    }\n                    getTextContent(params = {}) {\n                        if (this._transport._htmlForXfa) {\n                            return this.getXfa().then((xfa)=>{\n                                return _xfa_text.XfaText.textContent(xfa);\n                            });\n                        }\n                        const readableStream = this.streamTextContent(params);\n                        return new Promise(function(resolve, reject) {\n                            function pump() {\n                                reader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        resolve(textContent);\n                                        return;\n                                    }\n                                    Object.assign(textContent.styles, value.styles);\n                                    textContent.items.push(...value.items);\n                                    pump();\n                                }, reject);\n                            }\n                            const reader = readableStream.getReader();\n                            const textContent = {\n                                items: [],\n                                styles: Object.create(null)\n                            };\n                            pump();\n                        });\n                    }\n                    getStructTree() {\n                        return this._transport.getStructTree(this._pageIndex);\n                    }\n                    _destroy() {\n                        this.destroyed = true;\n                        const waitOn = [];\n                        for (const intentState of this._intentStates.values()){\n                            this._abortOperatorList({\n                                intentState,\n                                reason: new Error(\"Page was destroyed.\"),\n                                force: true\n                            });\n                            if (intentState.opListReadCapability) {\n                                continue;\n                            }\n                            for (const internalRenderTask of intentState.renderTasks){\n                                waitOn.push(internalRenderTask.completed);\n                                internalRenderTask.cancel();\n                            }\n                        }\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        return Promise.all(waitOn);\n                    }\n                    cleanup(resetStats = false) {\n                        this.#pendingCleanup = true;\n                        const success = this.#tryCleanup(false);\n                        if (resetStats && success) {\n                            this._stats &&= new _display_utils.StatTimer();\n                        }\n                        return success;\n                    }\n                    #tryCleanup(delayed = false) {\n                        this.#abortDelayedCleanup();\n                        if (!this.#pendingCleanup || this.destroyed) {\n                            return false;\n                        }\n                        if (delayed) {\n                            this.#delayedCleanupTimeout = setTimeout(()=>{\n                                this.#delayedCleanupTimeout = null;\n                                this.#tryCleanup(false);\n                            }, DELAYED_CLEANUP_TIMEOUT);\n                            return false;\n                        }\n                        for (const { renderTasks, operatorList } of this._intentStates.values()){\n                            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                                return false;\n                            }\n                        }\n                        this._intentStates.clear();\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        return true;\n                    }\n                    #abortDelayedCleanup() {\n                        if (this.#delayedCleanupTimeout) {\n                            clearTimeout(this.#delayedCleanupTimeout);\n                            this.#delayedCleanupTimeout = null;\n                        }\n                    }\n                    _startRenderPage(transparency, cacheKey) {\n                        const intentState = this._intentStates.get(cacheKey);\n                        if (!intentState) {\n                            return;\n                        }\n                        this._stats?.timeEnd(\"Page Request\");\n                        intentState.displayReadyCapability?.resolve(transparency);\n                    }\n                    _renderPageChunk(operatorListChunk, intentState) {\n                        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n                            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n                            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n                        }\n                        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n                        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n                        for (const internalRenderTask of intentState.renderTasks){\n                            internalRenderTask.operatorListChanged();\n                        }\n                        if (operatorListChunk.lastChunk) {\n                            this.#tryCleanup(true);\n                        }\n                    }\n                    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable }) {\n                        const { map, transfers } = annotationStorageSerializable;\n                        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n                            pageIndex: this._pageIndex,\n                            intent: renderingIntent,\n                            cacheKey,\n                            annotationStorage: map\n                        }, transfers);\n                        const reader = readableStream.getReader();\n                        const intentState = this._intentStates.get(cacheKey);\n                        intentState.streamReader = reader;\n                        const pump = ()=>{\n                            reader.read().then(({ value, done })=>{\n                                if (done) {\n                                    intentState.streamReader = null;\n                                    return;\n                                }\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                this._renderPageChunk(value, intentState);\n                                pump();\n                            }, (reason)=>{\n                                intentState.streamReader = null;\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                if (intentState.operatorList) {\n                                    intentState.operatorList.lastChunk = true;\n                                    for (const internalRenderTask of intentState.renderTasks){\n                                        internalRenderTask.operatorListChanged();\n                                    }\n                                    this.#tryCleanup(true);\n                                }\n                                if (intentState.displayReadyCapability) {\n                                    intentState.displayReadyCapability.reject(reason);\n                                } else if (intentState.opListReadCapability) {\n                                    intentState.opListReadCapability.reject(reason);\n                                } else {\n                                    throw reason;\n                                }\n                            });\n                        };\n                        pump();\n                    }\n                    _abortOperatorList({ intentState, reason, force = false }) {\n                        if (!intentState.streamReader) {\n                            return;\n                        }\n                        if (intentState.streamReaderCancelTimeout) {\n                            clearTimeout(intentState.streamReaderCancelTimeout);\n                            intentState.streamReaderCancelTimeout = null;\n                        }\n                        if (!force) {\n                            if (intentState.renderTasks.size > 0) {\n                                return;\n                            }\n                            if (reason instanceof _display_utils.RenderingCancelledException) {\n                                let delay = RENDERING_CANCELLED_TIMEOUT;\n                                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                                    delay += reason.extraDelay;\n                                }\n                                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                                    intentState.streamReaderCancelTimeout = null;\n                                    this._abortOperatorList({\n                                        intentState,\n                                        reason,\n                                        force: true\n                                    });\n                                }, delay);\n                                return;\n                            }\n                        }\n                        intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(()=>{});\n                        intentState.streamReader = null;\n                        if (this._transport.destroyed) {\n                            return;\n                        }\n                        for (const [curCacheKey, curIntentState] of this._intentStates){\n                            if (curIntentState === intentState) {\n                                this._intentStates.delete(curCacheKey);\n                                break;\n                            }\n                        }\n                        this.cleanup();\n                    }\n                    get stats() {\n                        return this._stats;\n                    }\n                }\n                exports.PDFPageProxy = PDFPageProxy;\n                class LoopbackPort {\n                    #listeners;\n                    #deferred;\n                    postMessage(obj, transfer) {\n                        const event = {\n                            data: structuredClone(obj, transfer ? {\n                                transfer\n                            } : null)\n                        };\n                        this.#deferred.then(()=>{\n                            for (const listener of this.#listeners){\n                                listener.call(this, event);\n                            }\n                        });\n                    }\n                    addEventListener(name, listener) {\n                        this.#listeners.add(listener);\n                    }\n                    removeEventListener(name, listener) {\n                        this.#listeners.delete(listener);\n                    }\n                    terminate() {\n                        this.#listeners.clear();\n                    }\n                    constructor(){\n                        this.#listeners = new Set();\n                        this.#deferred = Promise.resolve();\n                    }\n                }\n                exports.LoopbackPort = LoopbackPort;\n                const PDFWorkerUtil = {\n                    isWorkerDisabled: false,\n                    fallbackWorkerSrc: null,\n                    fakeWorkerId: 0\n                };\n                exports.PDFWorkerUtil = PDFWorkerUtil;\n                {\n                    if (_util.isNodeJS && \"function\" === \"function\") {\n                        PDFWorkerUtil.isWorkerDisabled = true;\n                        PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n                    } else if (typeof document === \"object\") {\n                        const pdfjsFilePath = document?.currentScript?.src;\n                        if (pdfjsFilePath) {\n                            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n                        }\n                    }\n                    PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {\n                        let base;\n                        try {\n                            base = new URL(baseUrl);\n                            if (!base.origin || base.origin === \"null\") {\n                                return false;\n                            }\n                        } catch  {\n                            return false;\n                        }\n                        const other = new URL(otherUrl, base);\n                        return base.origin === other.origin;\n                    };\n                    PDFWorkerUtil.createCDNWrapper = function(url) {\n                        const wrapper = `importScripts(\"${url}\");`;\n                        return URL.createObjectURL(new Blob([\n                            wrapper\n                        ]));\n                    };\n                }\n                class PDFWorker {\n                    static #workerPorts;\n                    constructor({ name = null, port = null, verbosity = (0, _util.getVerbosityLevel)() } = {}){\n                        this.name = name;\n                        this.destroyed = false;\n                        this.verbosity = verbosity;\n                        this._readyCapability = new _util.PromiseCapability();\n                        this._port = null;\n                        this._webWorker = null;\n                        this._messageHandler = null;\n                        if (port) {\n                            if (PDFWorker.#workerPorts?.has(port)) {\n                                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n                            }\n                            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n                            this._initializeFromPort(port);\n                            return;\n                        }\n                        this._initialize();\n                    }\n                    get promise() {\n                        return this._readyCapability.promise;\n                    }\n                    get port() {\n                        return this._port;\n                    }\n                    get messageHandler() {\n                        return this._messageHandler;\n                    }\n                    _initializeFromPort(port) {\n                        this._port = port;\n                        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n                        this._messageHandler.on(\"ready\", function() {});\n                        this._readyCapability.resolve();\n                        this._messageHandler.send(\"configure\", {\n                            verbosity: this.verbosity\n                        });\n                    }\n                    _initialize() {\n                        if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n                            let { workerSrc } = PDFWorker;\n                            try {\n                                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n                                    workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n                                }\n                                const worker = new Worker(workerSrc);\n                                const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n                                const terminateEarly = ()=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    messageHandler.destroy();\n                                    worker.terminate();\n                                    if (this.destroyed) {\n                                        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                    } else {\n                                        this._setupFakeWorker();\n                                    }\n                                };\n                                const onWorkerError = ()=>{\n                                    if (!this._webWorker) {\n                                        terminateEarly();\n                                    }\n                                };\n                                worker.addEventListener(\"error\", onWorkerError);\n                                messageHandler.on(\"test\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    if (data) {\n                                        this._messageHandler = messageHandler;\n                                        this._port = worker;\n                                        this._webWorker = worker;\n                                        this._readyCapability.resolve();\n                                        messageHandler.send(\"configure\", {\n                                            verbosity: this.verbosity\n                                        });\n                                    } else {\n                                        this._setupFakeWorker();\n                                        messageHandler.destroy();\n                                        worker.terminate();\n                                    }\n                                });\n                                messageHandler.on(\"ready\", (data)=>{\n                                    worker.removeEventListener(\"error\", onWorkerError);\n                                    if (this.destroyed) {\n                                        terminateEarly();\n                                        return;\n                                    }\n                                    try {\n                                        sendTest();\n                                    } catch  {\n                                        this._setupFakeWorker();\n                                    }\n                                });\n                                const sendTest = ()=>{\n                                    const testObj = new Uint8Array();\n                                    messageHandler.send(\"test\", testObj, [\n                                        testObj.buffer\n                                    ]);\n                                };\n                                sendTest();\n                                return;\n                            } catch  {\n                                (0, _util.info)(\"The worker has been disabled.\");\n                            }\n                        }\n                        this._setupFakeWorker();\n                    }\n                    _setupFakeWorker() {\n                        if (!PDFWorkerUtil.isWorkerDisabled) {\n                            (0, _util.warn)(\"Setting up fake worker.\");\n                            PDFWorkerUtil.isWorkerDisabled = true;\n                        }\n                        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n                            if (this.destroyed) {\n                                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                return;\n                            }\n                            const port = new LoopbackPort();\n                            this._port = port;\n                            const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n                            const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n                            WorkerMessageHandler.setup(workerHandler, port);\n                            const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n                            this._messageHandler = messageHandler;\n                            this._readyCapability.resolve();\n                            messageHandler.send(\"configure\", {\n                                verbosity: this.verbosity\n                            });\n                        }).catch((reason)=>{\n                            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n                        });\n                    }\n                    destroy() {\n                        this.destroyed = true;\n                        if (this._webWorker) {\n                            this._webWorker.terminate();\n                            this._webWorker = null;\n                        }\n                        PDFWorker.#workerPorts?.delete(this._port);\n                        this._port = null;\n                        if (this._messageHandler) {\n                            this._messageHandler.destroy();\n                            this._messageHandler = null;\n                        }\n                    }\n                    static fromPort(params) {\n                        if (!params?.port) {\n                            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n                        }\n                        const cachedPort = this.#workerPorts?.get(params.port);\n                        if (cachedPort) {\n                            if (cachedPort._pendingDestroy) {\n                                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n                            }\n                            return cachedPort;\n                        }\n                        return new PDFWorker(params);\n                    }\n                    static get workerSrc() {\n                        if (_worker_options.GlobalWorkerOptions.workerSrc) {\n                            return _worker_options.GlobalWorkerOptions.workerSrc;\n                        }\n                        if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n                            if (!_util.isNodeJS) {\n                                (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                            }\n                            return PDFWorkerUtil.fallbackWorkerSrc;\n                        }\n                        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                    }\n                    static get _mainThreadWorkerMessageHandler() {\n                        try {\n                            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n                        } catch  {\n                            return null;\n                        }\n                    }\n                    static get _setupFakeWorkerGlobal() {\n                        const loader = async ()=>{\n                            const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n                            if (mainWorkerMessageHandler) {\n                                return mainWorkerMessageHandler;\n                            }\n                            if (_util.isNodeJS && \"function\" === \"function\") {\n                                const worker = eval(\"require\")(this.workerSrc);\n                                return worker.WorkerMessageHandler;\n                            }\n                            await (0, _display_utils.loadScript)(this.workerSrc);\n                            return window.pdfjsWorker.WorkerMessageHandler;\n                        };\n                        return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n                    }\n                }\n                exports.PDFWorker = PDFWorker;\n                class WorkerTransport {\n                    #methodPromises;\n                    #pageCache;\n                    #pagePromises;\n                    #passwordCapability;\n                    constructor(messageHandler, loadingTask, networkStream, params, factory){\n                        this.#methodPromises = new Map();\n                        this.#pageCache = new Map();\n                        this.#pagePromises = new Map();\n                        this.#passwordCapability = null;\n                        this.messageHandler = messageHandler;\n                        this.loadingTask = loadingTask;\n                        this.commonObjs = new PDFObjects();\n                        this.fontLoader = new _font_loader.FontLoader({\n                            ownerDocument: params.ownerDocument,\n                            styleElement: params.styleElement\n                        });\n                        this._params = params;\n                        this.canvasFactory = factory.canvasFactory;\n                        this.filterFactory = factory.filterFactory;\n                        this.cMapReaderFactory = factory.cMapReaderFactory;\n                        this.standardFontDataFactory = factory.standardFontDataFactory;\n                        this.destroyed = false;\n                        this.destroyCapability = null;\n                        this._networkStream = networkStream;\n                        this._fullReader = null;\n                        this._lastProgress = null;\n                        this.downloadInfoCapability = new _util.PromiseCapability();\n                        this.setupMessageHandler();\n                    }\n                    #cacheSimpleMethod(name, data = null) {\n                        const cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, data);\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    get annotationStorage() {\n                        return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n                    }\n                    getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {\n                        let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n                        let annotationStorageSerializable = _annotation_storage.SerializableEmpty;\n                        switch(intent){\n                            case \"any\":\n                                renderingIntent = _util.RenderingIntentFlag.ANY;\n                                break;\n                            case \"display\":\n                                break;\n                            case \"print\":\n                                renderingIntent = _util.RenderingIntentFlag.PRINT;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n                        }\n                        switch(annotationMode){\n                            case _util.AnnotationMode.DISABLE:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                                break;\n                            case _util.AnnotationMode.ENABLE:\n                                break;\n                            case _util.AnnotationMode.ENABLE_FORMS:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n                                break;\n                            case _util.AnnotationMode.ENABLE_STORAGE:\n                                renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                                const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n                                annotationStorageSerializable = annotationStorage.serializable;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n                        }\n                        if (isOpList) {\n                            renderingIntent += _util.RenderingIntentFlag.OPLIST;\n                        }\n                        return {\n                            renderingIntent,\n                            cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,\n                            annotationStorageSerializable\n                        };\n                    }\n                    destroy() {\n                        if (this.destroyCapability) {\n                            return this.destroyCapability.promise;\n                        }\n                        this.destroyed = true;\n                        this.destroyCapability = new _util.PromiseCapability();\n                        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n                        const waitOn = [];\n                        for (const page of this.#pageCache.values()){\n                            waitOn.push(page._destroy());\n                        }\n                        this.#pageCache.clear();\n                        this.#pagePromises.clear();\n                        if (this.hasOwnProperty(\"annotationStorage\")) {\n                            this.annotationStorage.resetModified();\n                        }\n                        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n                        waitOn.push(terminated);\n                        Promise.all(waitOn).then(()=>{\n                            this.commonObjs.clear();\n                            this.fontLoader.clear();\n                            this.#methodPromises.clear();\n                            this.filterFactory.destroy();\n                            this._networkStream?.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n                            if (this.messageHandler) {\n                                this.messageHandler.destroy();\n                                this.messageHandler = null;\n                            }\n                            this.destroyCapability.resolve();\n                        }, this.destroyCapability.reject);\n                        return this.destroyCapability.promise;\n                    }\n                    setupMessageHandler() {\n                        const { messageHandler, loadingTask } = this;\n                        messageHandler.on(\"GetReader\", (data, sink)=>{\n                            (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n                            this._fullReader = this._networkStream.getFullReader();\n                            this._fullReader.onProgress = (evt)=>{\n                                this._lastProgress = {\n                                    loaded: evt.loaded,\n                                    total: evt.total\n                                };\n                            };\n                            sink.onPull = ()=>{\n                                this._fullReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                this._fullReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"ReaderHeadersReady\", (data)=>{\n                            const headersCapability = new _util.PromiseCapability();\n                            const fullReader = this._fullReader;\n                            fullReader.headersReady.then(()=>{\n                                if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n                                    if (this._lastProgress) {\n                                        loadingTask.onProgress?.(this._lastProgress);\n                                    }\n                                    fullReader.onProgress = (evt)=>{\n                                        loadingTask.onProgress?.({\n                                            loaded: evt.loaded,\n                                            total: evt.total\n                                        });\n                                    };\n                                }\n                                headersCapability.resolve({\n                                    isStreamingSupported: fullReader.isStreamingSupported,\n                                    isRangeSupported: fullReader.isRangeSupported,\n                                    contentLength: fullReader.contentLength\n                                });\n                            }, headersCapability.reject);\n                            return headersCapability.promise;\n                        });\n                        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n                            (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n                            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n                            if (!rangeReader) {\n                                sink.close();\n                                return;\n                            }\n                            sink.onPull = ()=>{\n                                rangeReader.read().then(function({ value, done }) {\n                                    if (done) {\n                                        sink.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                                    sink.enqueue(new Uint8Array(value), 1, [\n                                        value\n                                    ]);\n                                }).catch((reason)=>{\n                                    sink.error(reason);\n                                });\n                            };\n                            sink.onCancel = (reason)=>{\n                                rangeReader.cancel(reason);\n                                sink.ready.catch((readyReason)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason;\n                                });\n                            };\n                        });\n                        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n                            this._numPages = pdfInfo.numPages;\n                            this._htmlForXfa = pdfInfo.htmlForXfa;\n                            delete pdfInfo.htmlForXfa;\n                            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n                        });\n                        messageHandler.on(\"DocException\", function(ex) {\n                            let reason;\n                            switch(ex.name){\n                                case \"PasswordException\":\n                                    reason = new _util.PasswordException(ex.message, ex.code);\n                                    break;\n                                case \"InvalidPDFException\":\n                                    reason = new _util.InvalidPDFException(ex.message);\n                                    break;\n                                case \"MissingPDFException\":\n                                    reason = new _util.MissingPDFException(ex.message);\n                                    break;\n                                case \"UnexpectedResponseException\":\n                                    reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n                                    break;\n                                case \"UnknownErrorException\":\n                                    reason = new _util.UnknownErrorException(ex.message, ex.details);\n                                    break;\n                                default:\n                                    (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n                            }\n                            loadingTask._capability.reject(reason);\n                        });\n                        messageHandler.on(\"PasswordRequest\", (exception)=>{\n                            this.#passwordCapability = new _util.PromiseCapability();\n                            if (loadingTask.onPassword) {\n                                const updatePassword = (password)=>{\n                                    if (password instanceof Error) {\n                                        this.#passwordCapability.reject(password);\n                                    } else {\n                                        this.#passwordCapability.resolve({\n                                            password\n                                        });\n                                    }\n                                };\n                                try {\n                                    loadingTask.onPassword(updatePassword, exception.code);\n                                } catch (ex) {\n                                    this.#passwordCapability.reject(ex);\n                                }\n                            } else {\n                                this.#passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n                            }\n                            return this.#passwordCapability.promise;\n                        });\n                        messageHandler.on(\"DataLoaded\", (data)=>{\n                            loadingTask.onProgress?.({\n                                loaded: data.length,\n                                total: data.length\n                            });\n                            this.downloadInfoCapability.resolve(data);\n                        });\n                        messageHandler.on(\"StartRenderPage\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const page = this.#pageCache.get(data.pageIndex);\n                            page._startRenderPage(data.transparency, data.cacheKey);\n                        });\n                        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            if (this.commonObjs.has(id)) {\n                                return;\n                            }\n                            switch(type){\n                                case \"Font\":\n                                    const params = this._params;\n                                    if (\"error\" in exportedData) {\n                                        const exportedError = exportedData.error;\n                                        (0, _util.warn)(`Error during font loading: ${exportedError}`);\n                                        this.commonObjs.resolve(id, exportedError);\n                                        break;\n                                    }\n                                    const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                                    const font = new _font_loader.FontFaceObject(exportedData, {\n                                        isEvalSupported: params.isEvalSupported,\n                                        disableFontFace: params.disableFontFace,\n                                        ignoreErrors: params.ignoreErrors,\n                                        inspectFont\n                                    });\n                                    this.fontLoader.bind(font).catch((reason)=>{\n                                        return messageHandler.sendWithPromise(\"FontFallback\", {\n                                            id\n                                        });\n                                    }).finally(()=>{\n                                        if (!params.fontExtraProperties && font.data) {\n                                            font.data = null;\n                                        }\n                                        this.commonObjs.resolve(id, font);\n                                    });\n                                    break;\n                                case \"FontPath\":\n                                case \"Image\":\n                                case \"Pattern\":\n                                    this.commonObjs.resolve(id, exportedData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown common object type ${type}`);\n                            }\n                        });\n                        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const pageProxy = this.#pageCache.get(pageIndex);\n                            if (pageProxy.objs.has(id)) {\n                                return;\n                            }\n                            switch(type){\n                                case \"Image\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    if (imageData) {\n                                        let length;\n                                        if (imageData.bitmap) {\n                                            const { width, height } = imageData;\n                                            length = width * height * 4;\n                                        } else {\n                                            length = imageData.data?.length || 0;\n                                        }\n                                        if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n                                            pageProxy._maybeCleanupAfterRender = true;\n                                        }\n                                    }\n                                    break;\n                                case \"Pattern\":\n                                    pageProxy.objs.resolve(id, imageData);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown object type ${type}`);\n                            }\n                        });\n                        messageHandler.on(\"DocProgress\", (data)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            loadingTask.onProgress?.({\n                                loaded: data.loaded,\n                                total: data.total\n                            });\n                        });\n                        messageHandler.on(\"FetchBuiltInCMap\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.cMapReaderFactory) {\n                                return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.cMapReaderFactory.fetch(data);\n                        });\n                        messageHandler.on(\"FetchStandardFontData\", (data)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.standardFontDataFactory) {\n                                return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.standardFontDataFactory.fetch(data);\n                        });\n                    }\n                    getData() {\n                        return this.messageHandler.sendWithPromise(\"GetData\", null);\n                    }\n                    saveDocument() {\n                        if (this.annotationStorage.size <= 0) {\n                            (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n                        }\n                        const { map, transfers } = this.annotationStorage.serializable;\n                        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n                            isPureXfa: !!this._htmlForXfa,\n                            numPages: this._numPages,\n                            annotationStorage: map,\n                            filename: this._fullReader?.filename ?? null\n                        }, transfers).finally(()=>{\n                            this.annotationStorage.resetModified();\n                        });\n                    }\n                    getPage(pageNumber) {\n                        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n                            return Promise.reject(new Error(\"Invalid page request.\"));\n                        }\n                        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n                            pageIndex\n                        }).then((pageInfo)=>{\n                            if (this.destroyed) {\n                                throw new Error(\"Transport destroyed\");\n                            }\n                            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n                            this.#pageCache.set(pageIndex, page);\n                            return page;\n                        });\n                        this.#pagePromises.set(pageIndex, promise);\n                        return promise;\n                    }\n                    getPageIndex(ref) {\n                        if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n                            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n                            num: ref.num,\n                            gen: ref.gen\n                        });\n                    }\n                    getAnnotations(pageIndex, intent) {\n                        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n                            pageIndex,\n                            intent\n                        });\n                    }\n                    getFieldObjects() {\n                        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n                    }\n                    hasJSActions() {\n                        return this.#cacheSimpleMethod(\"HasJSActions\");\n                    }\n                    getCalculationOrderIds() {\n                        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n                    }\n                    getDestinations() {\n                        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n                    }\n                    getDestination(id) {\n                        if (typeof id !== \"string\") {\n                            return Promise.reject(new Error(\"Invalid destination request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n                            id\n                        });\n                    }\n                    getPageLabels() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n                    }\n                    getPageLayout() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n                    }\n                    getPageMode() {\n                        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n                    }\n                    getViewerPreferences() {\n                        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n                    }\n                    getOpenAction() {\n                        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n                    }\n                    getAttachments() {\n                        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n                    }\n                    getDocJSActions() {\n                        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n                    }\n                    getPageJSActions(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n                            pageIndex\n                        });\n                    }\n                    getStructTree(pageIndex) {\n                        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n                            pageIndex\n                        });\n                    }\n                    getOutline() {\n                        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n                    }\n                    getOptionalContentConfig() {\n                        return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then((results)=>{\n                            return new _optional_content_config.OptionalContentConfig(results);\n                        });\n                    }\n                    getPermissions() {\n                        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n                    }\n                    getMetadata() {\n                        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n                        if (cachedPromise) {\n                            return cachedPromise;\n                        }\n                        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>{\n                            return {\n                                info: results[0],\n                                metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n                                contentDispositionFilename: this._fullReader?.filename ?? null,\n                                contentLength: this._fullReader?.contentLength ?? null\n                            };\n                        });\n                        this.#methodPromises.set(name, promise);\n                        return promise;\n                    }\n                    getMarkInfo() {\n                        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n                    }\n                    async startCleanup(keepLoadedFonts = false) {\n                        if (this.destroyed) {\n                            return;\n                        }\n                        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n                        for (const page of this.#pageCache.values()){\n                            const cleanupSuccessful = page.cleanup();\n                            if (!cleanupSuccessful) {\n                                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n                            }\n                        }\n                        this.commonObjs.clear();\n                        if (!keepLoadedFonts) {\n                            this.fontLoader.clear();\n                        }\n                        this.#methodPromises.clear();\n                        this.filterFactory.destroy(true);\n                    }\n                    get loadingParams() {\n                        const { disableAutoFetch, enableXfa } = this._params;\n                        return (0, _util.shadow)(this, \"loadingParams\", {\n                            disableAutoFetch,\n                            enableXfa\n                        });\n                    }\n                }\n                class PDFObjects {\n                    #objs;\n                    #ensureObj(objId) {\n                        return this.#objs[objId] ||= {\n                            capability: new _util.PromiseCapability(),\n                            data: null\n                        };\n                    }\n                    get(objId, callback = null) {\n                        if (callback) {\n                            const obj = this.#ensureObj(objId);\n                            obj.capability.promise.then(()=>callback(obj.data));\n                            return null;\n                        }\n                        const obj = this.#objs[objId];\n                        if (!obj?.capability.settled) {\n                            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n                        }\n                        return obj.data;\n                    }\n                    has(objId) {\n                        const obj = this.#objs[objId];\n                        return obj?.capability.settled || false;\n                    }\n                    resolve(objId, data = null) {\n                        const obj = this.#ensureObj(objId);\n                        obj.data = data;\n                        obj.capability.resolve();\n                    }\n                    clear() {\n                        for(const objId in this.#objs){\n                            const { data } = this.#objs[objId];\n                            data?.bitmap?.close();\n                        }\n                        this.#objs = Object.create(null);\n                    }\n                    constructor(){\n                        this.#objs = Object.create(null);\n                    }\n                }\n                class RenderTask {\n                    #internalRenderTask;\n                    constructor(internalRenderTask){\n                        this.#internalRenderTask = null;\n                        this.#internalRenderTask = internalRenderTask;\n                        this.onContinue = null;\n                    }\n                    get promise() {\n                        return this.#internalRenderTask.capability.promise;\n                    }\n                    cancel(extraDelay = 0) {\n                        this.#internalRenderTask.cancel(null, extraDelay);\n                    }\n                    get separateAnnots() {\n                        const { separateAnnots } = this.#internalRenderTask.operatorList;\n                        if (!separateAnnots) {\n                            return false;\n                        }\n                        const { annotationCanvasMap } = this.#internalRenderTask;\n                        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n                    }\n                }\n                exports.RenderTask = RenderTask;\n                class InternalRenderTask {\n                    static #canvasInUse = new WeakSet();\n                    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n                        this.callback = callback;\n                        this.params = params;\n                        this.objs = objs;\n                        this.commonObjs = commonObjs;\n                        this.annotationCanvasMap = annotationCanvasMap;\n                        this.operatorListIdx = null;\n                        this.operatorList = operatorList;\n                        this._pageIndex = pageIndex;\n                        this.canvasFactory = canvasFactory;\n                        this.filterFactory = filterFactory;\n                        this._pdfBug = pdfBug;\n                        this.pageColors = pageColors;\n                        this.running = false;\n                        this.graphicsReadyCallback = null;\n                        this.graphicsReady = false;\n                        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n                        this.cancelled = false;\n                        this.capability = new _util.PromiseCapability();\n                        this.task = new RenderTask(this);\n                        this._cancelBound = this.cancel.bind(this);\n                        this._continueBound = this._continue.bind(this);\n                        this._scheduleNextBound = this._scheduleNext.bind(this);\n                        this._nextBound = this._next.bind(this);\n                        this._canvas = params.canvasContext.canvas;\n                    }\n                    get completed() {\n                        return this.capability.promise.catch(function() {});\n                    }\n                    initializeGraphics({ transparency = false, optionalContentConfig }) {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this._canvas) {\n                            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n                            }\n                            InternalRenderTask.#canvasInUse.add(this._canvas);\n                        }\n                        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n                            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n                            this.stepper.init(this.operatorList);\n                            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n                        }\n                        const { canvasContext, viewport, transform, background } = this.params;\n                        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                            optionalContentConfig\n                        }, this.annotationCanvasMap, this.pageColors);\n                        this.gfx.beginDrawing({\n                            transform,\n                            viewport,\n                            transparency,\n                            background\n                        });\n                        this.operatorListIdx = 0;\n                        this.graphicsReady = true;\n                        this.graphicsReadyCallback?.();\n                    }\n                    cancel(error = null, extraDelay = 0) {\n                        this.running = false;\n                        this.cancelled = true;\n                        this.gfx?.endDrawing();\n                        InternalRenderTask.#canvasInUse.delete(this._canvas);\n                        this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n                    }\n                    operatorListChanged() {\n                        if (!this.graphicsReady) {\n                            this.graphicsReadyCallback ||= this._continueBound;\n                            return;\n                        }\n                        this.stepper?.updateOperatorList(this.operatorList);\n                        if (this.running) {\n                            return;\n                        }\n                        this._continue();\n                    }\n                    _continue() {\n                        this.running = true;\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this.task.onContinue) {\n                            this.task.onContinue(this._scheduleNextBound);\n                        } else {\n                            this._scheduleNext();\n                        }\n                    }\n                    _scheduleNext() {\n                        if (this._useRequestAnimationFrame) {\n                            window.requestAnimationFrame(()=>{\n                                this._nextBound().catch(this._cancelBound);\n                            });\n                        } else {\n                            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n                        }\n                    }\n                    async _next() {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n                        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                            this.running = false;\n                            if (this.operatorList.lastChunk) {\n                                this.gfx.endDrawing();\n                                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                                this.callback();\n                            }\n                        }\n                    }\n                }\n                const version = \"3.11.174\";\n                exports.version = version;\n                const build = \"ce8716743\";\n                exports.build = build;\n            /***/ },\n            /* 3 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SerializableEmpty = exports1.PrintAnnotationStorage = exports1.AnnotationStorage = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _murmurhash = __w_pdfjs_require__(8);\n                const SerializableEmpty = Object.freeze({\n                    map: null,\n                    hash: \"\",\n                    transfers: undefined\n                });\n                exports1.SerializableEmpty = SerializableEmpty;\n                class AnnotationStorage {\n                    #modified;\n                    #storage;\n                    constructor(){\n                        this.#modified = false;\n                        this.#storage = new Map();\n                        this.onSetModified = null;\n                        this.onResetModified = null;\n                        this.onAnnotationEditor = null;\n                    }\n                    getValue(key, defaultValue) {\n                        const value = this.#storage.get(key);\n                        if (value === undefined) {\n                            return defaultValue;\n                        }\n                        return Object.assign(defaultValue, value);\n                    }\n                    getRawValue(key) {\n                        return this.#storage.get(key);\n                    }\n                    remove(key) {\n                        this.#storage.delete(key);\n                        if (this.#storage.size === 0) {\n                            this.resetModified();\n                        }\n                        if (typeof this.onAnnotationEditor === \"function\") {\n                            for (const value of this.#storage.values()){\n                                if (value instanceof _editor.AnnotationEditor) {\n                                    return;\n                                }\n                            }\n                            this.onAnnotationEditor(null);\n                        }\n                    }\n                    setValue(key, value) {\n                        const obj = this.#storage.get(key);\n                        let modified = false;\n                        if (obj !== undefined) {\n                            for (const [entry, val] of Object.entries(value)){\n                                if (obj[entry] !== val) {\n                                    modified = true;\n                                    obj[entry] = val;\n                                }\n                            }\n                        } else {\n                            modified = true;\n                            this.#storage.set(key, value);\n                        }\n                        if (modified) {\n                            this.#setModified();\n                        }\n                        if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n                            this.onAnnotationEditor(value.constructor._type);\n                        }\n                    }\n                    has(key) {\n                        return this.#storage.has(key);\n                    }\n                    getAll() {\n                        return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null;\n                    }\n                    setAll(obj) {\n                        for (const [key, val] of Object.entries(obj)){\n                            this.setValue(key, val);\n                        }\n                    }\n                    get size() {\n                        return this.#storage.size;\n                    }\n                    #setModified() {\n                        if (!this.#modified) {\n                            this.#modified = true;\n                            if (typeof this.onSetModified === \"function\") {\n                                this.onSetModified();\n                            }\n                        }\n                    }\n                    resetModified() {\n                        if (this.#modified) {\n                            this.#modified = false;\n                            if (typeof this.onResetModified === \"function\") {\n                                this.onResetModified();\n                            }\n                        }\n                    }\n                    get print() {\n                        return new PrintAnnotationStorage(this);\n                    }\n                    get serializable() {\n                        if (this.#storage.size === 0) {\n                            return SerializableEmpty;\n                        }\n                        const map = new Map(), hash = new _murmurhash.MurmurHash3_64(), transfers = [];\n                        const context = Object.create(null);\n                        let hasBitmap = false;\n                        for (const [key, val] of this.#storage){\n                            const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;\n                            if (serialized) {\n                                map.set(key, serialized);\n                                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                                hasBitmap ||= !!serialized.bitmap;\n                            }\n                        }\n                        if (hasBitmap) {\n                            for (const value of map.values()){\n                                if (value.bitmap) {\n                                    transfers.push(value.bitmap);\n                                }\n                            }\n                        }\n                        return map.size > 0 ? {\n                            map,\n                            hash: hash.hexdigest(),\n                            transfers\n                        } : SerializableEmpty;\n                    }\n                }\n                exports1.AnnotationStorage = AnnotationStorage;\n                class PrintAnnotationStorage extends AnnotationStorage {\n                    #serializable;\n                    constructor(parent){\n                        super();\n                        const { map, hash, transfers } = parent.serializable;\n                        const clone = structuredClone(map, transfers ? {\n                            transfer: transfers\n                        } : null);\n                        this.#serializable = {\n                            map: clone,\n                            hash,\n                            transfers\n                        };\n                    }\n                    get print() {\n                        (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n                    }\n                    get serializable() {\n                        return this.#serializable;\n                    }\n                }\n                exports1.PrintAnnotationStorage = PrintAnnotationStorage;\n            /***/ },\n            /* 4 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditor = void 0;\n                var _tools = __w_pdfjs_require__(5);\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                class AnnotationEditor {\n                    #altText;\n                    #altTextDecorative;\n                    #altTextButton;\n                    #altTextTooltip;\n                    #altTextTooltipTimeout;\n                    #keepAspectRatio;\n                    #resizersDiv;\n                    #boundFocusin;\n                    #boundFocusout;\n                    #hasBeenClicked;\n                    #isEditing;\n                    #isInEditMode;\n                    #isDraggable;\n                    #zIndex;\n                    static{\n                        this._borderLineWidth = -1;\n                    }\n                    static{\n                        this._colorManager = new _tools.ColorManager();\n                    }\n                    static{\n                        this._zIndex = 1;\n                    }\n                    static{\n                        this.SMALL_EDITOR_SIZE = 0;\n                    }\n                    constructor(parameters){\n                        this.#altText = \"\";\n                        this.#altTextDecorative = false;\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                        this.#altTextTooltipTimeout = null;\n                        this.#keepAspectRatio = false;\n                        this.#resizersDiv = null;\n                        this.#boundFocusin = this.focusin.bind(this);\n                        this.#boundFocusout = this.focusout.bind(this);\n                        this.#hasBeenClicked = false;\n                        this.#isEditing = false;\n                        this.#isInEditMode = false;\n                        this._initialOptions = Object.create(null);\n                        this._uiManager = null;\n                        this._focusEventsAllowed = true;\n                        this._l10nPromise = null;\n                        this.#isDraggable = false;\n                        this.#zIndex = AnnotationEditor._zIndex++;\n                        if (this.constructor === AnnotationEditor) {\n                            (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n                        }\n                        this.parent = parameters.parent;\n                        this.id = parameters.id;\n                        this.width = this.height = null;\n                        this.pageIndex = parameters.parent.pageIndex;\n                        this.name = parameters.name;\n                        this.div = null;\n                        this._uiManager = parameters.uiManager;\n                        this.annotationElementId = null;\n                        this._willKeepAspectRatio = false;\n                        this._initialOptions.isCentered = parameters.isCentered;\n                        this._structTreeParentId = null;\n                        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n                        this.rotation = rotation;\n                        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n                        this.pageDimensions = [\n                            pageWidth,\n                            pageHeight\n                        ];\n                        this.pageTranslation = [\n                            pageX,\n                            pageY\n                        ];\n                        const [width, height] = this.parentDimensions;\n                        this.x = parameters.x / width;\n                        this.y = parameters.y / height;\n                        this.isAttachedToDOM = false;\n                        this.deleted = false;\n                    }\n                    get editorType() {\n                        return Object.getPrototypeOf(this).constructor._type;\n                    }\n                    static get _defaultLineColor() {\n                        return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n                    }\n                    static deleteAnnotationElement(editor) {\n                        const fakeEditor = new FakeEditor({\n                            id: editor.parent.getNextId(),\n                            parent: editor.parent,\n                            uiManager: editor._uiManager\n                        });\n                        fakeEditor.annotationElementId = editor.annotationElementId;\n                        fakeEditor.deleted = true;\n                        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n                    }\n                    static initialize(l10n, options = null) {\n                        AnnotationEditor._l10nPromise ||= new Map([\n                            \"editor_alt_text_button_label\",\n                            \"editor_alt_text_edit_button_label\",\n                            \"editor_alt_text_decorative_tooltip\"\n                        ].map((str)=>[\n                                str,\n                                l10n.get(str)\n                            ]));\n                        if (options?.strings) {\n                            for (const str of options.strings){\n                                AnnotationEditor._l10nPromise.set(str, l10n.get(str));\n                            }\n                        }\n                        if (AnnotationEditor._borderLineWidth !== -1) {\n                            return;\n                        }\n                        const style = getComputedStyle(document.documentElement);\n                        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n                    }\n                    static updateDefaultParams(_type, _value) {}\n                    static get defaultPropertiesToUpdate() {\n                        return [];\n                    }\n                    static isHandlingMimeForPasting(mime) {\n                        return false;\n                    }\n                    static paste(item, parent) {\n                        (0, _util.unreachable)(\"Not implemented\");\n                    }\n                    get propertiesToUpdate() {\n                        return [];\n                    }\n                    get _isDraggable() {\n                        return this.#isDraggable;\n                    }\n                    set _isDraggable(value) {\n                        this.#isDraggable = value;\n                        this.div?.classList.toggle(\"draggable\", value);\n                    }\n                    center() {\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        switch(this.parentRotation){\n                            case 90:\n                                this.x -= this.height * pageHeight / (pageWidth * 2);\n                                this.y += this.width * pageWidth / (pageHeight * 2);\n                                break;\n                            case 180:\n                                this.x += this.width / 2;\n                                this.y += this.height / 2;\n                                break;\n                            case 270:\n                                this.x += this.height * pageHeight / (pageWidth * 2);\n                                this.y -= this.width * pageWidth / (pageHeight * 2);\n                                break;\n                            default:\n                                this.x -= this.width / 2;\n                                this.y -= this.height / 2;\n                                break;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    addCommands(params) {\n                        this._uiManager.addCommands(params);\n                    }\n                    get currentLayer() {\n                        return this._uiManager.currentLayer;\n                    }\n                    setInBackground() {\n                        this.div.style.zIndex = 0;\n                    }\n                    setInForeground() {\n                        this.div.style.zIndex = this.#zIndex;\n                    }\n                    setParent(parent) {\n                        if (parent !== null) {\n                            this.pageIndex = parent.pageIndex;\n                            this.pageDimensions = parent.pageDimensions;\n                        }\n                        this.parent = parent;\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.#hasBeenClicked) {\n                            this.parent.setSelected(this);\n                        } else {\n                            this.#hasBeenClicked = false;\n                        }\n                    }\n                    focusout(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            return;\n                        }\n                        const target = event.relatedTarget;\n                        if (target?.closest(`#${this.id}`)) {\n                            return;\n                        }\n                        event.preventDefault();\n                        if (!this.parent?.isMultipleSelection) {\n                            this.commitOrRemove();\n                        }\n                    }\n                    commitOrRemove() {\n                        if (this.isEmpty()) {\n                            this.remove();\n                        } else {\n                            this.commit();\n                        }\n                    }\n                    commit() {\n                        this.addToAnnotationStorage();\n                    }\n                    addToAnnotationStorage() {\n                        this._uiManager.addToAnnotationStorage(this);\n                    }\n                    setAt(x, y, tx, ty) {\n                        const [width, height] = this.parentDimensions;\n                        [tx, ty] = this.screenToPageTranslation(tx, ty);\n                        this.x = (x + tx) / width;\n                        this.y = (y + ty) / height;\n                        this.fixAndSetPosition();\n                    }\n                    #translate([width, height], x, y) {\n                        [x, y] = this.screenToPageTranslation(x, y);\n                        this.x += x / width;\n                        this.y += y / height;\n                        this.fixAndSetPosition();\n                    }\n                    translate(x, y) {\n                        this.#translate(this.parentDimensions, x, y);\n                    }\n                    translateInPage(x, y) {\n                        this.#translate(this.pageDimensions, x, y);\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    drag(tx, ty) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.x += tx / parentWidth;\n                        this.y += ty / parentHeight;\n                        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n                            const { x, y } = this.div.getBoundingClientRect();\n                            if (this.parent.findNewParent(this, x, y)) {\n                                this.x -= Math.floor(this.x);\n                                this.y -= Math.floor(this.y);\n                            }\n                        }\n                        let { x, y } = this;\n                        const [bx, by] = this.#getBaseTranslation();\n                        x += bx;\n                        y += by;\n                        this.div.style.left = `${(100 * x).toFixed(2)}%`;\n                        this.div.style.top = `${(100 * y).toFixed(2)}%`;\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    #getBaseTranslation() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const { _borderLineWidth } = AnnotationEditor;\n                        const x = _borderLineWidth / parentWidth;\n                        const y = _borderLineWidth / parentHeight;\n                        switch(this.rotation){\n                            case 90:\n                                return [\n                                    -x,\n                                    y\n                                ];\n                            case 180:\n                                return [\n                                    x,\n                                    y\n                                ];\n                            case 270:\n                                return [\n                                    x,\n                                    -y\n                                ];\n                            default:\n                                return [\n                                    -x,\n                                    -y\n                                ];\n                        }\n                    }\n                    fixAndSetPosition() {\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        let { x, y, width, height } = this;\n                        width *= pageWidth;\n                        height *= pageHeight;\n                        x *= pageWidth;\n                        y *= pageHeight;\n                        switch(this.rotation){\n                            case 0:\n                                x = Math.max(0, Math.min(pageWidth - width, x));\n                                y = Math.max(0, Math.min(pageHeight - height, y));\n                                break;\n                            case 90:\n                                x = Math.max(0, Math.min(pageWidth - height, x));\n                                y = Math.min(pageHeight, Math.max(width, y));\n                                break;\n                            case 180:\n                                x = Math.min(pageWidth, Math.max(width, x));\n                                y = Math.min(pageHeight, Math.max(height, y));\n                                break;\n                            case 270:\n                                x = Math.min(pageWidth, Math.max(height, x));\n                                y = Math.max(0, Math.min(pageHeight - width, y));\n                                break;\n                        }\n                        this.x = x /= pageWidth;\n                        this.y = y /= pageHeight;\n                        const [bx, by] = this.#getBaseTranslation();\n                        x += bx;\n                        y += by;\n                        const { style } = this.div;\n                        style.left = `${(100 * x).toFixed(2)}%`;\n                        style.top = `${(100 * y).toFixed(2)}%`;\n                        this.moveInDOM();\n                    }\n                    static #rotatePoint(x, y, angle) {\n                        switch(angle){\n                            case 90:\n                                return [\n                                    y,\n                                    -x\n                                ];\n                            case 180:\n                                return [\n                                    -x,\n                                    -y\n                                ];\n                            case 270:\n                                return [\n                                    -y,\n                                    x\n                                ];\n                            default:\n                                return [\n                                    x,\n                                    y\n                                ];\n                        }\n                    }\n                    screenToPageTranslation(x, y) {\n                        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n                    }\n                    pageTranslationToScreen(x, y) {\n                        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n                    }\n                    #getRotationMatrix(rotation) {\n                        switch(rotation){\n                            case 90:\n                                {\n                                    const [pageWidth, pageHeight] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        -pageWidth / pageHeight,\n                                        pageHeight / pageWidth,\n                                        0\n                                    ];\n                                }\n                            case 180:\n                                return [\n                                    -1,\n                                    0,\n                                    0,\n                                    -1\n                                ];\n                            case 270:\n                                {\n                                    const [pageWidth, pageHeight] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        pageWidth / pageHeight,\n                                        -pageHeight / pageWidth,\n                                        0\n                                    ];\n                                }\n                            default:\n                                return [\n                                    1,\n                                    0,\n                                    0,\n                                    1\n                                ];\n                        }\n                    }\n                    get parentScale() {\n                        return this._uiManager.viewParameters.realScale;\n                    }\n                    get parentRotation() {\n                        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n                    }\n                    get parentDimensions() {\n                        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n                        const scaledWidth = pageWidth * parentScale;\n                        const scaledHeight = pageHeight * parentScale;\n                        return _util.FeatureTest.isCSSRoundSupported ? [\n                            Math.round(scaledWidth),\n                            Math.round(scaledHeight)\n                        ] : [\n                            scaledWidth,\n                            scaledHeight\n                        ];\n                    }\n                    setDims(width, height) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n                        if (!this.#keepAspectRatio) {\n                            this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n                        }\n                        this.#altTextButton?.classList.toggle(\"small\", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);\n                    }\n                    fixDims() {\n                        const { style } = this.div;\n                        const { height, width } = style;\n                        const widthPercent = width.endsWith(\"%\");\n                        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n                        if (widthPercent && heightPercent) {\n                            return;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        if (!widthPercent) {\n                            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n                        }\n                        if (!this.#keepAspectRatio && !heightPercent) {\n                            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n                        }\n                    }\n                    getInitialTranslation() {\n                        return [\n                            0,\n                            0\n                        ];\n                    }\n                    #createResizers() {\n                        if (this.#resizersDiv) {\n                            return;\n                        }\n                        this.#resizersDiv = document.createElement(\"div\");\n                        this.#resizersDiv.classList.add(\"resizers\");\n                        const classes = [\n                            \"topLeft\",\n                            \"topRight\",\n                            \"bottomRight\",\n                            \"bottomLeft\"\n                        ];\n                        if (!this._willKeepAspectRatio) {\n                            classes.push(\"topMiddle\", \"middleRight\", \"bottomMiddle\", \"middleLeft\");\n                        }\n                        for (const name of classes){\n                            const div = document.createElement(\"div\");\n                            this.#resizersDiv.append(div);\n                            div.classList.add(\"resizer\", name);\n                            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name));\n                            div.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        }\n                        this.div.prepend(this.#resizersDiv);\n                    }\n                    #resizerPointerdown(name, event) {\n                        event.preventDefault();\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        const boundResizerPointermove = this.#resizerPointermove.bind(this, name);\n                        const savedDraggable = this._isDraggable;\n                        this._isDraggable = false;\n                        const pointerMoveOptions = {\n                            passive: true,\n                            capture: true\n                        };\n                        window.addEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                        const savedX = this.x;\n                        const savedY = this.y;\n                        const savedWidth = this.width;\n                        const savedHeight = this.height;\n                        const savedParentCursor = this.parent.div.style.cursor;\n                        const savedCursor = this.div.style.cursor;\n                        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n                        const pointerUpCallback = ()=>{\n                            this._isDraggable = savedDraggable;\n                            window.removeEventListener(\"pointerup\", pointerUpCallback);\n                            window.removeEventListener(\"blur\", pointerUpCallback);\n                            window.removeEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n                            this.parent.div.style.cursor = savedParentCursor;\n                            this.div.style.cursor = savedCursor;\n                            const newX = this.x;\n                            const newY = this.y;\n                            const newWidth = this.width;\n                            const newHeight = this.height;\n                            if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n                                return;\n                            }\n                            this.addCommands({\n                                cmd: ()=>{\n                                    this.width = newWidth;\n                                    this.height = newHeight;\n                                    this.x = newX;\n                                    this.y = newY;\n                                    const [parentWidth, parentHeight] = this.parentDimensions;\n                                    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                                    this.fixAndSetPosition();\n                                },\n                                undo: ()=>{\n                                    this.width = savedWidth;\n                                    this.height = savedHeight;\n                                    this.x = savedX;\n                                    this.y = savedY;\n                                    const [parentWidth, parentHeight] = this.parentDimensions;\n                                    this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n                                    this.fixAndSetPosition();\n                                },\n                                mustExec: true\n                            });\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback);\n                        window.addEventListener(\"blur\", pointerUpCallback);\n                    }\n                    #resizerPointermove(name, event) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const savedX = this.x;\n                        const savedY = this.y;\n                        const savedWidth = this.width;\n                        const savedHeight = this.height;\n                        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n                        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n                        const round = (x)=>Math.round(x * 10000) / 10000;\n                        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n                        const transf = (x, y)=>[\n                                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                                rotationMatrix[1] * x + rotationMatrix[3] * y\n                            ];\n                        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n                        const invTransf = (x, y)=>[\n                                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n                            ];\n                        let getPoint;\n                        let getOpposite;\n                        let isDiagonal = false;\n                        let isHorizontal = false;\n                        switch(name){\n                            case \"topLeft\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        h\n                                    ];\n                                break;\n                            case \"topMiddle\":\n                                getPoint = (w, h)=>[\n                                        w / 2,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w / 2,\n                                        h\n                                    ];\n                                break;\n                            case \"topRight\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        0\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        h\n                                    ];\n                                break;\n                            case \"middleRight\":\n                                isHorizontal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        h / 2\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        h / 2\n                                    ];\n                                break;\n                            case \"bottomRight\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        w,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        0,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomMiddle\":\n                                getPoint = (w, h)=>[\n                                        w / 2,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w / 2,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomLeft\":\n                                isDiagonal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        h\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        0\n                                    ];\n                                break;\n                            case \"middleLeft\":\n                                isHorizontal = true;\n                                getPoint = (w, h)=>[\n                                        0,\n                                        h / 2\n                                    ];\n                                getOpposite = (w, h)=>[\n                                        w,\n                                        h / 2\n                                    ];\n                                break;\n                        }\n                        const point = getPoint(savedWidth, savedHeight);\n                        const oppositePoint = getOpposite(savedWidth, savedHeight);\n                        let transfOppositePoint = transf(...oppositePoint);\n                        const oppositeX = round(savedX + transfOppositePoint[0]);\n                        const oppositeY = round(savedY + transfOppositePoint[1]);\n                        let ratioX = 1;\n                        let ratioY = 1;\n                        let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n                        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n                        if (isDiagonal) {\n                            const oldDiag = Math.hypot(savedWidth, savedHeight);\n                            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n                        } else if (isHorizontal) {\n                            ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n                        } else {\n                            ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n                        }\n                        const newWidth = round(savedWidth * ratioX);\n                        const newHeight = round(savedHeight * ratioY);\n                        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n                        const newX = oppositeX - transfOppositePoint[0];\n                        const newY = oppositeY - transfOppositePoint[1];\n                        this.width = newWidth;\n                        this.height = newHeight;\n                        this.x = newX;\n                        this.y = newY;\n                        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                        this.fixAndSetPosition();\n                    }\n                    async addAltTextButton() {\n                        if (this.#altTextButton) {\n                            return;\n                        }\n                        const altText = this.#altTextButton = document.createElement(\"button\");\n                        altText.className = \"altText\";\n                        const msg = await AnnotationEditor._l10nPromise.get(\"editor_alt_text_button_label\");\n                        altText.textContent = msg;\n                        altText.setAttribute(\"aria-label\", msg);\n                        altText.tabIndex = \"0\";\n                        altText.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation());\n                        altText.addEventListener(\"click\", (event)=>{\n                            event.preventDefault();\n                            this._uiManager.editAltText(this);\n                        }, {\n                            capture: true\n                        });\n                        altText.addEventListener(\"keydown\", (event)=>{\n                            if (event.target === altText && event.key === \"Enter\") {\n                                event.preventDefault();\n                                this._uiManager.editAltText(this);\n                            }\n                        });\n                        this.#setAltTextButtonState();\n                        this.div.append(altText);\n                        if (!AnnotationEditor.SMALL_EDITOR_SIZE) {\n                            const PERCENT = 40;\n                            AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));\n                        }\n                    }\n                    async #setAltTextButtonState() {\n                        const button = this.#altTextButton;\n                        if (!button) {\n                            return;\n                        }\n                        if (!this.#altText && !this.#altTextDecorative) {\n                            button.classList.remove(\"done\");\n                            this.#altTextTooltip?.remove();\n                            return;\n                        }\n                        AnnotationEditor._l10nPromise.get(\"editor_alt_text_edit_button_label\").then((msg)=>{\n                            button.setAttribute(\"aria-label\", msg);\n                        });\n                        let tooltip = this.#altTextTooltip;\n                        if (!tooltip) {\n                            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n                            tooltip.className = \"tooltip\";\n                            tooltip.setAttribute(\"role\", \"tooltip\");\n                            const id = tooltip.id = `alt-text-tooltip-${this.id}`;\n                            button.setAttribute(\"aria-describedby\", id);\n                            const DELAY_TO_SHOW_TOOLTIP = 100;\n                            button.addEventListener(\"mouseenter\", ()=>{\n                                this.#altTextTooltipTimeout = setTimeout(()=>{\n                                    this.#altTextTooltipTimeout = null;\n                                    this.#altTextTooltip.classList.add(\"show\");\n                                    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                                        source: this,\n                                        details: {\n                                            type: \"editing\",\n                                            subtype: this.editorType,\n                                            data: {\n                                                action: \"alt_text_tooltip\"\n                                            }\n                                        }\n                                    });\n                                }, DELAY_TO_SHOW_TOOLTIP);\n                            });\n                            button.addEventListener(\"mouseleave\", ()=>{\n                                clearTimeout(this.#altTextTooltipTimeout);\n                                this.#altTextTooltipTimeout = null;\n                                this.#altTextTooltip?.classList.remove(\"show\");\n                            });\n                        }\n                        button.classList.add(\"done\");\n                        tooltip.innerText = this.#altTextDecorative ? await AnnotationEditor._l10nPromise.get(\"editor_alt_text_decorative_tooltip\") : this.#altText;\n                        if (!tooltip.parentNode) {\n                            button.append(tooltip);\n                        }\n                    }\n                    getClientDimensions() {\n                        return this.div.getBoundingClientRect();\n                    }\n                    get altTextData() {\n                        return {\n                            altText: this.#altText,\n                            decorative: this.#altTextDecorative\n                        };\n                    }\n                    set altTextData({ altText, decorative }) {\n                        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n                            return;\n                        }\n                        this.#altText = altText;\n                        this.#altTextDecorative = decorative;\n                        this.#setAltTextButtonState();\n                    }\n                    render() {\n                        this.div = document.createElement(\"div\");\n                        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n                        this.div.className = this.name;\n                        this.div.setAttribute(\"id\", this.id);\n                        this.div.setAttribute(\"tabIndex\", 0);\n                        this.setInForeground();\n                        this.div.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.addEventListener(\"focusout\", this.#boundFocusout);\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        if (this.parentRotation % 180 !== 0) {\n                            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n                            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n                        }\n                        const [tx, ty] = this.getInitialTranslation();\n                        this.translate(tx, ty);\n                        (0, _tools.bindEvents)(this, this.div, [\n                            \"pointerdown\"\n                        ]);\n                        return this.div;\n                    }\n                    pointerdown(event) {\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            event.preventDefault();\n                            return;\n                        }\n                        this.#hasBeenClicked = true;\n                        this.#setUpDragSession(event);\n                    }\n                    #setUpDragSession(event) {\n                        if (!this._isDraggable) {\n                            return;\n                        }\n                        const isSelected = this._uiManager.isSelected(this);\n                        this._uiManager.setUpDragSession();\n                        let pointerMoveOptions, pointerMoveCallback;\n                        if (isSelected) {\n                            pointerMoveOptions = {\n                                passive: true,\n                                capture: true\n                            };\n                            pointerMoveCallback = (e)=>{\n                                const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);\n                                this._uiManager.dragSelectedEditors(tx, ty);\n                            };\n                            window.addEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                        }\n                        const pointerUpCallback = ()=>{\n                            window.removeEventListener(\"pointerup\", pointerUpCallback);\n                            window.removeEventListener(\"blur\", pointerUpCallback);\n                            if (isSelected) {\n                                window.removeEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n                            }\n                            this.#hasBeenClicked = false;\n                            if (!this._uiManager.endDragSession()) {\n                                const { isMac } = _util.FeatureTest.platform;\n                                if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n                                    this.parent.toggleSelected(this);\n                                } else {\n                                    this.parent.setSelected(this);\n                                }\n                            }\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback);\n                        window.addEventListener(\"blur\", pointerUpCallback);\n                    }\n                    moveInDOM() {\n                        this.parent?.moveEditorInDOM(this);\n                    }\n                    _setParentAndPosition(parent, x, y) {\n                        parent.changeParent(this);\n                        this.x = x;\n                        this.y = y;\n                        this.fixAndSetPosition();\n                    }\n                    getRect(tx, ty) {\n                        const scale = this.parentScale;\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        const [pageX, pageY] = this.pageTranslation;\n                        const shiftX = tx / scale;\n                        const shiftY = ty / scale;\n                        const x = this.x * pageWidth;\n                        const y = this.y * pageHeight;\n                        const width = this.width * pageWidth;\n                        const height = this.height * pageHeight;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x + shiftX + pageX,\n                                    pageHeight - y - shiftY - height + pageY,\n                                    x + shiftX + width + pageX,\n                                    pageHeight - y - shiftY + pageY\n                                ];\n                            case 90:\n                                return [\n                                    x + shiftY + pageX,\n                                    pageHeight - y + shiftX + pageY,\n                                    x + shiftY + height + pageX,\n                                    pageHeight - y + shiftX + width + pageY\n                                ];\n                            case 180:\n                                return [\n                                    x - shiftX - width + pageX,\n                                    pageHeight - y + shiftY + pageY,\n                                    x - shiftX + pageX,\n                                    pageHeight - y + shiftY + height + pageY\n                                ];\n                            case 270:\n                                return [\n                                    x - shiftY - height + pageX,\n                                    pageHeight - y - shiftX - width + pageY,\n                                    x - shiftY + pageX,\n                                    pageHeight - y - shiftX + pageY\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    getRectInCurrentCoords(rect, pageHeight) {\n                        const [x1, y1, x2, y2] = rect;\n                        const width = x2 - x1;\n                        const height = y2 - y1;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x1,\n                                    pageHeight - y2,\n                                    width,\n                                    height\n                                ];\n                            case 90:\n                                return [\n                                    x1,\n                                    pageHeight - y1,\n                                    height,\n                                    width\n                                ];\n                            case 180:\n                                return [\n                                    x2,\n                                    pageHeight - y1,\n                                    width,\n                                    height\n                                ];\n                            case 270:\n                                return [\n                                    x2,\n                                    pageHeight - y2,\n                                    height,\n                                    width\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    onceAdded() {}\n                    isEmpty() {\n                        return false;\n                    }\n                    enableEditMode() {\n                        this.#isInEditMode = true;\n                    }\n                    disableEditMode() {\n                        this.#isInEditMode = false;\n                    }\n                    isInEditMode() {\n                        return this.#isInEditMode;\n                    }\n                    shouldGetKeyboardEvents() {\n                        return false;\n                    }\n                    needsToBeRebuilt() {\n                        return this.div && !this.isAttachedToDOM;\n                    }\n                    rebuild() {\n                        this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n                    }\n                    serialize(isForCopying = false, context = null) {\n                        (0, _util.unreachable)(\"An editor must be serializable\");\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        const editor = new this.prototype.constructor({\n                            parent,\n                            id: parent.getNextId(),\n                            uiManager\n                        });\n                        editor.rotation = data.rotation;\n                        const [pageWidth, pageHeight] = editor.pageDimensions;\n                        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n                        editor.x = x / pageWidth;\n                        editor.y = y / pageHeight;\n                        editor.width = width / pageWidth;\n                        editor.height = height / pageHeight;\n                        return editor;\n                    }\n                    remove() {\n                        this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        if (this.parent) {\n                            this.parent.remove(this);\n                        } else {\n                            this._uiManager.removeEditor(this);\n                        }\n                        this.#altTextButton?.remove();\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                    }\n                    get isResizable() {\n                        return false;\n                    }\n                    makeResizable() {\n                        if (this.isResizable) {\n                            this.#createResizers();\n                            this.#resizersDiv.classList.remove(\"hidden\");\n                        }\n                    }\n                    select() {\n                        this.makeResizable();\n                        this.div?.classList.add(\"selectedEditor\");\n                    }\n                    unselect() {\n                        this.#resizersDiv?.classList.add(\"hidden\");\n                        this.div?.classList.remove(\"selectedEditor\");\n                        if (this.div?.contains(document.activeElement)) {\n                            this._uiManager.currentLayer.div.focus();\n                        }\n                    }\n                    updateParams(type, value) {}\n                    disableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = true;\n                        }\n                    }\n                    enableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = false;\n                        }\n                    }\n                    enterInEditMode() {}\n                    get contentDiv() {\n                        return this.div;\n                    }\n                    get isEditing() {\n                        return this.#isEditing;\n                    }\n                    set isEditing(value) {\n                        this.#isEditing = value;\n                        if (!this.parent) {\n                            return;\n                        }\n                        if (value) {\n                            this.parent.setSelected(this);\n                            this.parent.setActiveEditor(this);\n                        } else {\n                            this.parent.setActiveEditor(null);\n                        }\n                    }\n                    setAspectRatio(width, height) {\n                        this.#keepAspectRatio = true;\n                        const aspectRatio = width / height;\n                        const { style } = this.div;\n                        style.aspectRatio = aspectRatio;\n                        style.height = \"auto\";\n                    }\n                    static get MIN_SIZE() {\n                        return 16;\n                    }\n                }\n                exports1.AnnotationEditor = AnnotationEditor;\n                class FakeEditor extends AnnotationEditor {\n                    constructor(params){\n                        super(params);\n                        this.annotationElementId = params.annotationElementId;\n                        this.deleted = true;\n                    }\n                    serialize() {\n                        return {\n                            id: this.annotationElementId,\n                            deleted: true,\n                            pageIndex: this.pageIndex\n                        };\n                    }\n                }\n            /***/ },\n            /* 5 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.KeyboardManager = exports1.CommandManager = exports1.ColorManager = exports1.AnnotationEditorUIManager = void 0;\n                exports1.bindEvents = bindEvents;\n                exports1.opacityToHex = opacityToHex;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                function bindEvents(obj, element, names) {\n                    for (const name of names){\n                        element.addEventListener(name, obj[name].bind(obj));\n                    }\n                }\n                function opacityToHex(opacity) {\n                    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n                }\n                class IdManager {\n                    #id;\n                    getId() {\n                        return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n                    }\n                    constructor(){\n                        this.#id = 0;\n                    }\n                }\n                class ImageManager {\n                    #baseId;\n                    #id;\n                    #cache;\n                    static get _isSVGFittingCanvas() {\n                        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n                        const canvas = new OffscreenCanvas(1, 3);\n                        const ctx = canvas.getContext(\"2d\");\n                        const image = new Image();\n                        image.src = svg;\n                        const promise = image.decode().then(()=>{\n                            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n                            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n                        });\n                        return (0, _util.shadow)(this, \"_isSVGFittingCanvas\", promise);\n                    }\n                    async #get(key, rawData) {\n                        this.#cache ||= new Map();\n                        let data = this.#cache.get(key);\n                        if (data === null) {\n                            return null;\n                        }\n                        if (data?.bitmap) {\n                            data.refCounter += 1;\n                            return data;\n                        }\n                        try {\n                            data ||= {\n                                bitmap: null,\n                                id: `image_${this.#baseId}_${this.#id++}`,\n                                refCounter: 0,\n                                isSvg: false\n                            };\n                            let image;\n                            if (typeof rawData === \"string\") {\n                                data.url = rawData;\n                                const response = await fetch(rawData);\n                                if (!response.ok) {\n                                    throw new Error(response.statusText);\n                                }\n                                image = await response.blob();\n                            } else {\n                                image = data.file = rawData;\n                            }\n                            if (image.type === \"image/svg+xml\") {\n                                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                                const fileReader = new FileReader();\n                                const imageElement = new Image();\n                                const imagePromise = new Promise((resolve, reject)=>{\n                                    imageElement.onload = ()=>{\n                                        data.bitmap = imageElement;\n                                        data.isSvg = true;\n                                        resolve();\n                                    };\n                                    fileReader.onload = async ()=>{\n                                        const url = data.svgUrl = fileReader.result;\n                                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                                    };\n                                    imageElement.onerror = fileReader.onerror = reject;\n                                });\n                                fileReader.readAsDataURL(image);\n                                await imagePromise;\n                            } else {\n                                data.bitmap = await createImageBitmap(image);\n                            }\n                            data.refCounter = 1;\n                        } catch (e) {\n                            console.error(e);\n                            data = null;\n                        }\n                        this.#cache.set(key, data);\n                        if (data) {\n                            this.#cache.set(data.id, data);\n                        }\n                        return data;\n                    }\n                    async getFromFile(file) {\n                        const { lastModified, name, size, type } = file;\n                        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n                    }\n                    async getFromUrl(url) {\n                        return this.#get(url, url);\n                    }\n                    async getFromId(id) {\n                        this.#cache ||= new Map();\n                        const data = this.#cache.get(id);\n                        if (!data) {\n                            return null;\n                        }\n                        if (data.bitmap) {\n                            data.refCounter += 1;\n                            return data;\n                        }\n                        if (data.file) {\n                            return this.getFromFile(data.file);\n                        }\n                        return this.getFromUrl(data.url);\n                    }\n                    getSvgUrl(id) {\n                        const data = this.#cache.get(id);\n                        if (!data?.isSvg) {\n                            return null;\n                        }\n                        return data.svgUrl;\n                    }\n                    deleteId(id) {\n                        this.#cache ||= new Map();\n                        const data = this.#cache.get(id);\n                        if (!data) {\n                            return;\n                        }\n                        data.refCounter -= 1;\n                        if (data.refCounter !== 0) {\n                            return;\n                        }\n                        data.bitmap = null;\n                    }\n                    isValidId(id) {\n                        return id.startsWith(`image_${this.#baseId}_`);\n                    }\n                    constructor(){\n                        this.#baseId = (0, _util.getUuid)();\n                        this.#id = 0;\n                        this.#cache = null;\n                    }\n                }\n                class CommandManager {\n                    #commands;\n                    #locked;\n                    #maxSize;\n                    #position;\n                    constructor(maxSize = 128){\n                        this.#commands = [];\n                        this.#locked = false;\n                        this.#position = -1;\n                        this.#maxSize = maxSize;\n                    }\n                    add({ cmd, undo, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n                        if (mustExec) {\n                            cmd();\n                        }\n                        if (this.#locked) {\n                            return;\n                        }\n                        const save = {\n                            cmd,\n                            undo,\n                            type\n                        };\n                        if (this.#position === -1) {\n                            if (this.#commands.length > 0) {\n                                this.#commands.length = 0;\n                            }\n                            this.#position = 0;\n                            this.#commands.push(save);\n                            return;\n                        }\n                        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n                            if (keepUndo) {\n                                save.undo = this.#commands[this.#position].undo;\n                            }\n                            this.#commands[this.#position] = save;\n                            return;\n                        }\n                        const next = this.#position + 1;\n                        if (next === this.#maxSize) {\n                            this.#commands.splice(0, 1);\n                        } else {\n                            this.#position = next;\n                            if (next < this.#commands.length) {\n                                this.#commands.splice(next);\n                            }\n                        }\n                        this.#commands.push(save);\n                    }\n                    undo() {\n                        if (this.#position === -1) {\n                            return;\n                        }\n                        this.#locked = true;\n                        this.#commands[this.#position].undo();\n                        this.#locked = false;\n                        this.#position -= 1;\n                    }\n                    redo() {\n                        if (this.#position < this.#commands.length - 1) {\n                            this.#position += 1;\n                            this.#locked = true;\n                            this.#commands[this.#position].cmd();\n                            this.#locked = false;\n                        }\n                    }\n                    hasSomethingToUndo() {\n                        return this.#position !== -1;\n                    }\n                    hasSomethingToRedo() {\n                        return this.#position < this.#commands.length - 1;\n                    }\n                    destroy() {\n                        this.#commands = null;\n                    }\n                }\n                exports1.CommandManager = CommandManager;\n                class KeyboardManager {\n                    constructor(callbacks){\n                        this.buffer = [];\n                        this.callbacks = new Map();\n                        this.allKeys = new Set();\n                        const { isMac } = _util.FeatureTest.platform;\n                        for (const [keys, callback, options = {}] of callbacks){\n                            for (const key of keys){\n                                const isMacKey = key.startsWith(\"mac+\");\n                                if (isMac && isMacKey) {\n                                    this.callbacks.set(key.slice(4), {\n                                        callback,\n                                        options\n                                    });\n                                    this.allKeys.add(key.split(\"+\").at(-1));\n                                } else if (!isMac && !isMacKey) {\n                                    this.callbacks.set(key, {\n                                        callback,\n                                        options\n                                    });\n                                    this.allKeys.add(key.split(\"+\").at(-1));\n                                }\n                            }\n                        }\n                    }\n                    #serialize(event) {\n                        if (event.altKey) {\n                            this.buffer.push(\"alt\");\n                        }\n                        if (event.ctrlKey) {\n                            this.buffer.push(\"ctrl\");\n                        }\n                        if (event.metaKey) {\n                            this.buffer.push(\"meta\");\n                        }\n                        if (event.shiftKey) {\n                            this.buffer.push(\"shift\");\n                        }\n                        this.buffer.push(event.key);\n                        const str = this.buffer.join(\"+\");\n                        this.buffer.length = 0;\n                        return str;\n                    }\n                    exec(self, event) {\n                        if (!this.allKeys.has(event.key)) {\n                            return;\n                        }\n                        const info = this.callbacks.get(this.#serialize(event));\n                        if (!info) {\n                            return;\n                        }\n                        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n                        if (checker && !checker(self, event)) {\n                            return;\n                        }\n                        callback.bind(self, ...args)();\n                        if (!bubbles) {\n                            event.stopPropagation();\n                            event.preventDefault();\n                        }\n                    }\n                }\n                exports1.KeyboardManager = KeyboardManager;\n                class ColorManager {\n                    static{\n                        this._colorsMapping = new Map([\n                            [\n                                \"CanvasText\",\n                                [\n                                    0,\n                                    0,\n                                    0\n                                ]\n                            ],\n                            [\n                                \"Canvas\",\n                                [\n                                    255,\n                                    255,\n                                    255\n                                ]\n                            ]\n                        ]);\n                    }\n                    get _colors() {\n                        const colors = new Map([\n                            [\n                                \"CanvasText\",\n                                null\n                            ],\n                            [\n                                \"Canvas\",\n                                null\n                            ]\n                        ]);\n                        (0, _display_utils.getColorValues)(colors);\n                        return (0, _util.shadow)(this, \"_colors\", colors);\n                    }\n                    convert(color) {\n                        const rgb = (0, _display_utils.getRGB)(color);\n                        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n                            return rgb;\n                        }\n                        for (const [name, RGB] of this._colors){\n                            if (RGB.every((x, i)=>x === rgb[i])) {\n                                return ColorManager._colorsMapping.get(name);\n                            }\n                        }\n                        return rgb;\n                    }\n                    getHexCode(name) {\n                        const rgb = this._colors.get(name);\n                        if (!rgb) {\n                            return name;\n                        }\n                        return _util.Util.makeHexColor(...rgb);\n                    }\n                }\n                exports1.ColorManager = ColorManager;\n                class AnnotationEditorUIManager {\n                    #activeEditor;\n                    #allEditors;\n                    #allLayers;\n                    #altTextManager;\n                    #annotationStorage;\n                    #commandManager;\n                    #currentPageIndex;\n                    #deletedAnnotationsElementIds;\n                    #draggingEditors;\n                    #editorTypes;\n                    #editorsToRescale;\n                    #filterFactory;\n                    #idManager;\n                    #isEnabled;\n                    #isWaiting;\n                    #lastActiveElement;\n                    #mode;\n                    #selectedEditors;\n                    #pageColors;\n                    #boundBlur;\n                    #boundFocus;\n                    #boundCopy;\n                    #boundCut;\n                    #boundPaste;\n                    #boundKeydown;\n                    #boundOnEditingAction;\n                    #boundOnPageChanging;\n                    #boundOnScaleChanging;\n                    #boundOnRotationChanging;\n                    #previousStates;\n                    #translation;\n                    #translationTimeoutId;\n                    #container;\n                    #viewer;\n                    static{\n                        this.TRANSLATE_SMALL = 1;\n                    }\n                    static{\n                        this.TRANSLATE_BIG = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto = AnnotationEditorUIManager.prototype;\n                        const arrowChecker = (self)=>{\n                            const { activeElement } = document;\n                            return activeElement && self.#container.contains(activeElement) && self.hasSomethingToControl();\n                        };\n                        const small = this.TRANSLATE_SMALL;\n                        const big = this.TRANSLATE_BIG;\n                        return (0, _util.shadow)(this, \"_keyboardManager\", new KeyboardManager([\n                            [\n                                [\n                                    \"ctrl+a\",\n                                    \"mac+meta+a\"\n                                ],\n                                proto.selectAll\n                            ],\n                            [\n                                [\n                                    \"ctrl+z\",\n                                    \"mac+meta+z\"\n                                ],\n                                proto.undo\n                            ],\n                            [\n                                [\n                                    \"ctrl+y\",\n                                    \"ctrl+shift+z\",\n                                    \"mac+meta+shift+z\",\n                                    \"ctrl+shift+Z\",\n                                    \"mac+meta+shift+Z\"\n                                ],\n                                proto.redo\n                            ],\n                            [\n                                [\n                                    \"Backspace\",\n                                    \"alt+Backspace\",\n                                    \"ctrl+Backspace\",\n                                    \"shift+Backspace\",\n                                    \"mac+Backspace\",\n                                    \"mac+alt+Backspace\",\n                                    \"mac+ctrl+Backspace\",\n                                    \"Delete\",\n                                    \"ctrl+Delete\",\n                                    \"shift+Delete\",\n                                    \"mac+Delete\"\n                                ],\n                                proto.delete\n                            ],\n                            [\n                                [\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto.unselectAll\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ]\n                        ]));\n                    }\n                    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors){\n                        this.#activeEditor = null;\n                        this.#allEditors = new Map();\n                        this.#allLayers = new Map();\n                        this.#altTextManager = null;\n                        this.#annotationStorage = null;\n                        this.#commandManager = new CommandManager();\n                        this.#currentPageIndex = 0;\n                        this.#deletedAnnotationsElementIds = new Set();\n                        this.#draggingEditors = null;\n                        this.#editorTypes = null;\n                        this.#editorsToRescale = new Set();\n                        this.#filterFactory = null;\n                        this.#idManager = new IdManager();\n                        this.#isEnabled = false;\n                        this.#isWaiting = false;\n                        this.#lastActiveElement = null;\n                        this.#mode = _util.AnnotationEditorType.NONE;\n                        this.#selectedEditors = new Set();\n                        this.#pageColors = null;\n                        this.#boundBlur = this.blur.bind(this);\n                        this.#boundFocus = this.focus.bind(this);\n                        this.#boundCopy = this.copy.bind(this);\n                        this.#boundCut = this.cut.bind(this);\n                        this.#boundPaste = this.paste.bind(this);\n                        this.#boundKeydown = this.keydown.bind(this);\n                        this.#boundOnEditingAction = this.onEditingAction.bind(this);\n                        this.#boundOnPageChanging = this.onPageChanging.bind(this);\n                        this.#boundOnScaleChanging = this.onScaleChanging.bind(this);\n                        this.#boundOnRotationChanging = this.onRotationChanging.bind(this);\n                        this.#previousStates = {\n                            isEditing: false,\n                            isEmpty: true,\n                            hasSomethingToUndo: false,\n                            hasSomethingToRedo: false,\n                            hasSelectedEditor: false\n                        };\n                        this.#translation = [\n                            0,\n                            0\n                        ];\n                        this.#translationTimeoutId = null;\n                        this.#container = null;\n                        this.#viewer = null;\n                        this.#container = container;\n                        this.#viewer = viewer;\n                        this.#altTextManager = altTextManager;\n                        this._eventBus = eventBus;\n                        this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n                        this.#annotationStorage = pdfDocument.annotationStorage;\n                        this.#filterFactory = pdfDocument.filterFactory;\n                        this.#pageColors = pageColors;\n                        this.viewParameters = {\n                            realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,\n                            rotation: 0\n                        };\n                    }\n                    destroy() {\n                        this.#removeKeyboardManager();\n                        this.#removeFocusManager();\n                        this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n                        for (const layer of this.#allLayers.values()){\n                            layer.destroy();\n                        }\n                        this.#allLayers.clear();\n                        this.#allEditors.clear();\n                        this.#editorsToRescale.clear();\n                        this.#activeEditor = null;\n                        this.#selectedEditors.clear();\n                        this.#commandManager.destroy();\n                        this.#altTextManager.destroy();\n                    }\n                    get hcmFilter() {\n                        return (0, _util.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n                    }\n                    get direction() {\n                        return (0, _util.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n                    }\n                    editAltText(editor) {\n                        this.#altTextManager?.editAltText(this, editor);\n                    }\n                    onPageChanging({ pageNumber }) {\n                        this.#currentPageIndex = pageNumber - 1;\n                    }\n                    focusMainContainer() {\n                        this.#container.focus();\n                    }\n                    findParent(x, y) {\n                        for (const layer of this.#allLayers.values()){\n                            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n                            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                                return layer;\n                            }\n                        }\n                        return null;\n                    }\n                    disableUserSelect(value = false) {\n                        this.#viewer.classList.toggle(\"noUserSelect\", value);\n                    }\n                    addShouldRescale(editor) {\n                        this.#editorsToRescale.add(editor);\n                    }\n                    removeShouldRescale(editor) {\n                        this.#editorsToRescale.delete(editor);\n                    }\n                    onScaleChanging({ scale }) {\n                        this.commitOrRemove();\n                        this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;\n                        for (const editor of this.#editorsToRescale){\n                            editor.onScaleChanging();\n                        }\n                    }\n                    onRotationChanging({ pagesRotation }) {\n                        this.commitOrRemove();\n                        this.viewParameters.rotation = pagesRotation;\n                    }\n                    addToAnnotationStorage(editor) {\n                        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n                            this.#annotationStorage.setValue(editor.id, editor);\n                        }\n                    }\n                    #addFocusManager() {\n                        window.addEventListener(\"focus\", this.#boundFocus);\n                        window.addEventListener(\"blur\", this.#boundBlur);\n                    }\n                    #removeFocusManager() {\n                        window.removeEventListener(\"focus\", this.#boundFocus);\n                        window.removeEventListener(\"blur\", this.#boundBlur);\n                    }\n                    blur() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const { activeElement } = document;\n                        for (const editor of this.#selectedEditors){\n                            if (editor.div.contains(activeElement)) {\n                                this.#lastActiveElement = [\n                                    editor,\n                                    activeElement\n                                ];\n                                editor._focusEventsAllowed = false;\n                                break;\n                            }\n                        }\n                    }\n                    focus() {\n                        if (!this.#lastActiveElement) {\n                            return;\n                        }\n                        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n                        this.#lastActiveElement = null;\n                        lastActiveElement.addEventListener(\"focusin\", ()=>{\n                            lastEditor._focusEventsAllowed = true;\n                        }, {\n                            once: true\n                        });\n                        lastActiveElement.focus();\n                    }\n                    #addKeyboardManager() {\n                        window.addEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #removeKeyboardManager() {\n                        window.removeEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #addCopyPasteListeners() {\n                        document.addEventListener(\"copy\", this.#boundCopy);\n                        document.addEventListener(\"cut\", this.#boundCut);\n                        document.addEventListener(\"paste\", this.#boundPaste);\n                    }\n                    #removeCopyPasteListeners() {\n                        document.removeEventListener(\"copy\", this.#boundCopy);\n                        document.removeEventListener(\"cut\", this.#boundCut);\n                        document.removeEventListener(\"paste\", this.#boundPaste);\n                    }\n                    addEditListeners() {\n                        this.#addKeyboardManager();\n                        this.#addCopyPasteListeners();\n                    }\n                    removeEditListeners() {\n                        this.#removeKeyboardManager();\n                        this.#removeCopyPasteListeners();\n                    }\n                    copy(event) {\n                        event.preventDefault();\n                        this.#activeEditor?.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors = [];\n                        for (const editor of this.#selectedEditors){\n                            const serialized = editor.serialize(true);\n                            if (serialized) {\n                                editors.push(serialized);\n                            }\n                        }\n                        if (editors.length === 0) {\n                            return;\n                        }\n                        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n                    }\n                    cut(event) {\n                        this.copy(event);\n                        this.delete();\n                    }\n                    paste(event) {\n                        event.preventDefault();\n                        const { clipboardData } = event;\n                        for (const item of clipboardData.items){\n                            for (const editorType of this.#editorTypes){\n                                if (editorType.isHandlingMimeForPasting(item.type)) {\n                                    editorType.paste(item, this.currentLayer);\n                                    return;\n                                }\n                            }\n                        }\n                        let data = clipboardData.getData(\"application/pdfjs\");\n                        if (!data) {\n                            return;\n                        }\n                        try {\n                            data = JSON.parse(data);\n                        } catch (ex) {\n                            (0, _util.warn)(`paste: \"${ex.message}\".`);\n                            return;\n                        }\n                        if (!Array.isArray(data)) {\n                            return;\n                        }\n                        this.unselectAll();\n                        const layer = this.currentLayer;\n                        try {\n                            const newEditors = [];\n                            for (const editor of data){\n                                const deserializedEditor = layer.deserialize(editor);\n                                if (!deserializedEditor) {\n                                    return;\n                                }\n                                newEditors.push(deserializedEditor);\n                            }\n                            const cmd = ()=>{\n                                for (const editor of newEditors){\n                                    this.#addEditorToLayer(editor);\n                                }\n                                this.#selectEditors(newEditors);\n                            };\n                            const undo = ()=>{\n                                for (const editor of newEditors){\n                                    editor.remove();\n                                }\n                            };\n                            this.addCommands({\n                                cmd,\n                                undo,\n                                mustExec: true\n                            });\n                        } catch (ex) {\n                            (0, _util.warn)(`paste: \"${ex.message}\".`);\n                        }\n                    }\n                    keydown(event) {\n                        if (!this.getActive()?.shouldGetKeyboardEvents()) {\n                            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n                        }\n                    }\n                    onEditingAction(details) {\n                        if ([\n                            \"undo\",\n                            \"redo\",\n                            \"delete\",\n                            \"selectAll\"\n                        ].includes(details.name)) {\n                            this[details.name]();\n                        }\n                    }\n                    #dispatchUpdateStates(details) {\n                        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n                        if (hasChanged) {\n                            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                                source: this,\n                                details: Object.assign(this.#previousStates, details)\n                            });\n                        }\n                    }\n                    #dispatchUpdateUI(details) {\n                        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n                            source: this,\n                            details\n                        });\n                    }\n                    setEditingState(isEditing) {\n                        if (isEditing) {\n                            this.#addFocusManager();\n                            this.#addKeyboardManager();\n                            this.#addCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n                                isEmpty: this.#isEmpty(),\n                                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                                hasSelectedEditor: false\n                            });\n                        } else {\n                            this.#removeFocusManager();\n                            this.#removeKeyboardManager();\n                            this.#removeCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: false\n                            });\n                            this.disableUserSelect(false);\n                        }\n                    }\n                    registerEditorTypes(types) {\n                        if (this.#editorTypes) {\n                            return;\n                        }\n                        this.#editorTypes = types;\n                        for (const editorType of this.#editorTypes){\n                            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n                        }\n                    }\n                    getId() {\n                        return this.#idManager.getId();\n                    }\n                    get currentLayer() {\n                        return this.#allLayers.get(this.#currentPageIndex);\n                    }\n                    getLayer(pageIndex) {\n                        return this.#allLayers.get(pageIndex);\n                    }\n                    get currentPageIndex() {\n                        return this.#currentPageIndex;\n                    }\n                    addLayer(layer) {\n                        this.#allLayers.set(layer.pageIndex, layer);\n                        if (this.#isEnabled) {\n                            layer.enable();\n                        } else {\n                            layer.disable();\n                        }\n                    }\n                    removeLayer(layer) {\n                        this.#allLayers.delete(layer.pageIndex);\n                    }\n                    updateMode(mode, editId = null) {\n                        if (this.#mode === mode) {\n                            return;\n                        }\n                        this.#mode = mode;\n                        if (mode === _util.AnnotationEditorType.NONE) {\n                            this.setEditingState(false);\n                            this.#disableAll();\n                            return;\n                        }\n                        this.setEditingState(true);\n                        this.#enableAll();\n                        this.unselectAll();\n                        for (const layer of this.#allLayers.values()){\n                            layer.updateMode(mode);\n                        }\n                        if (!editId) {\n                            return;\n                        }\n                        for (const editor of this.#allEditors.values()){\n                            if (editor.annotationElementId === editId) {\n                                this.setSelected(editor);\n                                editor.enterInEditMode();\n                                break;\n                            }\n                        }\n                    }\n                    updateToolbar(mode) {\n                        if (mode === this.#mode) {\n                            return;\n                        }\n                        this._eventBus.dispatch(\"switchannotationeditormode\", {\n                            source: this,\n                            mode\n                        });\n                    }\n                    updateParams(type, value) {\n                        if (!this.#editorTypes) {\n                            return;\n                        }\n                        if (type === _util.AnnotationEditorParamsType.CREATE) {\n                            this.currentLayer.addNewEditor(type);\n                            return;\n                        }\n                        for (const editor of this.#selectedEditors){\n                            editor.updateParams(type, value);\n                        }\n                        for (const editorType of this.#editorTypes){\n                            editorType.updateDefaultParams(type, value);\n                        }\n                    }\n                    enableWaiting(mustWait = false) {\n                        if (this.#isWaiting === mustWait) {\n                            return;\n                        }\n                        this.#isWaiting = mustWait;\n                        for (const layer of this.#allLayers.values()){\n                            if (mustWait) {\n                                layer.disableClick();\n                            } else {\n                                layer.enableClick();\n                            }\n                            layer.div.classList.toggle(\"waiting\", mustWait);\n                        }\n                    }\n                    #enableAll() {\n                        if (!this.#isEnabled) {\n                            this.#isEnabled = true;\n                            for (const layer of this.#allLayers.values()){\n                                layer.enable();\n                            }\n                        }\n                    }\n                    #disableAll() {\n                        this.unselectAll();\n                        if (this.#isEnabled) {\n                            this.#isEnabled = false;\n                            for (const layer of this.#allLayers.values()){\n                                layer.disable();\n                            }\n                        }\n                    }\n                    getEditors(pageIndex) {\n                        const editors = [];\n                        for (const editor of this.#allEditors.values()){\n                            if (editor.pageIndex === pageIndex) {\n                                editors.push(editor);\n                            }\n                        }\n                        return editors;\n                    }\n                    getEditor(id) {\n                        return this.#allEditors.get(id);\n                    }\n                    addEditor(editor) {\n                        this.#allEditors.set(editor.id, editor);\n                    }\n                    removeEditor(editor) {\n                        this.#allEditors.delete(editor.id);\n                        this.unselect(editor);\n                        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n                            this.#annotationStorage?.remove(editor.id);\n                        }\n                    }\n                    addDeletedAnnotationElement(editor) {\n                        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n                        editor.deleted = true;\n                    }\n                    isDeletedAnnotationElement(annotationElementId) {\n                        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n                    }\n                    removeDeletedAnnotationElement(editor) {\n                        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n                        editor.deleted = false;\n                    }\n                    #addEditorToLayer(editor) {\n                        const layer = this.#allLayers.get(editor.pageIndex);\n                        if (layer) {\n                            layer.addOrRebuild(editor);\n                        } else {\n                            this.addEditor(editor);\n                        }\n                    }\n                    setActiveEditor(editor) {\n                        if (this.#activeEditor === editor) {\n                            return;\n                        }\n                        this.#activeEditor = editor;\n                        if (editor) {\n                            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        }\n                    }\n                    toggleSelected(editor) {\n                        if (this.#selectedEditors.has(editor)) {\n                            this.#selectedEditors.delete(editor);\n                            editor.unselect();\n                            this.#dispatchUpdateStates({\n                                hasSelectedEditor: this.hasSelection\n                            });\n                            return;\n                        }\n                        this.#selectedEditors.add(editor);\n                        editor.select();\n                        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    setSelected(editor) {\n                        for (const ed of this.#selectedEditors){\n                            if (ed !== editor) {\n                                ed.unselect();\n                            }\n                        }\n                        this.#selectedEditors.clear();\n                        this.#selectedEditors.add(editor);\n                        editor.select();\n                        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    isSelected(editor) {\n                        return this.#selectedEditors.has(editor);\n                    }\n                    unselect(editor) {\n                        editor.unselect();\n                        this.#selectedEditors.delete(editor);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: this.hasSelection\n                        });\n                    }\n                    get hasSelection() {\n                        return this.#selectedEditors.size !== 0;\n                    }\n                    undo() {\n                        this.#commandManager.undo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                            hasSomethingToRedo: true,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    redo() {\n                        this.#commandManager.redo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    addCommands(params) {\n                        this.#commandManager.add(params);\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: false,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    #isEmpty() {\n                        if (this.#allEditors.size === 0) {\n                            return true;\n                        }\n                        if (this.#allEditors.size === 1) {\n                            for (const editor of this.#allEditors.values()){\n                                return editor.isEmpty();\n                            }\n                        }\n                        return false;\n                    }\n                    delete() {\n                        this.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors = [\n                            ...this.#selectedEditors\n                        ];\n                        const cmd = ()=>{\n                            for (const editor of editors){\n                                editor.remove();\n                            }\n                        };\n                        const undo = ()=>{\n                            for (const editor of editors){\n                                this.#addEditorToLayer(editor);\n                            }\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: true\n                        });\n                    }\n                    commitOrRemove() {\n                        this.#activeEditor?.commitOrRemove();\n                    }\n                    hasSomethingToControl() {\n                        return this.#activeEditor || this.hasSelection;\n                    }\n                    #selectEditors(editors) {\n                        this.#selectedEditors.clear();\n                        for (const editor of editors){\n                            if (editor.isEmpty()) {\n                                continue;\n                            }\n                            this.#selectedEditors.add(editor);\n                            editor.select();\n                        }\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    selectAll() {\n                        for (const editor of this.#selectedEditors){\n                            editor.commit();\n                        }\n                        this.#selectEditors(this.#allEditors.values());\n                    }\n                    unselectAll() {\n                        if (this.#activeEditor) {\n                            this.#activeEditor.commitOrRemove();\n                            return;\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        for (const editor of this.#selectedEditors){\n                            editor.unselect();\n                        }\n                        this.#selectedEditors.clear();\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: false\n                        });\n                    }\n                    translateSelectedEditors(x, y, noCommit = false) {\n                        if (!noCommit) {\n                            this.commitOrRemove();\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.#translation[0] += x;\n                        this.#translation[1] += y;\n                        const [totalX, totalY] = this.#translation;\n                        const editors = [\n                            ...this.#selectedEditors\n                        ];\n                        const TIME_TO_WAIT = 1000;\n                        if (this.#translationTimeoutId) {\n                            clearTimeout(this.#translationTimeoutId);\n                        }\n                        this.#translationTimeoutId = setTimeout(()=>{\n                            this.#translationTimeoutId = null;\n                            this.#translation[0] = this.#translation[1] = 0;\n                            this.addCommands({\n                                cmd: ()=>{\n                                    for (const editor of editors){\n                                        if (this.#allEditors.has(editor.id)) {\n                                            editor.translateInPage(totalX, totalY);\n                                        }\n                                    }\n                                },\n                                undo: ()=>{\n                                    for (const editor of editors){\n                                        if (this.#allEditors.has(editor.id)) {\n                                            editor.translateInPage(-totalX, -totalY);\n                                        }\n                                    }\n                                },\n                                mustExec: false\n                            });\n                        }, TIME_TO_WAIT);\n                        for (const editor of editors){\n                            editor.translateInPage(x, y);\n                        }\n                    }\n                    setUpDragSession() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.disableUserSelect(true);\n                        this.#draggingEditors = new Map();\n                        for (const editor of this.#selectedEditors){\n                            this.#draggingEditors.set(editor, {\n                                savedX: editor.x,\n                                savedY: editor.y,\n                                savedPageIndex: editor.pageIndex,\n                                newX: 0,\n                                newY: 0,\n                                newPageIndex: -1\n                            });\n                        }\n                    }\n                    endDragSession() {\n                        if (!this.#draggingEditors) {\n                            return false;\n                        }\n                        this.disableUserSelect(false);\n                        const map = this.#draggingEditors;\n                        this.#draggingEditors = null;\n                        let mustBeAddedInUndoStack = false;\n                        for (const [{ x, y, pageIndex }, value] of map){\n                            value.newX = x;\n                            value.newY = y;\n                            value.newPageIndex = pageIndex;\n                            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n                        }\n                        if (!mustBeAddedInUndoStack) {\n                            return false;\n                        }\n                        const move = (editor, x, y, pageIndex)=>{\n                            if (this.#allEditors.has(editor.id)) {\n                                const parent = this.#allLayers.get(pageIndex);\n                                if (parent) {\n                                    editor._setParentAndPosition(parent, x, y);\n                                } else {\n                                    editor.pageIndex = pageIndex;\n                                    editor.x = x;\n                                    editor.y = y;\n                                }\n                            }\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                for (const [editor, { newX, newY, newPageIndex }] of map){\n                                    move(editor, newX, newY, newPageIndex);\n                                }\n                            },\n                            undo: ()=>{\n                                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                                    move(editor, savedX, savedY, savedPageIndex);\n                                }\n                            },\n                            mustExec: true\n                        });\n                        return true;\n                    }\n                    dragSelectedEditors(tx, ty) {\n                        if (!this.#draggingEditors) {\n                            return;\n                        }\n                        for (const editor of this.#draggingEditors.keys()){\n                            editor.drag(tx, ty);\n                        }\n                    }\n                    rebuild(editor) {\n                        if (editor.parent === null) {\n                            const parent = this.getLayer(editor.pageIndex);\n                            if (parent) {\n                                parent.changeParent(editor);\n                                parent.addOrRebuild(editor);\n                            } else {\n                                this.addEditor(editor);\n                                this.addToAnnotationStorage(editor);\n                                editor.rebuild();\n                            }\n                        } else {\n                            editor.parent.addOrRebuild(editor);\n                        }\n                    }\n                    isActive(editor) {\n                        return this.#activeEditor === editor;\n                    }\n                    getActive() {\n                        return this.#activeEditor;\n                    }\n                    getMode() {\n                        return this.#mode;\n                    }\n                    get imageManager() {\n                        return (0, _util.shadow)(this, \"imageManager\", new ImageManager());\n                    }\n                }\n                exports1.AnnotationEditorUIManager = AnnotationEditorUIManager;\n            /***/ },\n            /* 6 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StatTimer = exports1.RenderingCancelledException = exports1.PixelsPerInch = exports1.PageViewport = exports1.PDFDateString = exports1.DOMStandardFontDataFactory = exports1.DOMSVGFactory = exports1.DOMFilterFactory = exports1.DOMCanvasFactory = exports1.DOMCMapReaderFactory = void 0;\n                exports1.deprecated = deprecated;\n                exports1.getColorValues = getColorValues;\n                exports1.getCurrentTransform = getCurrentTransform;\n                exports1.getCurrentTransformInverse = getCurrentTransformInverse;\n                exports1.getFilenameFromUrl = getFilenameFromUrl;\n                exports1.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\n                exports1.getRGB = getRGB;\n                exports1.getXfaPageViewport = getXfaPageViewport;\n                exports1.isDataScheme = isDataScheme;\n                exports1.isPdfFile = isPdfFile;\n                exports1.isValidFetchUrl = isValidFetchUrl;\n                exports1.loadScript = loadScript;\n                exports1.noContextMenu = noContextMenu;\n                exports1.setLayerDimensions = setLayerDimensions;\n                var _base_factory = __w_pdfjs_require__(7);\n                var _util = __w_pdfjs_require__(1);\n                const SVG_NS = \"http://www.w3.org/2000/svg\";\n                class PixelsPerInch {\n                    static{\n                        this.CSS = 96.0;\n                    }\n                    static{\n                        this.PDF = 72.0;\n                    }\n                    static{\n                        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n                    }\n                }\n                exports1.PixelsPerInch = PixelsPerInch;\n                class DOMFilterFactory extends _base_factory.BaseFilterFactory {\n                    #_cache;\n                    #_defs;\n                    #docId;\n                    #document;\n                    #hcmFilter;\n                    #hcmKey;\n                    #hcmUrl;\n                    #hcmHighlightFilter;\n                    #hcmHighlightKey;\n                    #hcmHighlightUrl;\n                    #id;\n                    constructor({ docId, ownerDocument = globalThis.document } = {}){\n                        super();\n                        this.#id = 0;\n                        this.#docId = docId;\n                        this.#document = ownerDocument;\n                    }\n                    get #cache() {\n                        return this.#_cache ||= new Map();\n                    }\n                    get #defs() {\n                        if (!this.#_defs) {\n                            const div = this.#document.createElement(\"div\");\n                            const { style } = div;\n                            style.visibility = \"hidden\";\n                            style.contain = \"strict\";\n                            style.width = style.height = 0;\n                            style.position = \"absolute\";\n                            style.top = style.left = 0;\n                            style.zIndex = -1;\n                            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n                            svg.setAttribute(\"width\", 0);\n                            svg.setAttribute(\"height\", 0);\n                            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n                            div.append(svg);\n                            svg.append(this.#_defs);\n                            this.#document.body.append(div);\n                        }\n                        return this.#_defs;\n                    }\n                    addFilter(maps) {\n                        if (!maps) {\n                            return \"none\";\n                        }\n                        let value = this.#cache.get(maps);\n                        if (value) {\n                            return value;\n                        }\n                        let tableR, tableG, tableB, key;\n                        if (maps.length === 1) {\n                            const mapR = maps[0];\n                            const buffer = new Array(256);\n                            for(let i = 0; i < 256; i++){\n                                buffer[i] = mapR[i] / 255;\n                            }\n                            key = tableR = tableG = tableB = buffer.join(\",\");\n                        } else {\n                            const [mapR, mapG, mapB] = maps;\n                            const bufferR = new Array(256);\n                            const bufferG = new Array(256);\n                            const bufferB = new Array(256);\n                            for(let i = 0; i < 256; i++){\n                                bufferR[i] = mapR[i] / 255;\n                                bufferG[i] = mapG[i] / 255;\n                                bufferB[i] = mapB[i] / 255;\n                            }\n                            tableR = bufferR.join(\",\");\n                            tableG = bufferG.join(\",\");\n                            tableB = bufferB.join(\",\");\n                            key = `${tableR}${tableG}${tableB}`;\n                        }\n                        value = this.#cache.get(key);\n                        if (value) {\n                            this.#cache.set(maps, value);\n                            return value;\n                        }\n                        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n                        const url = `url(#${id})`;\n                        this.#cache.set(maps, url);\n                        this.#cache.set(key, url);\n                        const filter = this.#createFilter(id);\n                        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n                        return url;\n                    }\n                    addHCMFilter(fgColor, bgColor) {\n                        const key = `${fgColor}-${bgColor}`;\n                        if (this.#hcmKey === key) {\n                            return this.#hcmUrl;\n                        }\n                        this.#hcmKey = key;\n                        this.#hcmUrl = \"none\";\n                        this.#hcmFilter?.remove();\n                        if (!fgColor || !bgColor) {\n                            return this.#hcmUrl;\n                        }\n                        const fgRGB = this.#getRGB(fgColor);\n                        fgColor = _util.Util.makeHexColor(...fgRGB);\n                        const bgRGB = this.#getRGB(bgColor);\n                        bgColor = _util.Util.makeHexColor(...bgRGB);\n                        this.#defs.style.color = \"\";\n                        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n                            return this.#hcmUrl;\n                        }\n                        const map = new Array(256);\n                        for(let i = 0; i <= 255; i++){\n                            const x = i / 255;\n                            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n                        }\n                        const table = map.join(\",\");\n                        const id = `g_${this.#docId}_hcm_filter`;\n                        const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                        this.#addTransferMapConversion(table, table, table, filter);\n                        this.#addGrayConversion(filter);\n                        const getSteps = (c, n)=>{\n                            const start = fgRGB[c] / 255;\n                            const end = bgRGB[c] / 255;\n                            const arr = new Array(n + 1);\n                            for(let i = 0; i <= n; i++){\n                                arr[i] = start + i / n * (end - start);\n                            }\n                            return arr.join(\",\");\n                        };\n                        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n                        this.#hcmUrl = `url(#${id})`;\n                        return this.#hcmUrl;\n                    }\n                    addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n                        if (this.#hcmHighlightKey === key) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        this.#hcmHighlightKey = key;\n                        this.#hcmHighlightUrl = \"none\";\n                        this.#hcmHighlightFilter?.remove();\n                        if (!fgColor || !bgColor) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        const [fgRGB, bgRGB] = [\n                            fgColor,\n                            bgColor\n                        ].map(this.#getRGB.bind(this));\n                        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n                        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n                        let [newFgRGB, newBgRGB] = [\n                            newFgColor,\n                            newBgColor\n                        ].map(this.#getRGB.bind(this));\n                        if (bgGray < fgGray) {\n                            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                                bgGray,\n                                fgGray,\n                                newBgRGB,\n                                newFgRGB\n                            ];\n                        }\n                        this.#defs.style.color = \"\";\n                        const getSteps = (fg, bg, n)=>{\n                            const arr = new Array(256);\n                            const step = (bgGray - fgGray) / n;\n                            const newStart = fg / 255;\n                            const newStep = (bg - fg) / (255 * n);\n                            let prev = 0;\n                            for(let i = 0; i <= n; i++){\n                                const k = Math.round(fgGray + i * step);\n                                const value = newStart + i * newStep;\n                                for(let j = prev; j <= k; j++){\n                                    arr[j] = value;\n                                }\n                                prev = k + 1;\n                            }\n                            for(let i = prev; i < 256; i++){\n                                arr[i] = arr[prev - 1];\n                            }\n                            return arr.join(\",\");\n                        };\n                        const id = `g_${this.#docId}_hcm_highlight_filter`;\n                        const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n                        this.#addGrayConversion(filter);\n                        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n                        this.#hcmHighlightUrl = `url(#${id})`;\n                        return this.#hcmHighlightUrl;\n                    }\n                    destroy(keepHCM = false) {\n                        if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n                            return;\n                        }\n                        if (this.#_defs) {\n                            this.#_defs.parentNode.parentNode.remove();\n                            this.#_defs = null;\n                        }\n                        if (this.#_cache) {\n                            this.#_cache.clear();\n                            this.#_cache = null;\n                        }\n                        this.#id = 0;\n                    }\n                    #addGrayConversion(filter) {\n                        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n                        feColorMatrix.setAttribute(\"type\", \"matrix\");\n                        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n                        filter.append(feColorMatrix);\n                    }\n                    #createFilter(id) {\n                        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n                        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n                        filter.setAttribute(\"id\", id);\n                        this.#defs.append(filter);\n                        return filter;\n                    }\n                    #appendFeFunc(feComponentTransfer, func, table) {\n                        const feFunc = this.#document.createElementNS(SVG_NS, func);\n                        feFunc.setAttribute(\"type\", \"discrete\");\n                        feFunc.setAttribute(\"tableValues\", table);\n                        feComponentTransfer.append(feFunc);\n                    }\n                    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n                        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n                        filter.append(feComponentTransfer);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n                        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n                    }\n                    #getRGB(color) {\n                        this.#defs.style.color = color;\n                        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n                    }\n                }\n                exports1.DOMFilterFactory = DOMFilterFactory;\n                class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n                    constructor({ ownerDocument = globalThis.document } = {}){\n                        super();\n                        this._document = ownerDocument;\n                    }\n                    _createCanvas(width, height) {\n                        const canvas = this._document.createElement(\"canvas\");\n                        canvas.width = width;\n                        canvas.height = height;\n                        return canvas;\n                    }\n                }\n                exports1.DOMCanvasFactory = DOMCanvasFactory;\n                async function fetchData(url, asTypedArray = false) {\n                    if (isValidFetchUrl(url, document.baseURI)) {\n                        const response = await fetch(url);\n                        if (!response.ok) {\n                            throw new Error(response.statusText);\n                        }\n                        return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n                    }\n                    return new Promise((resolve, reject)=>{\n                        const request = new XMLHttpRequest();\n                        request.open(\"GET\", url, true);\n                        if (asTypedArray) {\n                            request.responseType = \"arraybuffer\";\n                        }\n                        request.onreadystatechange = ()=>{\n                            if (request.readyState !== XMLHttpRequest.DONE) {\n                                return;\n                            }\n                            if (request.status === 200 || request.status === 0) {\n                                let data;\n                                if (asTypedArray && request.response) {\n                                    data = new Uint8Array(request.response);\n                                } else if (!asTypedArray && request.responseText) {\n                                    data = (0, _util.stringToBytes)(request.responseText);\n                                }\n                                if (data) {\n                                    resolve(data);\n                                    return;\n                                }\n                            }\n                            reject(new Error(request.statusText));\n                        };\n                        request.send(null);\n                    });\n                }\n                class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n                    _fetchData(url, compressionType) {\n                        return fetchData(url, this.isCompressed).then((data)=>{\n                            return {\n                                cMapData: data,\n                                compressionType\n                            };\n                        });\n                    }\n                }\n                exports1.DOMCMapReaderFactory = DOMCMapReaderFactory;\n                class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n                    _fetchData(url) {\n                        return fetchData(url, true);\n                    }\n                }\n                exports1.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n                class DOMSVGFactory extends _base_factory.BaseSVGFactory {\n                    _createSVG(type) {\n                        return document.createElementNS(SVG_NS, type);\n                    }\n                }\n                exports1.DOMSVGFactory = DOMSVGFactory;\n                class PageViewport {\n                    constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n                        this.viewBox = viewBox;\n                        this.scale = scale;\n                        this.rotation = rotation;\n                        this.offsetX = offsetX;\n                        this.offsetY = offsetY;\n                        const centerX = (viewBox[2] + viewBox[0]) / 2;\n                        const centerY = (viewBox[3] + viewBox[1]) / 2;\n                        let rotateA, rotateB, rotateC, rotateD;\n                        rotation %= 360;\n                        if (rotation < 0) {\n                            rotation += 360;\n                        }\n                        switch(rotation){\n                            case 180:\n                                rotateA = -1;\n                                rotateB = 0;\n                                rotateC = 0;\n                                rotateD = 1;\n                                break;\n                            case 90:\n                                rotateA = 0;\n                                rotateB = 1;\n                                rotateC = 1;\n                                rotateD = 0;\n                                break;\n                            case 270:\n                                rotateA = 0;\n                                rotateB = -1;\n                                rotateC = -1;\n                                rotateD = 0;\n                                break;\n                            case 0:\n                                rotateA = 1;\n                                rotateB = 0;\n                                rotateC = 0;\n                                rotateD = -1;\n                                break;\n                            default:\n                                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n                        }\n                        if (dontFlip) {\n                            rotateC = -rotateC;\n                            rotateD = -rotateD;\n                        }\n                        let offsetCanvasX, offsetCanvasY;\n                        let width, height;\n                        if (rotateA === 0) {\n                            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n                            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n                            width = (viewBox[3] - viewBox[1]) * scale;\n                            height = (viewBox[2] - viewBox[0]) * scale;\n                        } else {\n                            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n                            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n                            width = (viewBox[2] - viewBox[0]) * scale;\n                            height = (viewBox[3] - viewBox[1]) * scale;\n                        }\n                        this.transform = [\n                            rotateA * scale,\n                            rotateB * scale,\n                            rotateC * scale,\n                            rotateD * scale,\n                            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n                            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n                        ];\n                        this.width = width;\n                        this.height = height;\n                    }\n                    get rawDims() {\n                        const { viewBox } = this;\n                        return (0, _util.shadow)(this, \"rawDims\", {\n                            pageWidth: viewBox[2] - viewBox[0],\n                            pageHeight: viewBox[3] - viewBox[1],\n                            pageX: viewBox[0],\n                            pageY: viewBox[1]\n                        });\n                    }\n                    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n                        return new PageViewport({\n                            viewBox: this.viewBox.slice(),\n                            scale,\n                            rotation,\n                            offsetX,\n                            offsetY,\n                            dontFlip\n                        });\n                    }\n                    convertToViewportPoint(x, y) {\n                        return _util.Util.applyTransform([\n                            x,\n                            y\n                        ], this.transform);\n                    }\n                    convertToViewportRectangle(rect) {\n                        const topLeft = _util.Util.applyTransform([\n                            rect[0],\n                            rect[1]\n                        ], this.transform);\n                        const bottomRight = _util.Util.applyTransform([\n                            rect[2],\n                            rect[3]\n                        ], this.transform);\n                        return [\n                            topLeft[0],\n                            topLeft[1],\n                            bottomRight[0],\n                            bottomRight[1]\n                        ];\n                    }\n                    convertToPdfPoint(x, y) {\n                        return _util.Util.applyInverseTransform([\n                            x,\n                            y\n                        ], this.transform);\n                    }\n                }\n                exports1.PageViewport = PageViewport;\n                class RenderingCancelledException extends _util.BaseException {\n                    constructor(msg, extraDelay = 0){\n                        super(msg, \"RenderingCancelledException\");\n                        this.extraDelay = extraDelay;\n                    }\n                }\n                exports1.RenderingCancelledException = RenderingCancelledException;\n                function isDataScheme(url) {\n                    const ii = url.length;\n                    let i = 0;\n                    while(i < ii && url[i].trim() === \"\"){\n                        i++;\n                    }\n                    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n                }\n                function isPdfFile(filename) {\n                    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n                }\n                function getFilenameFromUrl(url, onlyStripPath = false) {\n                    if (!onlyStripPath) {\n                        [url] = url.split(/[#?]/, 1);\n                    }\n                    return url.substring(url.lastIndexOf(\"/\") + 1);\n                }\n                function getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n                    if (typeof url !== \"string\") {\n                        return defaultFilename;\n                    }\n                    if (isDataScheme(url)) {\n                        (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n                        return defaultFilename;\n                    }\n                    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n                    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n                    const splitURI = reURI.exec(url);\n                    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n                    if (suggestedFilename) {\n                        suggestedFilename = suggestedFilename[0];\n                        if (suggestedFilename.includes(\"%\")) {\n                            try {\n                                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n                            } catch  {}\n                        }\n                    }\n                    return suggestedFilename || defaultFilename;\n                }\n                class StatTimer {\n                    time(name) {\n                        if (name in this.started) {\n                            (0, _util.warn)(`Timer is already running for ${name}`);\n                        }\n                        this.started[name] = Date.now();\n                    }\n                    timeEnd(name) {\n                        if (!(name in this.started)) {\n                            (0, _util.warn)(`Timer has not been started for ${name}`);\n                        }\n                        this.times.push({\n                            name,\n                            start: this.started[name],\n                            end: Date.now()\n                        });\n                        delete this.started[name];\n                    }\n                    toString() {\n                        const outBuf = [];\n                        let longest = 0;\n                        for (const { name } of this.times){\n                            longest = Math.max(name.length, longest);\n                        }\n                        for (const { name, start, end } of this.times){\n                            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n                        }\n                        return outBuf.join(\"\");\n                    }\n                    constructor(){\n                        this.started = Object.create(null);\n                        this.times = [];\n                    }\n                }\n                exports1.StatTimer = StatTimer;\n                function isValidFetchUrl(url, baseUrl) {\n                    try {\n                        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n                        return protocol === \"http:\" || protocol === \"https:\";\n                    } catch  {\n                        return false;\n                    }\n                }\n                function noContextMenu(e) {\n                    e.preventDefault();\n                }\n                function loadScript(src, removeScriptElement = false) {\n                    return new Promise((resolve, reject)=>{\n                        const script = document.createElement(\"script\");\n                        script.src = src;\n                        script.onload = function(evt) {\n                            if (removeScriptElement) {\n                                script.remove();\n                            }\n                            resolve(evt);\n                        };\n                        script.onerror = function() {\n                            reject(new Error(`Cannot load script at: ${script.src}`));\n                        };\n                        (document.head || document.documentElement).append(script);\n                    });\n                }\n                function deprecated(details) {\n                    console.log(\"Deprecated API usage: \" + details);\n                }\n                let pdfDateStringRegex;\n                class PDFDateString {\n                    static toDateObject(input) {\n                        if (!input || typeof input !== \"string\") {\n                            return null;\n                        }\n                        pdfDateStringRegex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n                        const matches = pdfDateStringRegex.exec(input);\n                        if (!matches) {\n                            return null;\n                        }\n                        const year = parseInt(matches[1], 10);\n                        let month = parseInt(matches[2], 10);\n                        month = month >= 1 && month <= 12 ? month - 1 : 0;\n                        let day = parseInt(matches[3], 10);\n                        day = day >= 1 && day <= 31 ? day : 1;\n                        let hour = parseInt(matches[4], 10);\n                        hour = hour >= 0 && hour <= 23 ? hour : 0;\n                        let minute = parseInt(matches[5], 10);\n                        minute = minute >= 0 && minute <= 59 ? minute : 0;\n                        let second = parseInt(matches[6], 10);\n                        second = second >= 0 && second <= 59 ? second : 0;\n                        const universalTimeRelation = matches[7] || \"Z\";\n                        let offsetHour = parseInt(matches[8], 10);\n                        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n                        let offsetMinute = parseInt(matches[9], 10) || 0;\n                        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n                        if (universalTimeRelation === \"-\") {\n                            hour += offsetHour;\n                            minute += offsetMinute;\n                        } else if (universalTimeRelation === \"+\") {\n                            hour -= offsetHour;\n                            minute -= offsetMinute;\n                        }\n                        return new Date(Date.UTC(year, month, day, hour, minute, second));\n                    }\n                }\n                exports1.PDFDateString = PDFDateString;\n                function getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n                    const { width, height } = xfaPage.attributes.style;\n                    const viewBox = [\n                        0,\n                        0,\n                        parseInt(width),\n                        parseInt(height)\n                    ];\n                    return new PageViewport({\n                        viewBox,\n                        scale,\n                        rotation\n                    });\n                }\n                function getRGB(color) {\n                    if (color.startsWith(\"#\")) {\n                        const colorRGB = parseInt(color.slice(1), 16);\n                        return [\n                            (colorRGB & 0xff0000) >> 16,\n                            (colorRGB & 0x00ff00) >> 8,\n                            colorRGB & 0x0000ff\n                        ];\n                    }\n                    if (color.startsWith(\"rgb(\")) {\n                        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n                    }\n                    if (color.startsWith(\"rgba(\")) {\n                        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n                    }\n                    (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n                    return [\n                        0,\n                        0,\n                        0\n                    ];\n                }\n                function getColorValues(colors) {\n                    const span = document.createElement(\"span\");\n                    span.style.visibility = \"hidden\";\n                    document.body.append(span);\n                    for (const name of colors.keys()){\n                        span.style.color = name;\n                        const computedColor = window.getComputedStyle(span).color;\n                        colors.set(name, getRGB(computedColor));\n                    }\n                    span.remove();\n                }\n                function getCurrentTransform(ctx) {\n                    const { a, b, c, d, e, f } = ctx.getTransform();\n                    return [\n                        a,\n                        b,\n                        c,\n                        d,\n                        e,\n                        f\n                    ];\n                }\n                function getCurrentTransformInverse(ctx) {\n                    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n                    return [\n                        a,\n                        b,\n                        c,\n                        d,\n                        e,\n                        f\n                    ];\n                }\n                function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n                    if (viewport instanceof PageViewport) {\n                        const { pageWidth, pageHeight } = viewport.rawDims;\n                        const { style } = div;\n                        const useRound = _util.FeatureTest.isCSSRoundSupported;\n                        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n                        const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`, heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;\n                        if (!mustFlip || viewport.rotation % 180 === 0) {\n                            style.width = widthStr;\n                            style.height = heightStr;\n                        } else {\n                            style.width = heightStr;\n                            style.height = widthStr;\n                        }\n                    }\n                    if (mustRotate) {\n                        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n                    }\n                }\n            /***/ },\n            /* 7 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.BaseStandardFontDataFactory = exports1.BaseSVGFactory = exports1.BaseFilterFactory = exports1.BaseCanvasFactory = exports1.BaseCMapReaderFactory = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class BaseFilterFactory {\n                    constructor(){\n                        if (this.constructor === BaseFilterFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n                        }\n                    }\n                    addFilter(maps) {\n                        return \"none\";\n                    }\n                    addHCMFilter(fgColor, bgColor) {\n                        return \"none\";\n                    }\n                    addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n                        return \"none\";\n                    }\n                    destroy(keepHCM = false) {}\n                }\n                exports1.BaseFilterFactory = BaseFilterFactory;\n                class BaseCanvasFactory {\n                    constructor(){\n                        if (this.constructor === BaseCanvasFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n                        }\n                    }\n                    create(width, height) {\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        const canvas = this._createCanvas(width, height);\n                        return {\n                            canvas,\n                            context: canvas.getContext(\"2d\")\n                        };\n                    }\n                    reset(canvasAndContext, width, height) {\n                        if (!canvasAndContext.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        canvasAndContext.canvas.width = width;\n                        canvasAndContext.canvas.height = height;\n                    }\n                    destroy(canvasAndContext) {\n                        if (!canvasAndContext.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        canvasAndContext.canvas.width = 0;\n                        canvasAndContext.canvas.height = 0;\n                        canvasAndContext.canvas = null;\n                        canvasAndContext.context = null;\n                    }\n                    _createCanvas(width, height) {\n                        (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n                    }\n                }\n                exports1.BaseCanvasFactory = BaseCanvasFactory;\n                class BaseCMapReaderFactory {\n                    constructor({ baseUrl = null, isCompressed = true }){\n                        if (this.constructor === BaseCMapReaderFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n                        }\n                        this.baseUrl = baseUrl;\n                        this.isCompressed = isCompressed;\n                    }\n                    async fetch({ name }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n                        }\n                        if (!name) {\n                            throw new Error(\"CMap name must be specified.\");\n                        }\n                        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                        const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n                        return this._fetchData(url, compressionType).catch((reason)=>{\n                            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n                        });\n                    }\n                    _fetchData(url, compressionType) {\n                        (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseCMapReaderFactory = BaseCMapReaderFactory;\n                class BaseStandardFontDataFactory {\n                    constructor({ baseUrl = null }){\n                        if (this.constructor === BaseStandardFontDataFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n                        }\n                        this.baseUrl = baseUrl;\n                    }\n                    async fetch({ filename }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n                        }\n                        if (!filename) {\n                            throw new Error(\"Font filename must be specified.\");\n                        }\n                        const url = `${this.baseUrl}${filename}`;\n                        return this._fetchData(url).catch((reason)=>{\n                            throw new Error(`Unable to load font data at: ${url}`);\n                        });\n                    }\n                    _fetchData(url) {\n                        (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n                class BaseSVGFactory {\n                    constructor(){\n                        if (this.constructor === BaseSVGFactory) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n                        }\n                    }\n                    create(width, height, skipDimensions = false) {\n                        if (width <= 0 || height <= 0) {\n                            throw new Error(\"Invalid SVG dimensions\");\n                        }\n                        const svg = this._createSVG(\"svg:svg\");\n                        svg.setAttribute(\"version\", \"1.1\");\n                        if (!skipDimensions) {\n                            svg.setAttribute(\"width\", `${width}px`);\n                            svg.setAttribute(\"height\", `${height}px`);\n                        }\n                        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n                        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n                        return svg;\n                    }\n                    createElement(type) {\n                        if (typeof type !== \"string\") {\n                            throw new Error(\"Invalid SVG element type\");\n                        }\n                        return this._createSVG(type);\n                    }\n                    _createSVG(type) {\n                        (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n                    }\n                }\n                exports1.BaseSVGFactory = BaseSVGFactory;\n            /***/ },\n            /* 8 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MurmurHash3_64 = void 0;\n                var _util = __w_pdfjs_require__(1);\n                const SEED = 0xc3d2e1f0;\n                const MASK_HIGH = 0xffff0000;\n                const MASK_LOW = 0xffff;\n                class MurmurHash3_64 {\n                    constructor(seed){\n                        this.h1 = seed ? seed & 0xffffffff : SEED;\n                        this.h2 = seed ? seed & 0xffffffff : SEED;\n                    }\n                    update(input) {\n                        let data, length;\n                        if (typeof input === \"string\") {\n                            data = new Uint8Array(input.length * 2);\n                            length = 0;\n                            for(let i = 0, ii = input.length; i < ii; i++){\n                                const code = input.charCodeAt(i);\n                                if (code <= 0xff) {\n                                    data[length++] = code;\n                                } else {\n                                    data[length++] = code >>> 8;\n                                    data[length++] = code & 0xff;\n                                }\n                            }\n                        } else if ((0, _util.isArrayBuffer)(input)) {\n                            data = input.slice();\n                            length = data.byteLength;\n                        } else {\n                            throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n                        }\n                        const blockCounts = length >> 2;\n                        const tailLength = length - blockCounts * 4;\n                        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n                        let k1 = 0, k2 = 0;\n                        let h1 = this.h1, h2 = this.h2;\n                        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n                        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n                        for(let i = 0; i < blockCounts; i++){\n                            if (i & 1) {\n                                k1 = dataUint32[i];\n                                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                                k1 = k1 << 15 | k1 >>> 17;\n                                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                                h1 ^= k1;\n                                h1 = h1 << 13 | h1 >>> 19;\n                                h1 = h1 * 5 + 0xe6546b64;\n                            } else {\n                                k2 = dataUint32[i];\n                                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                                k2 = k2 << 15 | k2 >>> 17;\n                                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                                h2 ^= k2;\n                                h2 = h2 << 13 | h2 >>> 19;\n                                h2 = h2 * 5 + 0xe6546b64;\n                            }\n                        }\n                        k1 = 0;\n                        switch(tailLength){\n                            case 3:\n                                k1 ^= data[blockCounts * 4 + 2] << 16;\n                            case 2:\n                                k1 ^= data[blockCounts * 4 + 1] << 8;\n                            case 1:\n                                k1 ^= data[blockCounts * 4];\n                                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                                k1 = k1 << 15 | k1 >>> 17;\n                                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                                if (blockCounts & 1) {\n                                    h1 ^= k1;\n                                } else {\n                                    h2 ^= k1;\n                                }\n                        }\n                        this.h1 = h1;\n                        this.h2 = h2;\n                    }\n                    hexdigest() {\n                        let h1 = this.h1, h2 = this.h2;\n                        h1 ^= h2 >>> 1;\n                        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n                        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n                        h1 ^= h2 >>> 1;\n                        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n                        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n                        h1 ^= h2 >>> 1;\n                        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n                    }\n                }\n                exports1.MurmurHash3_64 = MurmurHash3_64;\n            /***/ },\n            /* 9 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FontLoader = exports1.FontFaceObject = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class FontLoader {\n                    #systemFonts;\n                    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n                        this.#systemFonts = new Set();\n                        this._document = ownerDocument;\n                        this.nativeFontFaces = new Set();\n                        this.styleElement = null;\n                        this.loadingRequests = [];\n                        this.loadTestFontId = 0;\n                    }\n                    addNativeFontFace(nativeFontFace) {\n                        this.nativeFontFaces.add(nativeFontFace);\n                        this._document.fonts.add(nativeFontFace);\n                    }\n                    removeNativeFontFace(nativeFontFace) {\n                        this.nativeFontFaces.delete(nativeFontFace);\n                        this._document.fonts.delete(nativeFontFace);\n                    }\n                    insertRule(rule) {\n                        if (!this.styleElement) {\n                            this.styleElement = this._document.createElement(\"style\");\n                            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n                        }\n                        const styleSheet = this.styleElement.sheet;\n                        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n                    }\n                    clear() {\n                        for (const nativeFontFace of this.nativeFontFaces){\n                            this._document.fonts.delete(nativeFontFace);\n                        }\n                        this.nativeFontFaces.clear();\n                        this.#systemFonts.clear();\n                        if (this.styleElement) {\n                            this.styleElement.remove();\n                            this.styleElement = null;\n                        }\n                    }\n                    async loadSystemFont(info) {\n                        if (!info || this.#systemFonts.has(info.loadedName)) {\n                            return;\n                        }\n                        (0, _util.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n                        if (this.isFontLoadingAPISupported) {\n                            const { loadedName, src, style } = info;\n                            const fontFace = new FontFace(loadedName, src, style);\n                            this.addNativeFontFace(fontFace);\n                            try {\n                                await fontFace.load();\n                                this.#systemFonts.add(loadedName);\n                            } catch  {\n                                (0, _util.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                                this.removeNativeFontFace(fontFace);\n                            }\n                            return;\n                        }\n                        (0, _util.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n                    }\n                    async bind(font) {\n                        if (font.attached || font.missingFile && !font.systemFontInfo) {\n                            return;\n                        }\n                        font.attached = true;\n                        if (font.systemFontInfo) {\n                            await this.loadSystemFont(font.systemFontInfo);\n                            return;\n                        }\n                        if (this.isFontLoadingAPISupported) {\n                            const nativeFontFace = font.createNativeFontFace();\n                            if (nativeFontFace) {\n                                this.addNativeFontFace(nativeFontFace);\n                                try {\n                                    await nativeFontFace.loaded;\n                                } catch (ex) {\n                                    (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                                    font.disableFontFace = true;\n                                    throw ex;\n                                }\n                            }\n                            return;\n                        }\n                        const rule = font.createFontFaceRule();\n                        if (rule) {\n                            this.insertRule(rule);\n                            if (this.isSyncFontLoadingSupported) {\n                                return;\n                            }\n                            await new Promise((resolve)=>{\n                                const request = this._queueLoadingCallback(resolve);\n                                this._prepareFontLoadEvent(font, request);\n                            });\n                        }\n                    }\n                    get isFontLoadingAPISupported() {\n                        const hasFonts = !!this._document?.fonts;\n                        return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n                    }\n                    get isSyncFontLoadingSupported() {\n                        let supported = false;\n                        if (_util.isNodeJS) {\n                            supported = true;\n                        } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n                            supported = true;\n                        }\n                        return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n                    }\n                    _queueLoadingCallback(callback) {\n                        function completeRequest() {\n                            (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n                            request.done = true;\n                            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                                const otherRequest = loadingRequests.shift();\n                                setTimeout(otherRequest.callback, 0);\n                            }\n                        }\n                        const { loadingRequests } = this;\n                        const request = {\n                            done: false,\n                            complete: completeRequest,\n                            callback\n                        };\n                        loadingRequests.push(request);\n                        return request;\n                    }\n                    get _loadTestFont() {\n                        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n                        return (0, _util.shadow)(this, \"_loadTestFont\", testFont);\n                    }\n                    _prepareFontLoadEvent(font, request) {\n                        function int32(data, offset) {\n                            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n                        }\n                        function spliceString(s, offset, remove, insert) {\n                            const chunk1 = s.substring(0, offset);\n                            const chunk2 = s.substring(offset + remove);\n                            return chunk1 + insert + chunk2;\n                        }\n                        let i, ii;\n                        const canvas = this._document.createElement(\"canvas\");\n                        canvas.width = 1;\n                        canvas.height = 1;\n                        const ctx = canvas.getContext(\"2d\");\n                        let called = 0;\n                        function isFontReady(name, callback) {\n                            if (++called > 30) {\n                                (0, _util.warn)(\"Load test font never loaded.\");\n                                callback();\n                                return;\n                            }\n                            ctx.font = \"30px \" + name;\n                            ctx.fillText(\".\", 0, 20);\n                            const imageData = ctx.getImageData(0, 0, 1, 1);\n                            if (imageData.data[3] > 0) {\n                                callback();\n                                return;\n                            }\n                            setTimeout(isFontReady.bind(null, name, callback));\n                        }\n                        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n                        let data = this._loadTestFont;\n                        const COMMENT_OFFSET = 976;\n                        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n                        const CFF_CHECKSUM_OFFSET = 16;\n                        const XXXX_VALUE = 0x58585858;\n                        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n                        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n                            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n                        }\n                        if (i < loadTestFontId.length) {\n                            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n                        }\n                        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n                        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n                        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n                        this.insertRule(rule);\n                        const div = this._document.createElement(\"div\");\n                        div.style.visibility = \"hidden\";\n                        div.style.width = div.style.height = \"10px\";\n                        div.style.position = \"absolute\";\n                        div.style.top = div.style.left = \"0px\";\n                        for (const name of [\n                            font.loadedName,\n                            loadTestFontId\n                        ]){\n                            const span = this._document.createElement(\"span\");\n                            span.textContent = \"Hi\";\n                            span.style.fontFamily = name;\n                            div.append(span);\n                        }\n                        this._document.body.append(div);\n                        isFontReady(loadTestFontId, ()=>{\n                            div.remove();\n                            request.complete();\n                        });\n                    }\n                }\n                exports1.FontLoader = FontLoader;\n                class FontFaceObject {\n                    constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, inspectFont = null }){\n                        this.compiledGlyphs = Object.create(null);\n                        for(const i in translatedData){\n                            this[i] = translatedData[i];\n                        }\n                        this.isEvalSupported = isEvalSupported !== false;\n                        this.disableFontFace = disableFontFace === true;\n                        this.ignoreErrors = ignoreErrors === true;\n                        this._inspectFont = inspectFont;\n                    }\n                    createNativeFontFace() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        let nativeFontFace;\n                        if (!this.cssFontInfo) {\n                            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n                        } else {\n                            const css = {\n                                weight: this.cssFontInfo.fontWeight\n                            };\n                            if (this.cssFontInfo.italicAngle) {\n                                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n                            }\n                            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n                        }\n                        this._inspectFont?.(this);\n                        return nativeFontFace;\n                    }\n                    createFontFaceRule() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        const data = (0, _util.bytesToString)(this.data);\n                        const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n                        let rule;\n                        if (!this.cssFontInfo) {\n                            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n                        } else {\n                            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n                            if (this.cssFontInfo.italicAngle) {\n                                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n                            }\n                            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n                        }\n                        this._inspectFont?.(this, url);\n                        return rule;\n                    }\n                    getPathGenerator(objs, character) {\n                        if (this.compiledGlyphs[character] !== undefined) {\n                            return this.compiledGlyphs[character];\n                        }\n                        let cmds;\n                        try {\n                            cmds = objs.get(this.loadedName + \"_path_\" + character);\n                        } catch (ex) {\n                            if (!this.ignoreErrors) {\n                                throw ex;\n                            }\n                            (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n                            return this.compiledGlyphs[character] = function(c, size) {};\n                        }\n                        if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n                            const jsBuf = [];\n                            for (const current of cmds){\n                                const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n                                jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n                            }\n                            return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n                        }\n                        return this.compiledGlyphs[character] = function(c, size) {\n                            for (const current of cmds){\n                                if (current.cmd === \"scale\") {\n                                    current.args = [\n                                        size,\n                                        -size\n                                    ];\n                                }\n                                c[current.cmd].apply(c, current.args);\n                            }\n                        };\n                    }\n                }\n                exports1.FontFaceObject = FontFaceObject;\n            /***/ },\n            /* 10 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NodeStandardFontDataFactory = exports1.NodeFilterFactory = exports1.NodeCanvasFactory = exports1.NodeCMapReaderFactory = void 0;\n                var _base_factory = __w_pdfjs_require__(7);\n                var _util = __w_pdfjs_require__(1);\n                ;\n                ;\n                const fetchData = function(url) {\n                    return new Promise((resolve, reject)=>{\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        fs.readFile(url, (error, data)=>{\n                            if (error || !data) {\n                                reject(new Error(error));\n                                return;\n                            }\n                            resolve(new Uint8Array(data));\n                        });\n                    });\n                };\n                class NodeFilterFactory extends _base_factory.BaseFilterFactory {\n                }\n                exports1.NodeFilterFactory = NodeFilterFactory;\n                class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n                    _createCanvas(width, height) {\n                        const Canvas = __webpack_require__(/*! canvas */ \"?f848\");\n                        return Canvas.createCanvas(width, height);\n                    }\n                }\n                exports1.NodeCanvasFactory = NodeCanvasFactory;\n                class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n                    _fetchData(url, compressionType) {\n                        return fetchData(url).then((data)=>{\n                            return {\n                                cMapData: data,\n                                compressionType\n                            };\n                        });\n                    }\n                }\n                exports1.NodeCMapReaderFactory = NodeCMapReaderFactory;\n                class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n                    _fetchData(url) {\n                        return fetchData(url);\n                    }\n                }\n                exports1.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n            /***/ },\n            /* 11 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.CanvasGraphics = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _pattern_helper = __w_pdfjs_require__(12);\n                var _image_utils = __w_pdfjs_require__(13);\n                const MIN_FONT_SIZE = 16;\n                const MAX_FONT_SIZE = 100;\n                const MAX_GROUP_SIZE = 4096;\n                const EXECUTION_TIME = 15;\n                const EXECUTION_STEPS = 10;\n                const MAX_SIZE_TO_COMPILE = 1000;\n                const FULL_CHUNK_HEIGHT = 16;\n                function mirrorContextOperations(ctx, destCtx) {\n                    if (ctx._removeMirroring) {\n                        throw new Error(\"Context is already forwarding operations.\");\n                    }\n                    ctx.__originalSave = ctx.save;\n                    ctx.__originalRestore = ctx.restore;\n                    ctx.__originalRotate = ctx.rotate;\n                    ctx.__originalScale = ctx.scale;\n                    ctx.__originalTranslate = ctx.translate;\n                    ctx.__originalTransform = ctx.transform;\n                    ctx.__originalSetTransform = ctx.setTransform;\n                    ctx.__originalResetTransform = ctx.resetTransform;\n                    ctx.__originalClip = ctx.clip;\n                    ctx.__originalMoveTo = ctx.moveTo;\n                    ctx.__originalLineTo = ctx.lineTo;\n                    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n                    ctx.__originalRect = ctx.rect;\n                    ctx.__originalClosePath = ctx.closePath;\n                    ctx.__originalBeginPath = ctx.beginPath;\n                    ctx._removeMirroring = ()=>{\n                        ctx.save = ctx.__originalSave;\n                        ctx.restore = ctx.__originalRestore;\n                        ctx.rotate = ctx.__originalRotate;\n                        ctx.scale = ctx.__originalScale;\n                        ctx.translate = ctx.__originalTranslate;\n                        ctx.transform = ctx.__originalTransform;\n                        ctx.setTransform = ctx.__originalSetTransform;\n                        ctx.resetTransform = ctx.__originalResetTransform;\n                        ctx.clip = ctx.__originalClip;\n                        ctx.moveTo = ctx.__originalMoveTo;\n                        ctx.lineTo = ctx.__originalLineTo;\n                        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n                        ctx.rect = ctx.__originalRect;\n                        ctx.closePath = ctx.__originalClosePath;\n                        ctx.beginPath = ctx.__originalBeginPath;\n                        delete ctx._removeMirroring;\n                    };\n                    ctx.save = function ctxSave() {\n                        destCtx.save();\n                        this.__originalSave();\n                    };\n                    ctx.restore = function ctxRestore() {\n                        destCtx.restore();\n                        this.__originalRestore();\n                    };\n                    ctx.translate = function ctxTranslate(x, y) {\n                        destCtx.translate(x, y);\n                        this.__originalTranslate(x, y);\n                    };\n                    ctx.scale = function ctxScale(x, y) {\n                        destCtx.scale(x, y);\n                        this.__originalScale(x, y);\n                    };\n                    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n                        destCtx.transform(a, b, c, d, e, f);\n                        this.__originalTransform(a, b, c, d, e, f);\n                    };\n                    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n                        destCtx.setTransform(a, b, c, d, e, f);\n                        this.__originalSetTransform(a, b, c, d, e, f);\n                    };\n                    ctx.resetTransform = function ctxResetTransform() {\n                        destCtx.resetTransform();\n                        this.__originalResetTransform();\n                    };\n                    ctx.rotate = function ctxRotate(angle) {\n                        destCtx.rotate(angle);\n                        this.__originalRotate(angle);\n                    };\n                    ctx.clip = function ctxRotate(rule) {\n                        destCtx.clip(rule);\n                        this.__originalClip(rule);\n                    };\n                    ctx.moveTo = function(x, y) {\n                        destCtx.moveTo(x, y);\n                        this.__originalMoveTo(x, y);\n                    };\n                    ctx.lineTo = function(x, y) {\n                        destCtx.lineTo(x, y);\n                        this.__originalLineTo(x, y);\n                    };\n                    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n                        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n                    };\n                    ctx.rect = function(x, y, width, height) {\n                        destCtx.rect(x, y, width, height);\n                        this.__originalRect(x, y, width, height);\n                    };\n                    ctx.closePath = function() {\n                        destCtx.closePath();\n                        this.__originalClosePath();\n                    };\n                    ctx.beginPath = function() {\n                        destCtx.beginPath();\n                        this.__originalBeginPath();\n                    };\n                }\n                class CachedCanvases {\n                    constructor(canvasFactory){\n                        this.canvasFactory = canvasFactory;\n                        this.cache = Object.create(null);\n                    }\n                    getCanvas(id, width, height) {\n                        let canvasEntry;\n                        if (this.cache[id] !== undefined) {\n                            canvasEntry = this.cache[id];\n                            this.canvasFactory.reset(canvasEntry, width, height);\n                        } else {\n                            canvasEntry = this.canvasFactory.create(width, height);\n                            this.cache[id] = canvasEntry;\n                        }\n                        return canvasEntry;\n                    }\n                    delete(id) {\n                        delete this.cache[id];\n                    }\n                    clear() {\n                        for(const id in this.cache){\n                            const canvasEntry = this.cache[id];\n                            this.canvasFactory.destroy(canvasEntry);\n                            delete this.cache[id];\n                        }\n                    }\n                }\n                function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n                    const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n                    if (b === 0 && c === 0) {\n                        const tlX = destX * a + tx;\n                        const rTlX = Math.round(tlX);\n                        const tlY = destY * d + ty;\n                        const rTlY = Math.round(tlY);\n                        const brX = (destX + destW) * a + tx;\n                        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                        const brY = (destY + destH) * d + ty;\n                        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n                        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n                        ctx.setTransform(a, b, c, d, tx, ty);\n                        return [\n                            rWidth,\n                            rHeight\n                        ];\n                    }\n                    if (a === 0 && d === 0) {\n                        const tlX = destY * c + tx;\n                        const rTlX = Math.round(tlX);\n                        const tlY = destX * b + ty;\n                        const rTlY = Math.round(tlY);\n                        const brX = (destY + destH) * c + tx;\n                        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n                        const brY = (destX + destW) * b + ty;\n                        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n                        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n                        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n                        ctx.setTransform(a, b, c, d, tx, ty);\n                        return [\n                            rHeight,\n                            rWidth\n                        ];\n                    }\n                    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n                    const scaleX = Math.hypot(a, b);\n                    const scaleY = Math.hypot(c, d);\n                    return [\n                        scaleX * destW,\n                        scaleY * destH\n                    ];\n                }\n                function compileType3Glyph(imgData) {\n                    const { width, height } = imgData;\n                    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n                        return null;\n                    }\n                    const POINT_TO_PROCESS_LIMIT = 1000;\n                    const POINT_TYPES = new Uint8Array([\n                        0,\n                        2,\n                        4,\n                        0,\n                        1,\n                        0,\n                        5,\n                        4,\n                        8,\n                        10,\n                        0,\n                        8,\n                        0,\n                        2,\n                        1,\n                        0\n                    ]);\n                    const width1 = width + 1;\n                    let points = new Uint8Array(width1 * (height + 1));\n                    let i, j, j0;\n                    const lineSize = width + 7 & ~7;\n                    let data = new Uint8Array(lineSize * height), pos = 0;\n                    for (const elem of imgData.data){\n                        let mask = 128;\n                        while(mask > 0){\n                            data[pos++] = elem & mask ? 0 : 255;\n                            mask >>= 1;\n                        }\n                    }\n                    let count = 0;\n                    pos = 0;\n                    if (data[pos] !== 0) {\n                        points[0] = 1;\n                        ++count;\n                    }\n                    for(j = 1; j < width; j++){\n                        if (data[pos] !== data[pos + 1]) {\n                            points[j] = data[pos] ? 2 : 1;\n                            ++count;\n                        }\n                        pos++;\n                    }\n                    if (data[pos] !== 0) {\n                        points[j] = 2;\n                        ++count;\n                    }\n                    for(i = 1; i < height; i++){\n                        pos = i * lineSize;\n                        j0 = i * width1;\n                        if (data[pos - lineSize] !== data[pos]) {\n                            points[j0] = data[pos] ? 1 : 8;\n                            ++count;\n                        }\n                        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n                        for(j = 1; j < width; j++){\n                            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n                            if (POINT_TYPES[sum]) {\n                                points[j0 + j] = POINT_TYPES[sum];\n                                ++count;\n                            }\n                            pos++;\n                        }\n                        if (data[pos - lineSize] !== data[pos]) {\n                            points[j0 + j] = data[pos] ? 2 : 4;\n                            ++count;\n                        }\n                        if (count > POINT_TO_PROCESS_LIMIT) {\n                            return null;\n                        }\n                    }\n                    pos = lineSize * (height - 1);\n                    j0 = i * width1;\n                    if (data[pos] !== 0) {\n                        points[j0] = 8;\n                        ++count;\n                    }\n                    for(j = 1; j < width; j++){\n                        if (data[pos] !== data[pos + 1]) {\n                            points[j0 + j] = data[pos] ? 4 : 8;\n                            ++count;\n                        }\n                        pos++;\n                    }\n                    if (data[pos] !== 0) {\n                        points[j0 + j] = 4;\n                        ++count;\n                    }\n                    if (count > POINT_TO_PROCESS_LIMIT) {\n                        return null;\n                    }\n                    const steps = new Int32Array([\n                        0,\n                        width1,\n                        -1,\n                        0,\n                        -width1,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]);\n                    const path = new Path2D();\n                    for(i = 0; count && i <= height; i++){\n                        let p = i * width1;\n                        const end = p + width;\n                        while(p < end && !points[p]){\n                            p++;\n                        }\n                        if (p === end) {\n                            continue;\n                        }\n                        path.moveTo(p % width1, i);\n                        const p0 = p;\n                        let type = points[p];\n                        do {\n                            const step = steps[type];\n                            do {\n                                p += step;\n                            }while (!points[p]);\n                            const pp = points[p];\n                            if (pp !== 5 && pp !== 10) {\n                                type = pp;\n                                points[p] = 0;\n                            } else {\n                                type = pp & 0x33 * type >> 4;\n                                points[p] &= type >> 2 | type << 2;\n                            }\n                            path.lineTo(p % width1, p / width1 | 0);\n                            if (!points[p]) {\n                                --count;\n                            }\n                        }while (p0 !== p);\n                        --i;\n                    }\n                    data = null;\n                    points = null;\n                    const drawOutline = function(c) {\n                        c.save();\n                        c.scale(1 / width, -1 / height);\n                        c.translate(0, -height);\n                        c.fill(path);\n                        c.beginPath();\n                        c.restore();\n                    };\n                    return drawOutline;\n                }\n                class CanvasExtraState {\n                    constructor(width, height){\n                        this.alphaIsShape = false;\n                        this.fontSize = 0;\n                        this.fontSizeScale = 1;\n                        this.textMatrix = _util.IDENTITY_MATRIX;\n                        this.textMatrixScale = 1;\n                        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRenderingMode = _util.TextRenderingMode.FILL;\n                        this.textRise = 0;\n                        this.fillColor = \"#000000\";\n                        this.strokeColor = \"#000000\";\n                        this.patternFill = false;\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.activeSMask = null;\n                        this.transferMaps = \"none\";\n                        this.startNewPathAndClipBox([\n                            0,\n                            0,\n                            width,\n                            height\n                        ]);\n                    }\n                    clone() {\n                        const clone = Object.create(this);\n                        clone.clipBox = this.clipBox.slice();\n                        return clone;\n                    }\n                    setCurrentPoint(x, y) {\n                        this.x = x;\n                        this.y = y;\n                    }\n                    updatePathMinMax(transform, x, y) {\n                        [x, y] = _util.Util.applyTransform([\n                            x,\n                            y\n                        ], transform);\n                        this.minX = Math.min(this.minX, x);\n                        this.minY = Math.min(this.minY, y);\n                        this.maxX = Math.max(this.maxX, x);\n                        this.maxY = Math.max(this.maxY, y);\n                    }\n                    updateRectMinMax(transform, rect) {\n                        const p1 = _util.Util.applyTransform(rect, transform);\n                        const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n                        this.minX = Math.min(this.minX, p1[0], p2[0]);\n                        this.minY = Math.min(this.minY, p1[1], p2[1]);\n                        this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n                        this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n                    }\n                    updateScalingPathMinMax(transform, minMax) {\n                        _util.Util.scaleMinMax(transform, minMax);\n                        this.minX = Math.min(this.minX, minMax[0]);\n                        this.maxX = Math.max(this.maxX, minMax[1]);\n                        this.minY = Math.min(this.minY, minMax[2]);\n                        this.maxY = Math.max(this.maxY, minMax[3]);\n                    }\n                    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n                        const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n                        if (minMax) {\n                            minMax[0] = Math.min(minMax[0], box[0], box[2]);\n                            minMax[1] = Math.max(minMax[1], box[0], box[2]);\n                            minMax[2] = Math.min(minMax[2], box[1], box[3]);\n                            minMax[3] = Math.max(minMax[3], box[1], box[3]);\n                            return;\n                        }\n                        this.updateRectMinMax(transform, box);\n                    }\n                    getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n                        const box = [\n                            this.minX,\n                            this.minY,\n                            this.maxX,\n                            this.maxY\n                        ];\n                        if (pathType === _pattern_helper.PathType.STROKE) {\n                            if (!transform) {\n                                (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n                            }\n                            const scale = _util.Util.singularValueDecompose2dScale(transform);\n                            const xStrokePad = scale[0] * this.lineWidth / 2;\n                            const yStrokePad = scale[1] * this.lineWidth / 2;\n                            box[0] -= xStrokePad;\n                            box[1] -= yStrokePad;\n                            box[2] += xStrokePad;\n                            box[3] += yStrokePad;\n                        }\n                        return box;\n                    }\n                    updateClipFromPath() {\n                        const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n                        this.startNewPathAndClipBox(intersect || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                    }\n                    isEmptyClip() {\n                        return this.minX === Infinity;\n                    }\n                    startNewPathAndClipBox(box) {\n                        this.clipBox = box;\n                        this.minX = Infinity;\n                        this.minY = Infinity;\n                        this.maxX = 0;\n                        this.maxY = 0;\n                    }\n                    getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n                        return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n                    }\n                }\n                function putBinaryImageData(ctx, imgData) {\n                    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n                        ctx.putImageData(imgData, 0, 0);\n                        return;\n                    }\n                    const height = imgData.height, width = imgData.width;\n                    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n                    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n                    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n                    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n                    let srcPos = 0, destPos;\n                    const src = imgData.data;\n                    const dest = chunkImgData.data;\n                    let i, j, thisChunkHeight, elemsInThisChunk;\n                    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n                        const srcLength = src.byteLength;\n                        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n                        const dest32DataLength = dest32.length;\n                        const fullSrcDiff = width + 7 >> 3;\n                        const white = 0xffffffff;\n                        const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                        for(i = 0; i < totalChunks; i++){\n                            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                            destPos = 0;\n                            for(j = 0; j < thisChunkHeight; j++){\n                                const srcDiff = srcLength - srcPos;\n                                let k = 0;\n                                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                                const kEndUnrolled = kEnd & ~7;\n                                let mask = 0;\n                                let srcByte = 0;\n                                for(; k < kEndUnrolled; k += 8){\n                                    srcByte = src[srcPos++];\n                                    dest32[destPos++] = srcByte & 128 ? white : black;\n                                    dest32[destPos++] = srcByte & 64 ? white : black;\n                                    dest32[destPos++] = srcByte & 32 ? white : black;\n                                    dest32[destPos++] = srcByte & 16 ? white : black;\n                                    dest32[destPos++] = srcByte & 8 ? white : black;\n                                    dest32[destPos++] = srcByte & 4 ? white : black;\n                                    dest32[destPos++] = srcByte & 2 ? white : black;\n                                    dest32[destPos++] = srcByte & 1 ? white : black;\n                                }\n                                for(; k < kEnd; k++){\n                                    if (mask === 0) {\n                                        srcByte = src[srcPos++];\n                                        mask = 128;\n                                    }\n                                    dest32[destPos++] = srcByte & mask ? white : black;\n                                    mask >>= 1;\n                                }\n                            }\n                            while(destPos < dest32DataLength){\n                                dest32[destPos++] = 0;\n                            }\n                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                        }\n                    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n                        j = 0;\n                        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n                        for(i = 0; i < fullChunks; i++){\n                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                            srcPos += elemsInThisChunk;\n                            ctx.putImageData(chunkImgData, 0, j);\n                            j += FULL_CHUNK_HEIGHT;\n                        }\n                        if (i < totalChunks) {\n                            elemsInThisChunk = width * partialChunkHeight * 4;\n                            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n                            ctx.putImageData(chunkImgData, 0, j);\n                        }\n                    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n                        thisChunkHeight = FULL_CHUNK_HEIGHT;\n                        elemsInThisChunk = width * thisChunkHeight;\n                        for(i = 0; i < totalChunks; i++){\n                            if (i >= fullChunks) {\n                                thisChunkHeight = partialChunkHeight;\n                                elemsInThisChunk = width * thisChunkHeight;\n                            }\n                            destPos = 0;\n                            for(j = elemsInThisChunk; j--;){\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = src[srcPos++];\n                                dest[destPos++] = 255;\n                            }\n                            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                        }\n                    } else {\n                        throw new Error(`bad image kind: ${imgData.kind}`);\n                    }\n                }\n                function putBinaryImageMask(ctx, imgData) {\n                    if (imgData.bitmap) {\n                        ctx.drawImage(imgData.bitmap, 0, 0);\n                        return;\n                    }\n                    const height = imgData.height, width = imgData.width;\n                    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n                    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n                    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n                    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n                    let srcPos = 0;\n                    const src = imgData.data;\n                    const dest = chunkImgData.data;\n                    for(let i = 0; i < totalChunks; i++){\n                        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n                        ({ srcPos } = (0, _image_utils.convertBlackAndWhiteToRGBA)({\n                            src,\n                            srcPos,\n                            dest,\n                            width,\n                            height: thisChunkHeight,\n                            nonBlackColor: 0\n                        }));\n                        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n                    }\n                }\n                function copyCtxState(sourceCtx, destCtx) {\n                    const properties = [\n                        \"strokeStyle\",\n                        \"fillStyle\",\n                        \"fillRule\",\n                        \"globalAlpha\",\n                        \"lineWidth\",\n                        \"lineCap\",\n                        \"lineJoin\",\n                        \"miterLimit\",\n                        \"globalCompositeOperation\",\n                        \"font\",\n                        \"filter\"\n                    ];\n                    for (const property of properties){\n                        if (sourceCtx[property] !== undefined) {\n                            destCtx[property] = sourceCtx[property];\n                        }\n                    }\n                    if (sourceCtx.setLineDash !== undefined) {\n                        destCtx.setLineDash(sourceCtx.getLineDash());\n                        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n                    }\n                }\n                function resetCtxToDefault(ctx) {\n                    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n                    ctx.fillRule = \"nonzero\";\n                    ctx.globalAlpha = 1;\n                    ctx.lineWidth = 1;\n                    ctx.lineCap = \"butt\";\n                    ctx.lineJoin = \"miter\";\n                    ctx.miterLimit = 10;\n                    ctx.globalCompositeOperation = \"source-over\";\n                    ctx.font = \"10px sans-serif\";\n                    if (ctx.setLineDash !== undefined) {\n                        ctx.setLineDash([]);\n                        ctx.lineDashOffset = 0;\n                    }\n                    if (!_util.isNodeJS) {\n                        const { filter } = ctx;\n                        if (filter !== \"none\" && filter !== \"\") {\n                            ctx.filter = \"none\";\n                        }\n                    }\n                }\n                function composeSMaskBackdrop(bytes, r0, g0, b0) {\n                    const length = bytes.length;\n                    for(let i = 3; i < length; i += 4){\n                        const alpha = bytes[i];\n                        if (alpha === 0) {\n                            bytes[i - 3] = r0;\n                            bytes[i - 2] = g0;\n                            bytes[i - 1] = b0;\n                        } else if (alpha < 255) {\n                            const alpha_ = 255 - alpha;\n                            bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n                            bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n                            bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n                        }\n                    }\n                }\n                function composeSMaskAlpha(maskData, layerData, transferMap) {\n                    const length = maskData.length;\n                    const scale = 1 / 255;\n                    for(let i = 3; i < length; i += 4){\n                        const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n                        layerData[i] = layerData[i] * alpha * scale | 0;\n                    }\n                }\n                function composeSMaskLuminosity(maskData, layerData, transferMap) {\n                    const length = maskData.length;\n                    for(let i = 3; i < length; i += 4){\n                        const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n                        layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n                    }\n                }\n                function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n                    const hasBackdrop = !!backdrop;\n                    const r0 = hasBackdrop ? backdrop[0] : 0;\n                    const g0 = hasBackdrop ? backdrop[1] : 0;\n                    const b0 = hasBackdrop ? backdrop[2] : 0;\n                    const composeFn = subtype === \"Luminosity\" ? composeSMaskLuminosity : composeSMaskAlpha;\n                    const PIXELS_TO_PROCESS = 1048576;\n                    const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n                    for(let row = 0; row < height; row += chunkSize){\n                        const chunkHeight = Math.min(chunkSize, height - row);\n                        const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n                        const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n                        if (hasBackdrop) {\n                            composeSMaskBackdrop(maskData.data, r0, g0, b0);\n                        }\n                        composeFn(maskData.data, layerData.data, transferMap);\n                        layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n                    }\n                }\n                function composeSMask(ctx, smask, layerCtx, layerBox) {\n                    const layerOffsetX = layerBox[0];\n                    const layerOffsetY = layerBox[1];\n                    const layerWidth = layerBox[2] - layerOffsetX;\n                    const layerHeight = layerBox[3] - layerOffsetY;\n                    if (layerWidth === 0 || layerHeight === 0) {\n                        return;\n                    }\n                    genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n                    ctx.save();\n                    ctx.globalAlpha = 1;\n                    ctx.globalCompositeOperation = \"source-over\";\n                    ctx.setTransform(1, 0, 0, 1, 0, 0);\n                    ctx.drawImage(layerCtx.canvas, 0, 0);\n                    ctx.restore();\n                }\n                function getImageSmoothingEnabled(transform, interpolate) {\n                    const scale = _util.Util.singularValueDecompose2dScale(transform);\n                    scale[0] = Math.fround(scale[0]);\n                    scale[1] = Math.fround(scale[1]);\n                    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                    if (interpolate !== undefined) {\n                        return interpolate;\n                    } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n                        return true;\n                    }\n                    return false;\n                }\n                const LINE_CAP_STYLES = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const NORMAL_CLIP = {};\n                const EO_CLIP = {};\n                class CanvasGraphics {\n                    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n                        this.ctx = canvasCtx;\n                        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.stateStack = [];\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.res = null;\n                        this.xobjs = null;\n                        this.commonObjs = commonObjs;\n                        this.objs = objs;\n                        this.canvasFactory = canvasFactory;\n                        this.filterFactory = filterFactory;\n                        this.groupStack = [];\n                        this.processingType3 = null;\n                        this.baseTransform = null;\n                        this.baseTransformStack = [];\n                        this.groupLevel = 0;\n                        this.smaskStack = [];\n                        this.smaskCounter = 0;\n                        this.tempSMask = null;\n                        this.suspendedCtx = null;\n                        this.contentVisible = true;\n                        this.markedContentStack = markedContentStack || [];\n                        this.optionalContentConfig = optionalContentConfig;\n                        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n                        this.cachedPatterns = new Map();\n                        this.annotationCanvasMap = annotationCanvasMap;\n                        this.viewportScale = 1;\n                        this.outputScaleX = 1;\n                        this.outputScaleY = 1;\n                        this.pageColors = pageColors;\n                        this._cachedScaleForStroking = [\n                            -1,\n                            0\n                        ];\n                        this._cachedGetSinglePixelWidth = null;\n                        this._cachedBitmapsMap = new Map();\n                    }\n                    getObject(data, fallback = null) {\n                        if (typeof data === \"string\") {\n                            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                        }\n                        return fallback;\n                    }\n                    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n                        const width = this.ctx.canvas.width;\n                        const height = this.ctx.canvas.height;\n                        const savedFillStyle = this.ctx.fillStyle;\n                        this.ctx.fillStyle = background || \"#ffffff\";\n                        this.ctx.fillRect(0, 0, width, height);\n                        this.ctx.fillStyle = savedFillStyle;\n                        if (transparency) {\n                            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n                            this.compositeCtx = this.ctx;\n                            this.transparentCanvas = transparentCanvas.canvas;\n                            this.ctx = transparentCanvas.context;\n                            this.ctx.save();\n                            this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n                        }\n                        this.ctx.save();\n                        resetCtxToDefault(this.ctx);\n                        if (transform) {\n                            this.ctx.transform(...transform);\n                            this.outputScaleX = transform[0];\n                            this.outputScaleY = transform[0];\n                        }\n                        this.ctx.transform(...viewport.transform);\n                        this.viewportScale = viewport.scale;\n                        this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n                    }\n                    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n                        const argsArray = operatorList.argsArray;\n                        const fnArray = operatorList.fnArray;\n                        let i = executionStartIdx || 0;\n                        const argsArrayLen = argsArray.length;\n                        if (argsArrayLen === i) {\n                            return i;\n                        }\n                        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n                        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n                        let steps = 0;\n                        const commonObjs = this.commonObjs;\n                        const objs = this.objs;\n                        let fnId;\n                        while(true){\n                            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                                stepper.breakIt(i, continueCallback);\n                                return i;\n                            }\n                            fnId = fnArray[i];\n                            if (fnId !== _util.OPS.dependency) {\n                                this[fnId].apply(this, argsArray[i]);\n                            } else {\n                                for (const depObjId of argsArray[i]){\n                                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                                    if (!objsPool.has(depObjId)) {\n                                        objsPool.get(depObjId, continueCallback);\n                                        return i;\n                                    }\n                                }\n                            }\n                            i++;\n                            if (i === argsArrayLen) {\n                                return i;\n                            }\n                            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                                if (Date.now() > endTime) {\n                                    continueCallback();\n                                    return i;\n                                }\n                                steps = 0;\n                            }\n                        }\n                    }\n                    #restoreInitialState() {\n                        while(this.stateStack.length || this.inSMaskMode){\n                            this.restore();\n                        }\n                        this.ctx.restore();\n                        if (this.transparentCanvas) {\n                            this.ctx = this.compositeCtx;\n                            this.ctx.save();\n                            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n                            this.ctx.restore();\n                            this.transparentCanvas = null;\n                        }\n                    }\n                    endDrawing() {\n                        this.#restoreInitialState();\n                        this.cachedCanvases.clear();\n                        this.cachedPatterns.clear();\n                        for (const cache of this._cachedBitmapsMap.values()){\n                            for (const canvas of cache.values()){\n                                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                                    canvas.width = canvas.height = 0;\n                                }\n                            }\n                            cache.clear();\n                        }\n                        this._cachedBitmapsMap.clear();\n                        this.#drawFilter();\n                    }\n                    #drawFilter() {\n                        if (this.pageColors) {\n                            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n                            if (hcmFilterId !== \"none\") {\n                                const savedFilter = this.ctx.filter;\n                                this.ctx.filter = hcmFilterId;\n                                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                                this.ctx.filter = savedFilter;\n                            }\n                        }\n                    }\n                    _scaleImage(img, inverseTransform) {\n                        const width = img.width;\n                        const height = img.height;\n                        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n                        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n                        let paintWidth = width, paintHeight = height;\n                        let tmpCanvasId = \"prescale1\";\n                        let tmpCanvas, tmpCtx;\n                        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n                            let newWidth = paintWidth, newHeight = paintHeight;\n                            if (widthScale > 2 && paintWidth > 1) {\n                                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                                widthScale /= paintWidth / newWidth;\n                            }\n                            if (heightScale > 2 && paintHeight > 1) {\n                                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                                heightScale /= paintHeight / newHeight;\n                            }\n                            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n                            tmpCtx = tmpCanvas.context;\n                            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n                            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n                            img = tmpCanvas.canvas;\n                            paintWidth = newWidth;\n                            paintHeight = newHeight;\n                            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n                        }\n                        return {\n                            img,\n                            paintWidth,\n                            paintHeight\n                        };\n                    }\n                    _createMaskCanvas(img) {\n                        const ctx = this.ctx;\n                        const { width, height } = img;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        let cache, cacheKey, scaled, maskCanvas;\n                        if ((img.bitmap || img.data) && img.count > 1) {\n                            const mainKey = img.bitmap || img.data.buffer;\n                            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                                currentTransform.slice(0, 4),\n                                fillColor\n                            ]);\n                            cache = this._cachedBitmapsMap.get(mainKey);\n                            if (!cache) {\n                                cache = new Map();\n                                this._cachedBitmapsMap.set(mainKey, cache);\n                            }\n                            const cachedImage = cache.get(cacheKey);\n                            if (cachedImage && !isPatternFill) {\n                                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                                return {\n                                    canvas: cachedImage,\n                                    offsetX,\n                                    offsetY\n                                };\n                            }\n                            scaled = cachedImage;\n                        }\n                        if (!scaled) {\n                            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                            putBinaryImageMask(maskCanvas.context, img);\n                        }\n                        let maskToCanvas = _util.Util.transform(currentTransform, [\n                            1 / width,\n                            0,\n                            0,\n                            -1 / height,\n                            0,\n                            0\n                        ]);\n                        maskToCanvas = _util.Util.transform(maskToCanvas, [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -height\n                        ]);\n                        const cord1 = _util.Util.applyTransform([\n                            0,\n                            0\n                        ], maskToCanvas);\n                        const cord2 = _util.Util.applyTransform([\n                            width,\n                            height\n                        ], maskToCanvas);\n                        const rect = _util.Util.normalizeRect([\n                            cord1[0],\n                            cord1[1],\n                            cord2[0],\n                            cord2[1]\n                        ]);\n                        const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n                        const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n                        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n                        const fillCtx = fillCanvas.context;\n                        const offsetX = Math.min(cord1[0], cord2[0]);\n                        const offsetY = Math.min(cord1[1], cord2[1]);\n                        fillCtx.translate(-offsetX, -offsetY);\n                        fillCtx.transform(...maskToCanvas);\n                        if (!scaled) {\n                            scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n                            scaled = scaled.img;\n                            if (cache && isPatternFill) {\n                                cache.set(cacheKey, scaled);\n                            }\n                        }\n                        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n                        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n                        fillCtx.globalCompositeOperation = \"source-in\";\n                        const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [\n                            1,\n                            0,\n                            0,\n                            1,\n                            -offsetX,\n                            -offsetY\n                        ]);\n                        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n                        fillCtx.fillRect(0, 0, width, height);\n                        if (cache && !isPatternFill) {\n                            this.cachedCanvases.delete(\"fillCanvas\");\n                            cache.set(cacheKey, fillCanvas.canvas);\n                        }\n                        return {\n                            canvas: fillCanvas.canvas,\n                            offsetX: Math.round(offsetX),\n                            offsetY: Math.round(offsetY)\n                        };\n                    }\n                    setLineWidth(width) {\n                        if (width !== this.current.lineWidth) {\n                            this._cachedScaleForStroking[0] = -1;\n                        }\n                        this.current.lineWidth = width;\n                        this.ctx.lineWidth = width;\n                    }\n                    setLineCap(style) {\n                        this.ctx.lineCap = LINE_CAP_STYLES[style];\n                    }\n                    setLineJoin(style) {\n                        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n                    }\n                    setMiterLimit(limit) {\n                        this.ctx.miterLimit = limit;\n                    }\n                    setDash(dashArray, dashPhase) {\n                        const ctx = this.ctx;\n                        if (ctx.setLineDash !== undefined) {\n                            ctx.setLineDash(dashArray);\n                            ctx.lineDashOffset = dashPhase;\n                        }\n                    }\n                    setRenderingIntent(intent) {}\n                    setFlatness(flatness) {}\n                    setGState(states) {\n                        for (const [key, value] of states){\n                            switch(key){\n                                case \"LW\":\n                                    this.setLineWidth(value);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value[0], value[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value[0], value[1]);\n                                    break;\n                                case \"CA\":\n                                    this.current.strokeAlpha = value;\n                                    break;\n                                case \"ca\":\n                                    this.current.fillAlpha = value;\n                                    this.ctx.globalAlpha = value;\n                                    break;\n                                case \"BM\":\n                                    this.ctx.globalCompositeOperation = value;\n                                    break;\n                                case \"SMask\":\n                                    this.current.activeSMask = value ? this.tempSMask : null;\n                                    this.tempSMask = null;\n                                    this.checkSMaskState();\n                                    break;\n                                case \"TR\":\n                                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                                    break;\n                            }\n                        }\n                    }\n                    get inSMaskMode() {\n                        return !!this.suspendedCtx;\n                    }\n                    checkSMaskState() {\n                        const inSMaskMode = this.inSMaskMode;\n                        if (this.current.activeSMask && !inSMaskMode) {\n                            this.beginSMaskMode();\n                        } else if (!this.current.activeSMask && inSMaskMode) {\n                            this.endSMaskMode();\n                        }\n                    }\n                    beginSMaskMode() {\n                        if (this.inSMaskMode) {\n                            throw new Error(\"beginSMaskMode called while already in smask mode\");\n                        }\n                        const drawnWidth = this.ctx.canvas.width;\n                        const drawnHeight = this.ctx.canvas.height;\n                        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n                        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                        this.suspendedCtx = this.ctx;\n                        this.ctx = scratchCanvas.context;\n                        const ctx = this.ctx;\n                        ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n                        copyCtxState(this.suspendedCtx, ctx);\n                        mirrorContextOperations(ctx, this.suspendedCtx);\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                    }\n                    endSMaskMode() {\n                        if (!this.inSMaskMode) {\n                            throw new Error(\"endSMaskMode called while not in smask mode\");\n                        }\n                        this.ctx._removeMirroring();\n                        copyCtxState(this.ctx, this.suspendedCtx);\n                        this.ctx = this.suspendedCtx;\n                        this.suspendedCtx = null;\n                    }\n                    compose(dirtyBox) {\n                        if (!this.current.activeSMask) {\n                            return;\n                        }\n                        if (!dirtyBox) {\n                            dirtyBox = [\n                                0,\n                                0,\n                                this.ctx.canvas.width,\n                                this.ctx.canvas.height\n                            ];\n                        } else {\n                            dirtyBox[0] = Math.floor(dirtyBox[0]);\n                            dirtyBox[1] = Math.floor(dirtyBox[1]);\n                            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n                            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n                        }\n                        const smask = this.current.activeSMask;\n                        const suspendedCtx = this.suspendedCtx;\n                        composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n                        this.ctx.save();\n                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.ctx.restore();\n                    }\n                    save() {\n                        if (this.inSMaskMode) {\n                            copyCtxState(this.ctx, this.suspendedCtx);\n                            this.suspendedCtx.save();\n                        } else {\n                            this.ctx.save();\n                        }\n                        const old = this.current;\n                        this.stateStack.push(old);\n                        this.current = old.clone();\n                    }\n                    restore() {\n                        if (this.stateStack.length === 0 && this.inSMaskMode) {\n                            this.endSMaskMode();\n                        }\n                        if (this.stateStack.length !== 0) {\n                            this.current = this.stateStack.pop();\n                            if (this.inSMaskMode) {\n                                this.suspendedCtx.restore();\n                                copyCtxState(this.suspendedCtx, this.ctx);\n                            } else {\n                                this.ctx.restore();\n                            }\n                            this.checkSMaskState();\n                            this.pendingClip = null;\n                            this._cachedScaleForStroking[0] = -1;\n                            this._cachedGetSinglePixelWidth = null;\n                        }\n                    }\n                    transform(a, b, c, d, e, f) {\n                        this.ctx.transform(a, b, c, d, e, f);\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                    }\n                    constructPath(ops, args, minMax) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        let x = current.x, y = current.y;\n                        let startX, startY;\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n                        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n                        for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n                            switch(ops[i] | 0){\n                                case _util.OPS.rectangle:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    const width = args[j++];\n                                    const height = args[j++];\n                                    const xw = x + width;\n                                    const yh = y + height;\n                                    ctx.moveTo(x, y);\n                                    if (width === 0 || height === 0) {\n                                        ctx.lineTo(xw, yh);\n                                    } else {\n                                        ctx.lineTo(xw, y);\n                                        ctx.lineTo(xw, yh);\n                                        ctx.lineTo(x, yh);\n                                    }\n                                    if (!isScalingMatrix) {\n                                        current.updateRectMinMax(currentTransform, [\n                                            x,\n                                            y,\n                                            xw,\n                                            yh\n                                        ]);\n                                    }\n                                    ctx.closePath();\n                                    break;\n                                case _util.OPS.moveTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    ctx.moveTo(x, y);\n                                    if (!isScalingMatrix) {\n                                        current.updatePathMinMax(currentTransform, x, y);\n                                    }\n                                    break;\n                                case _util.OPS.lineTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    ctx.lineTo(x, y);\n                                    if (!isScalingMatrix) {\n                                        current.updatePathMinMax(currentTransform, x, y);\n                                    }\n                                    break;\n                                case _util.OPS.curveTo:\n                                    startX = x;\n                                    startY = y;\n                                    x = args[j + 4];\n                                    y = args[j + 5];\n                                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                                    j += 6;\n                                    break;\n                                case _util.OPS.curveTo2:\n                                    startX = x;\n                                    startY = y;\n                                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    j += 4;\n                                    break;\n                                case _util.OPS.curveTo3:\n                                    startX = x;\n                                    startY = y;\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                                    j += 4;\n                                    break;\n                                case _util.OPS.closePath:\n                                    ctx.closePath();\n                                    break;\n                            }\n                        }\n                        if (isScalingMatrix) {\n                            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n                        }\n                        current.setCurrentPoint(x, y);\n                    }\n                    closePath() {\n                        this.ctx.closePath();\n                    }\n                    stroke(consumePath = true) {\n                        const ctx = this.ctx;\n                        const strokeColor = this.current.strokeColor;\n                        ctx.globalAlpha = this.current.strokeAlpha;\n                        if (this.contentVisible) {\n                            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                                ctx.save();\n                                ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n                                this.rescaleAndStroke(false);\n                                ctx.restore();\n                            } else {\n                                this.rescaleAndStroke(true);\n                            }\n                        }\n                        if (consumePath) {\n                            this.consumePath(this.current.getClippedPathBoundingBox());\n                        }\n                        ctx.globalAlpha = this.current.fillAlpha;\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    fill(consumePath = true) {\n                        const ctx = this.ctx;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        let needRestore = false;\n                        if (isPatternFill) {\n                            ctx.save();\n                            ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                            needRestore = true;\n                        }\n                        const intersect = this.current.getClippedPathBoundingBox();\n                        if (this.contentVisible && intersect !== null) {\n                            if (this.pendingEOFill) {\n                                ctx.fill(\"evenodd\");\n                                this.pendingEOFill = false;\n                            } else {\n                                ctx.fill();\n                            }\n                        }\n                        if (needRestore) {\n                            ctx.restore();\n                        }\n                        if (consumePath) {\n                            this.consumePath(intersect);\n                        }\n                    }\n                    eoFill() {\n                        this.pendingEOFill = true;\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.fill(false);\n                        this.stroke(false);\n                        this.consumePath();\n                    }\n                    eoFillStroke() {\n                        this.pendingEOFill = true;\n                        this.fillStroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.pendingEOFill = true;\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    endPath() {\n                        this.consumePath();\n                    }\n                    clip() {\n                        this.pendingClip = NORMAL_CLIP;\n                    }\n                    eoClip() {\n                        this.pendingClip = EO_CLIP;\n                    }\n                    beginText() {\n                        this.current.textMatrix = _util.IDENTITY_MATRIX;\n                        this.current.textMatrixScale = 1;\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    endText() {\n                        const paths = this.pendingTextPaths;\n                        const ctx = this.ctx;\n                        if (paths === undefined) {\n                            ctx.beginPath();\n                            return;\n                        }\n                        ctx.save();\n                        ctx.beginPath();\n                        for (const path of paths){\n                            ctx.setTransform(...path.transform);\n                            ctx.translate(path.x, path.y);\n                            path.addToPath(ctx, path.fontSize);\n                        }\n                        ctx.restore();\n                        ctx.clip();\n                        ctx.beginPath();\n                        delete this.pendingTextPaths;\n                    }\n                    setCharSpacing(spacing) {\n                        this.current.charSpacing = spacing;\n                    }\n                    setWordSpacing(spacing) {\n                        this.current.wordSpacing = spacing;\n                    }\n                    setHScale(scale) {\n                        this.current.textHScale = scale / 100;\n                    }\n                    setLeading(leading) {\n                        this.current.leading = -leading;\n                    }\n                    setFont(fontRefName, size) {\n                        const fontObj = this.commonObjs.get(fontRefName);\n                        const current = this.current;\n                        if (!fontObj) {\n                            throw new Error(`Can't find font for ${fontRefName}`);\n                        }\n                        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n                            (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n                        }\n                        if (size < 0) {\n                            size = -size;\n                            current.fontDirection = -1;\n                        } else {\n                            current.fontDirection = 1;\n                        }\n                        this.current.font = fontObj;\n                        this.current.fontSize = size;\n                        if (fontObj.isType3Font) {\n                            return;\n                        }\n                        const name = fontObj.loadedName || \"sans-serif\";\n                        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n                        let bold = \"normal\";\n                        if (fontObj.black) {\n                            bold = \"900\";\n                        } else if (fontObj.bold) {\n                            bold = \"bold\";\n                        }\n                        const italic = fontObj.italic ? \"italic\" : \"normal\";\n                        let browserFontSize = size;\n                        if (size < MIN_FONT_SIZE) {\n                            browserFontSize = MIN_FONT_SIZE;\n                        } else if (size > MAX_FONT_SIZE) {\n                            browserFontSize = MAX_FONT_SIZE;\n                        }\n                        this.current.fontSizeScale = size / browserFontSize;\n                        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n                    }\n                    setTextRenderingMode(mode) {\n                        this.current.textRenderingMode = mode;\n                    }\n                    setTextRise(rise) {\n                        this.current.textRise = rise;\n                    }\n                    moveText(x, y) {\n                        this.current.x = this.current.lineX += x;\n                        this.current.y = this.current.lineY += y;\n                    }\n                    setLeadingMoveText(x, y) {\n                        this.setLeading(-y);\n                        this.moveText(x, y);\n                    }\n                    setTextMatrix(a, b, c, d, e, f) {\n                        this.current.textMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        this.current.textMatrixScale = Math.hypot(a, b);\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    paintChar(character, x, y, patternTransform) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        const font = current.font;\n                        const textRenderingMode = current.textRenderingMode;\n                        const fontSize = current.fontSize / current.fontSizeScale;\n                        const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                        const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n                        const patternFill = current.patternFill && !font.missingFile;\n                        let addToPath;\n                        if (font.disableFontFace || isAddToPathSet || patternFill) {\n                            addToPath = font.getPathGenerator(this.commonObjs, character);\n                        }\n                        if (font.disableFontFace || patternFill) {\n                            ctx.save();\n                            ctx.translate(x, y);\n                            ctx.beginPath();\n                            addToPath(ctx, fontSize);\n                            if (patternTransform) {\n                                ctx.setTransform(...patternTransform);\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.fill();\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.stroke();\n                            }\n                            ctx.restore();\n                        } else {\n                            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.fillText(character, x, y);\n                            }\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                ctx.strokeText(character, x, y);\n                            }\n                        }\n                        if (isAddToPathSet) {\n                            const paths = this.pendingTextPaths ||= [];\n                            paths.push({\n                                transform: (0, _display_utils.getCurrentTransform)(ctx),\n                                x,\n                                y,\n                                fontSize,\n                                addToPath\n                            });\n                        }\n                    }\n                    get isFontSubpixelAAEnabled() {\n                        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n                        ctx.scale(1.5, 1);\n                        ctx.fillText(\"I\", 0, 10);\n                        const data = ctx.getImageData(0, 0, 10, 10).data;\n                        let enabled = false;\n                        for(let i = 3; i < data.length; i += 4){\n                            if (data[i] > 0 && data[i] < 255) {\n                                enabled = true;\n                                break;\n                            }\n                        }\n                        return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n                    }\n                    showText(glyphs) {\n                        const current = this.current;\n                        const font = current.font;\n                        if (font.isType3Font) {\n                            return this.showType3Text(glyphs);\n                        }\n                        const fontSize = current.fontSize;\n                        if (fontSize === 0) {\n                            return undefined;\n                        }\n                        const ctx = this.ctx;\n                        const fontSizeScale = current.fontSizeScale;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const fontDirection = current.fontDirection;\n                        const textHScale = current.textHScale * fontDirection;\n                        const glyphsLength = glyphs.length;\n                        const vertical = font.vertical;\n                        const spacingDir = vertical ? 1 : -1;\n                        const defaultVMetrics = font.defaultVMetrics;\n                        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n                        const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n                        ctx.save();\n                        ctx.transform(...current.textMatrix);\n                        ctx.translate(current.x, current.y + current.textRise);\n                        if (fontDirection > 0) {\n                            ctx.scale(textHScale, -1);\n                        } else {\n                            ctx.scale(textHScale, 1);\n                        }\n                        let patternTransform;\n                        if (current.patternFill) {\n                            ctx.save();\n                            const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n                            patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                            ctx.restore();\n                            ctx.fillStyle = pattern;\n                        }\n                        let lineWidth = current.lineWidth;\n                        const scale = current.textMatrixScale;\n                        if (scale === 0 || lineWidth === 0) {\n                            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                                lineWidth = this.getSinglePixelWidth();\n                            }\n                        } else {\n                            lineWidth /= scale;\n                        }\n                        if (fontSizeScale !== 1.0) {\n                            ctx.scale(fontSizeScale, fontSizeScale);\n                            lineWidth /= fontSizeScale;\n                        }\n                        ctx.lineWidth = lineWidth;\n                        if (font.isInvalidPDFjsFont) {\n                            const chars = [];\n                            let width = 0;\n                            for (const glyph of glyphs){\n                                chars.push(glyph.unicode);\n                                width += glyph.width;\n                            }\n                            ctx.fillText(chars.join(\"\"), 0, 0);\n                            current.x += width * widthAdvanceScale * textHScale;\n                            ctx.restore();\n                            this.compose();\n                            return undefined;\n                        }\n                        let x = 0, i;\n                        for(i = 0; i < glyphsLength; ++i){\n                            const glyph = glyphs[i];\n                            if (typeof glyph === \"number\") {\n                                x += spacingDir * glyph * fontSize / 1000;\n                                continue;\n                            }\n                            let restoreNeeded = false;\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const character = glyph.fontChar;\n                            const accent = glyph.accent;\n                            let scaledX, scaledY;\n                            let width = glyph.width;\n                            if (vertical) {\n                                const vmetric = glyph.vmetric || defaultVMetrics;\n                                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                                const vy = vmetric[2] * widthAdvanceScale;\n                                width = vmetric ? -vmetric[0] : width;\n                                scaledX = vx / fontSizeScale;\n                                scaledY = (x + vy) / fontSizeScale;\n                            } else {\n                                scaledX = x / fontSizeScale;\n                                scaledY = 0;\n                            }\n                            if (font.remeasure && width > 0) {\n                                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                                    const characterScaleX = width / measuredWidth;\n                                    restoreNeeded = true;\n                                    ctx.save();\n                                    ctx.scale(characterScaleX, 1);\n                                    scaledX /= characterScaleX;\n                                } else if (width !== measuredWidth) {\n                                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                                }\n                            }\n                            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                                if (simpleFillText && !accent) {\n                                    ctx.fillText(character, scaledX, scaledY);\n                                } else {\n                                    this.paintChar(character, scaledX, scaledY, patternTransform);\n                                    if (accent) {\n                                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n                                    }\n                                }\n                            }\n                            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n                            x += charWidth;\n                            if (restoreNeeded) {\n                                ctx.restore();\n                            }\n                        }\n                        if (vertical) {\n                            current.y -= x;\n                        } else {\n                            current.x += x * textHScale;\n                        }\n                        ctx.restore();\n                        this.compose();\n                        return undefined;\n                    }\n                    showType3Text(glyphs) {\n                        const ctx = this.ctx;\n                        const current = this.current;\n                        const font = current.font;\n                        const fontSize = current.fontSize;\n                        const fontDirection = current.fontDirection;\n                        const spacingDir = font.vertical ? 1 : -1;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const textHScale = current.textHScale * fontDirection;\n                        const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        const glyphsLength = glyphs.length;\n                        const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n                        let i, glyph, width, spacingLength;\n                        if (isTextInvisible || fontSize === 0) {\n                            return;\n                        }\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                        ctx.save();\n                        ctx.transform(...current.textMatrix);\n                        ctx.translate(current.x, current.y);\n                        ctx.scale(textHScale, fontDirection);\n                        for(i = 0; i < glyphsLength; ++i){\n                            glyph = glyphs[i];\n                            if (typeof glyph === \"number\") {\n                                spacingLength = spacingDir * glyph * fontSize / 1000;\n                                this.ctx.translate(spacingLength, 0);\n                                current.x += spacingLength * textHScale;\n                                continue;\n                            }\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n                            if (!operatorList) {\n                                (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                                continue;\n                            }\n                            if (this.contentVisible) {\n                                this.processingType3 = glyph;\n                                this.save();\n                                ctx.scale(fontSize, fontSize);\n                                ctx.transform(...fontMatrix);\n                                this.executeOperatorList(operatorList);\n                                this.restore();\n                            }\n                            const transformed = _util.Util.applyTransform([\n                                glyph.width,\n                                0\n                            ], fontMatrix);\n                            width = transformed[0] * fontSize + spacing;\n                            ctx.translate(width, 0);\n                            current.x += width * textHScale;\n                        }\n                        ctx.restore();\n                        this.processingType3 = null;\n                    }\n                    setCharWidth(xWidth, yWidth) {}\n                    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n                        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n                        this.ctx.clip();\n                        this.endPath();\n                    }\n                    getColorN_Pattern(IR) {\n                        let pattern;\n                        if (IR[0] === \"TilingPattern\") {\n                            const color = IR[1];\n                            const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n                            const canvasGraphicsFactory = {\n                                createCanvasGraphics: (ctx)=>{\n                                    return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                                        optionalContentConfig: this.optionalContentConfig,\n                                        markedContentStack: this.markedContentStack\n                                    });\n                                }\n                            };\n                            pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n                        } else {\n                            pattern = this._getPattern(IR[1], IR[2]);\n                        }\n                        return pattern;\n                    }\n                    setStrokeColorN() {\n                        this.current.strokeColor = this.getColorN_Pattern(arguments);\n                    }\n                    setFillColorN() {\n                        this.current.fillColor = this.getColorN_Pattern(arguments);\n                        this.current.patternFill = true;\n                    }\n                    setStrokeRGBColor(r, g, b) {\n                        const color = _util.Util.makeHexColor(r, g, b);\n                        this.ctx.strokeStyle = color;\n                        this.current.strokeColor = color;\n                    }\n                    setFillRGBColor(r, g, b) {\n                        const color = _util.Util.makeHexColor(r, g, b);\n                        this.ctx.fillStyle = color;\n                        this.current.fillColor = color;\n                        this.current.patternFill = false;\n                    }\n                    _getPattern(objId, matrix = null) {\n                        let pattern;\n                        if (this.cachedPatterns.has(objId)) {\n                            pattern = this.cachedPatterns.get(objId);\n                        } else {\n                            pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));\n                            this.cachedPatterns.set(objId, pattern);\n                        }\n                        if (matrix) {\n                            pattern.matrix = matrix;\n                        }\n                        return pattern;\n                    }\n                    shadingFill(objId) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        this.save();\n                        const pattern = this._getPattern(objId);\n                        ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n                        const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n                        if (inv) {\n                            const { width, height } = ctx.canvas;\n                            const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                width,\n                                height\n                            ], inv);\n                            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n                        } else {\n                            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n                        }\n                        this.compose(this.current.getClippedPathBoundingBox());\n                        this.restore();\n                    }\n                    beginInlineImage() {\n                        (0, _util.unreachable)(\"Should not call beginInlineImage\");\n                    }\n                    beginImageData() {\n                        (0, _util.unreachable)(\"Should not call beginImageData\");\n                    }\n                    paintFormXObjectBegin(matrix, bbox) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        this.baseTransformStack.push(this.baseTransform);\n                        if (Array.isArray(matrix) && matrix.length === 6) {\n                            this.transform(...matrix);\n                        }\n                        this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n                        if (bbox) {\n                            const width = bbox[2] - bbox[0];\n                            const height = bbox[3] - bbox[1];\n                            this.ctx.rect(bbox[0], bbox[1], width, height);\n                            this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n                            this.clip();\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.restore();\n                        this.baseTransform = this.baseTransformStack.pop();\n                    }\n                    beginGroup(group) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        if (this.inSMaskMode) {\n                            this.endSMaskMode();\n                            this.current.activeSMask = null;\n                        }\n                        const currentCtx = this.ctx;\n                        if (!group.isolated) {\n                            (0, _util.info)(\"TODO: Support non-isolated groups.\");\n                        }\n                        if (group.knockout) {\n                            (0, _util.warn)(\"Knockout groups not supported.\");\n                        }\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n                        if (group.matrix) {\n                            currentCtx.transform(...group.matrix);\n                        }\n                        if (!group.bbox) {\n                            throw new Error(\"Bounding box is required.\");\n                        }\n                        let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n                        const canvasBounds = [\n                            0,\n                            0,\n                            currentCtx.canvas.width,\n                            currentCtx.canvas.height\n                        ];\n                        bounds = _util.Util.intersect(bounds, canvasBounds) || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        const offsetX = Math.floor(bounds[0]);\n                        const offsetY = Math.floor(bounds[1]);\n                        let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n                        let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n                        let scaleX = 1, scaleY = 1;\n                        if (drawnWidth > MAX_GROUP_SIZE) {\n                            scaleX = drawnWidth / MAX_GROUP_SIZE;\n                            drawnWidth = MAX_GROUP_SIZE;\n                        }\n                        if (drawnHeight > MAX_GROUP_SIZE) {\n                            scaleY = drawnHeight / MAX_GROUP_SIZE;\n                            drawnHeight = MAX_GROUP_SIZE;\n                        }\n                        this.current.startNewPathAndClipBox([\n                            0,\n                            0,\n                            drawnWidth,\n                            drawnHeight\n                        ]);\n                        let cacheId = \"groupAt\" + this.groupLevel;\n                        if (group.smask) {\n                            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n                        }\n                        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n                        const groupCtx = scratchCanvas.context;\n                        groupCtx.scale(1 / scaleX, 1 / scaleY);\n                        groupCtx.translate(-offsetX, -offsetY);\n                        groupCtx.transform(...currentTransform);\n                        if (group.smask) {\n                            this.smaskStack.push({\n                                canvas: scratchCanvas.canvas,\n                                context: groupCtx,\n                                offsetX,\n                                offsetY,\n                                scaleX,\n                                scaleY,\n                                subtype: group.smask.subtype,\n                                backdrop: group.smask.backdrop,\n                                transferMap: group.smask.transferMap || null,\n                                startTransformInverse: null\n                            });\n                        } else {\n                            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n                            currentCtx.translate(offsetX, offsetY);\n                            currentCtx.scale(scaleX, scaleY);\n                            currentCtx.save();\n                        }\n                        copyCtxState(currentCtx, groupCtx);\n                        this.ctx = groupCtx;\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                        this.groupStack.push(currentCtx);\n                        this.groupLevel++;\n                    }\n                    endGroup(group) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.groupLevel--;\n                        const groupCtx = this.ctx;\n                        const ctx = this.groupStack.pop();\n                        this.ctx = ctx;\n                        this.ctx.imageSmoothingEnabled = false;\n                        if (group.smask) {\n                            this.tempSMask = this.smaskStack.pop();\n                            this.restore();\n                        } else {\n                            this.ctx.restore();\n                            const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n                            this.restore();\n                            this.ctx.save();\n                            this.ctx.setTransform(...currentMtx);\n                            const dirtyBox = _util.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                groupCtx.canvas.width,\n                                groupCtx.canvas.height\n                            ], currentMtx);\n                            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n                            this.ctx.restore();\n                            this.compose(dirtyBox);\n                        }\n                    }\n                    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n                        this.#restoreInitialState();\n                        resetCtxToDefault(this.ctx);\n                        this.ctx.save();\n                        this.save();\n                        if (this.baseTransform) {\n                            this.ctx.setTransform(...this.baseTransform);\n                        }\n                        if (Array.isArray(rect) && rect.length === 4) {\n                            const width = rect[2] - rect[0];\n                            const height = rect[3] - rect[1];\n                            if (hasOwnCanvas && this.annotationCanvasMap) {\n                                transform = transform.slice();\n                                transform[4] -= rect[0];\n                                transform[5] -= rect[1];\n                                rect = rect.slice();\n                                rect[0] = rect[1] = 0;\n                                rect[2] = width;\n                                rect[3] = height;\n                                const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n                                const { viewportScale } = this;\n                                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                                const { canvas, context } = this.annotationCanvas;\n                                this.annotationCanvasMap.set(id, canvas);\n                                this.annotationCanvas.savedCtx = this.ctx;\n                                this.ctx = context;\n                                this.ctx.save();\n                                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                                resetCtxToDefault(this.ctx);\n                            } else {\n                                resetCtxToDefault(this.ctx);\n                                this.ctx.rect(rect[0], rect[1], width, height);\n                                this.ctx.clip();\n                                this.endPath();\n                            }\n                        }\n                        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.transform(...transform);\n                        this.transform(...matrix);\n                    }\n                    endAnnotation() {\n                        if (this.annotationCanvas) {\n                            this.ctx.restore();\n                            this.#drawFilter();\n                            this.ctx = this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas;\n                        }\n                    }\n                    paintImageMaskXObject(img) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const count = img.count;\n                        img = this.getObject(img.data, img);\n                        img.count = count;\n                        const ctx = this.ctx;\n                        const glyph = this.processingType3;\n                        if (glyph) {\n                            if (glyph.compiled === undefined) {\n                                glyph.compiled = compileType3Glyph(img);\n                            }\n                            if (glyph.compiled) {\n                                glyph.compiled(ctx);\n                                return;\n                            }\n                        }\n                        const mask = this._createMaskCanvas(img);\n                        const maskCanvas = mask.canvas;\n                        ctx.save();\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n                        ctx.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        img = this.getObject(img.data, img);\n                        const ctx = this.ctx;\n                        ctx.save();\n                        const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n                        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n                        const mask = this._createMaskCanvas(img);\n                        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n                        for(let i = 0, ii = positions.length; i < ii; i += 2){\n                            const trans = _util.Util.transform(currentTransform, [\n                                scaleX,\n                                skewX,\n                                skewY,\n                                scaleY,\n                                positions[i],\n                                positions[i + 1]\n                            ]);\n                            const [x, y] = _util.Util.applyTransform([\n                                0,\n                                0\n                            ], trans);\n                            ctx.drawImage(mask.canvas, x, y);\n                        }\n                        ctx.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectGroup(images) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        const fillColor = this.current.fillColor;\n                        const isPatternFill = this.current.patternFill;\n                        for (const image of images){\n                            const { data, width, height, transform } = image;\n                            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n                            const maskCtx = maskCanvas.context;\n                            maskCtx.save();\n                            const img = this.getObject(data, image);\n                            putBinaryImageMask(maskCtx, img);\n                            maskCtx.globalCompositeOperation = \"source-in\";\n                            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n                            maskCtx.fillRect(0, 0, width, height);\n                            maskCtx.restore();\n                            ctx.save();\n                            ctx.transform(...transform);\n                            ctx.scale(1, -1);\n                            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n                            ctx.restore();\n                        }\n                        this.compose();\n                    }\n                    paintImageXObject(objId) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData);\n                    }\n                    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const map = [];\n                        for(let i = 0, ii = positions.length; i < ii; i += 2){\n                            map.push({\n                                transform: [\n                                    scaleX,\n                                    0,\n                                    0,\n                                    scaleY,\n                                    positions[i],\n                                    positions[i + 1]\n                                ],\n                                x: 0,\n                                y: 0,\n                                w: width,\n                                h: height\n                            });\n                        }\n                        this.paintInlineImageXObjectGroup(imgData, map);\n                    }\n                    applyTransferMapsToCanvas(ctx) {\n                        if (this.current.transferMaps !== \"none\") {\n                            ctx.filter = this.current.transferMaps;\n                            ctx.drawImage(ctx.canvas, 0, 0);\n                            ctx.filter = \"none\";\n                        }\n                        return ctx.canvas;\n                    }\n                    applyTransferMapsToBitmap(imgData) {\n                        if (this.current.transferMaps === \"none\") {\n                            return imgData.bitmap;\n                        }\n                        const { bitmap, width, height } = imgData;\n                        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                        const tmpCtx = tmpCanvas.context;\n                        tmpCtx.filter = this.current.transferMaps;\n                        tmpCtx.drawImage(bitmap, 0, 0);\n                        tmpCtx.filter = \"none\";\n                        return tmpCanvas.canvas;\n                    }\n                    paintInlineImageXObject(imgData) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const ctx = this.ctx;\n                        this.save();\n                        if (!_util.isNodeJS) {\n                            const { filter } = ctx;\n                            if (filter !== \"none\" && filter !== \"\") {\n                                ctx.filter = \"none\";\n                            }\n                        }\n                        ctx.scale(1 / width, -1 / height);\n                        let imgToPaint;\n                        if (imgData.bitmap) {\n                            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n                        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n                            imgToPaint = imgData;\n                        } else {\n                            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n                            const tmpCtx = tmpCanvas.context;\n                            putBinaryImageData(tmpCtx, imgData);\n                            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                        }\n                        const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n                        ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n                        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n                        this.compose();\n                        this.restore();\n                    }\n                    paintInlineImageXObjectGroup(imgData, map) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx = this.ctx;\n                        let imgToPaint;\n                        if (imgData.bitmap) {\n                            imgToPaint = imgData.bitmap;\n                        } else {\n                            const w = imgData.width;\n                            const h = imgData.height;\n                            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n                            const tmpCtx = tmpCanvas.context;\n                            putBinaryImageData(tmpCtx, imgData);\n                            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n                        }\n                        for (const entry of map){\n                            ctx.save();\n                            ctx.transform(...entry.transform);\n                            ctx.scale(1, -1);\n                            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n                            ctx.restore();\n                        }\n                        this.compose();\n                    }\n                    paintSolidColorImageMask() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.ctx.fillRect(0, 0, 1, 1);\n                        this.compose();\n                    }\n                    markPoint(tag) {}\n                    markPointProps(tag, properties) {}\n                    beginMarkedContent(tag) {\n                        this.markedContentStack.push({\n                            visible: true\n                        });\n                    }\n                    beginMarkedContentProps(tag, properties) {\n                        if (tag === \"OC\") {\n                            this.markedContentStack.push({\n                                visible: this.optionalContentConfig.isVisible(properties)\n                            });\n                        } else {\n                            this.markedContentStack.push({\n                                visible: true\n                            });\n                        }\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    endMarkedContent() {\n                        this.markedContentStack.pop();\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    beginCompat() {}\n                    endCompat() {}\n                    consumePath(clipBox) {\n                        const isEmpty = this.current.isEmptyClip();\n                        if (this.pendingClip) {\n                            this.current.updateClipFromPath();\n                        }\n                        if (!this.pendingClip) {\n                            this.compose(clipBox);\n                        }\n                        const ctx = this.ctx;\n                        if (this.pendingClip) {\n                            if (!isEmpty) {\n                                if (this.pendingClip === EO_CLIP) {\n                                    ctx.clip(\"evenodd\");\n                                } else {\n                                    ctx.clip();\n                                }\n                            }\n                            this.pendingClip = null;\n                        }\n                        this.current.startNewPathAndClipBox(this.current.clipBox);\n                        ctx.beginPath();\n                    }\n                    getSinglePixelWidth() {\n                        if (!this._cachedGetSinglePixelWidth) {\n                            const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n                            if (m[1] === 0 && m[2] === 0) {\n                                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n                            } else {\n                                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                                const normX = Math.hypot(m[0], m[2]);\n                                const normY = Math.hypot(m[1], m[3]);\n                                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n                            }\n                        }\n                        return this._cachedGetSinglePixelWidth;\n                    }\n                    getScaleForStroking() {\n                        if (this._cachedScaleForStroking[0] === -1) {\n                            const { lineWidth } = this.current;\n                            const { a, b, c, d } = this.ctx.getTransform();\n                            let scaleX, scaleY;\n                            if (b === 0 && c === 0) {\n                                const normX = Math.abs(a);\n                                const normY = Math.abs(d);\n                                if (normX === normY) {\n                                    if (lineWidth === 0) {\n                                        scaleX = scaleY = 1 / normX;\n                                    } else {\n                                        const scaledLineWidth = normX * lineWidth;\n                                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                                    }\n                                } else if (lineWidth === 0) {\n                                    scaleX = 1 / normX;\n                                    scaleY = 1 / normY;\n                                } else {\n                                    const scaledXLineWidth = normX * lineWidth;\n                                    const scaledYLineWidth = normY * lineWidth;\n                                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                                }\n                            } else {\n                                const absDet = Math.abs(a * d - b * c);\n                                const normX = Math.hypot(a, b);\n                                const normY = Math.hypot(c, d);\n                                if (lineWidth === 0) {\n                                    scaleX = normY / absDet;\n                                    scaleY = normX / absDet;\n                                } else {\n                                    const baseArea = lineWidth * absDet;\n                                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                                }\n                            }\n                            this._cachedScaleForStroking[0] = scaleX;\n                            this._cachedScaleForStroking[1] = scaleY;\n                        }\n                        return this._cachedScaleForStroking;\n                    }\n                    rescaleAndStroke(saveRestore) {\n                        const { ctx } = this;\n                        const { lineWidth } = this.current;\n                        const [scaleX, scaleY] = this.getScaleForStroking();\n                        ctx.lineWidth = lineWidth || 1;\n                        if (scaleX === 1 && scaleY === 1) {\n                            ctx.stroke();\n                            return;\n                        }\n                        const dashes = ctx.getLineDash();\n                        if (saveRestore) {\n                            ctx.save();\n                        }\n                        ctx.scale(scaleX, scaleY);\n                        if (dashes.length > 0) {\n                            const scale = Math.max(scaleX, scaleY);\n                            ctx.setLineDash(dashes.map((x)=>x / scale));\n                            ctx.lineDashOffset /= scale;\n                        }\n                        ctx.stroke();\n                        if (saveRestore) {\n                            ctx.restore();\n                        }\n                    }\n                    isContentVisible() {\n                        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n                            if (!this.markedContentStack[i].visible) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n                exports1.CanvasGraphics = CanvasGraphics;\n                for(const op in _util.OPS){\n                    if (CanvasGraphics.prototype[op] !== undefined) {\n                        CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n                    }\n                }\n            /***/ },\n            /* 12 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TilingPattern = exports1.PathType = void 0;\n                exports1.getShadingPattern = getShadingPattern;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                const PathType = {\n                    FILL: \"Fill\",\n                    STROKE: \"Stroke\",\n                    SHADING: \"Shading\"\n                };\n                exports1.PathType = PathType;\n                function applyBoundingBox(ctx, bbox) {\n                    if (!bbox) {\n                        return;\n                    }\n                    const width = bbox[2] - bbox[0];\n                    const height = bbox[3] - bbox[1];\n                    const region = new Path2D();\n                    region.rect(bbox[0], bbox[1], width, height);\n                    ctx.clip(region);\n                }\n                class BaseShadingPattern {\n                    constructor(){\n                        if (this.constructor === BaseShadingPattern) {\n                            (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n                        }\n                    }\n                    getPattern() {\n                        (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n                    }\n                }\n                class RadialAxialShadingPattern extends BaseShadingPattern {\n                    constructor(IR){\n                        super();\n                        this._type = IR[1];\n                        this._bbox = IR[2];\n                        this._colorStops = IR[3];\n                        this._p0 = IR[4];\n                        this._p1 = IR[5];\n                        this._r0 = IR[6];\n                        this._r1 = IR[7];\n                        this.matrix = null;\n                    }\n                    _createGradient(ctx) {\n                        let grad;\n                        if (this._type === \"axial\") {\n                            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n                        } else if (this._type === \"radial\") {\n                            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n                        }\n                        for (const colorStop of this._colorStops){\n                            grad.addColorStop(colorStop[0], colorStop[1]);\n                        }\n                        return grad;\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        let pattern;\n                        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n                            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [\n                                0,\n                                0,\n                                0,\n                                0\n                            ];\n                            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n                            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n                            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n                            const tmpCtx = tmpCanvas.context;\n                            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                            tmpCtx.beginPath();\n                            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n                            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n                            inverse = _util.Util.transform(inverse, [\n                                1,\n                                0,\n                                0,\n                                1,\n                                ownerBBox[0],\n                                ownerBBox[1]\n                            ]);\n                            tmpCtx.transform(...owner.baseTransform);\n                            if (this.matrix) {\n                                tmpCtx.transform(...this.matrix);\n                            }\n                            applyBoundingBox(tmpCtx, this._bbox);\n                            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n                            tmpCtx.fill();\n                            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n                            const domMatrix = new DOMMatrix(inverse);\n                            pattern.setTransform(domMatrix);\n                        } else {\n                            applyBoundingBox(ctx, this._bbox);\n                            pattern = this._createGradient(ctx);\n                        }\n                        return pattern;\n                    }\n                }\n                function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n                    const coords = context.coords, colors = context.colors;\n                    const bytes = data.data, rowSize = data.width * 4;\n                    let tmp;\n                    if (coords[p1 + 1] > coords[p2 + 1]) {\n                        tmp = p1;\n                        p1 = p2;\n                        p2 = tmp;\n                        tmp = c1;\n                        c1 = c2;\n                        c2 = tmp;\n                    }\n                    if (coords[p2 + 1] > coords[p3 + 1]) {\n                        tmp = p2;\n                        p2 = p3;\n                        p3 = tmp;\n                        tmp = c2;\n                        c2 = c3;\n                        c3 = tmp;\n                    }\n                    if (coords[p1 + 1] > coords[p2 + 1]) {\n                        tmp = p1;\n                        p1 = p2;\n                        p2 = tmp;\n                        tmp = c1;\n                        c1 = c2;\n                        c2 = tmp;\n                    }\n                    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n                    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n                    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n                    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n                    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n                    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n                    if (y1 >= y3) {\n                        return;\n                    }\n                    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n                    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n                    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n                    const minY = Math.round(y1), maxY = Math.round(y3);\n                    let xa, car, cag, cab;\n                    let xb, cbr, cbg, cbb;\n                    for(let y = minY; y <= maxY; y++){\n                        if (y < y2) {\n                            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n                            xa = x1 - (x1 - x2) * k;\n                            car = c1r - (c1r - c2r) * k;\n                            cag = c1g - (c1g - c2g) * k;\n                            cab = c1b - (c1b - c2b) * k;\n                        } else {\n                            let k;\n                            if (y > y3) {\n                                k = 1;\n                            } else if (y2 === y3) {\n                                k = 0;\n                            } else {\n                                k = (y2 - y) / (y2 - y3);\n                            }\n                            xa = x2 - (x2 - x3) * k;\n                            car = c2r - (c2r - c3r) * k;\n                            cag = c2g - (c2g - c3g) * k;\n                            cab = c2b - (c2b - c3b) * k;\n                        }\n                        let k;\n                        if (y < y1) {\n                            k = 0;\n                        } else if (y > y3) {\n                            k = 1;\n                        } else {\n                            k = (y1 - y) / (y1 - y3);\n                        }\n                        xb = x1 - (x1 - x3) * k;\n                        cbr = c1r - (c1r - c3r) * k;\n                        cbg = c1g - (c1g - c3g) * k;\n                        cbb = c1b - (c1b - c3b) * k;\n                        const x1_ = Math.round(Math.min(xa, xb));\n                        const x2_ = Math.round(Math.max(xa, xb));\n                        let j = rowSize * y + x1_ * 4;\n                        for(let x = x1_; x <= x2_; x++){\n                            k = (xa - x) / (xa - xb);\n                            if (k < 0) {\n                                k = 0;\n                            } else if (k > 1) {\n                                k = 1;\n                            }\n                            bytes[j++] = car - (car - cbr) * k | 0;\n                            bytes[j++] = cag - (cag - cbg) * k | 0;\n                            bytes[j++] = cab - (cab - cbb) * k | 0;\n                            bytes[j++] = 255;\n                        }\n                    }\n                }\n                function drawFigure(data, figure, context) {\n                    const ps = figure.coords;\n                    const cs = figure.colors;\n                    let i, ii;\n                    switch(figure.type){\n                        case \"lattice\":\n                            const verticesPerRow = figure.verticesPerRow;\n                            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n                            const cols = verticesPerRow - 1;\n                            for(i = 0; i < rows; i++){\n                                let q = i * verticesPerRow;\n                                for(let j = 0; j < cols; j++, q++){\n                                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                                }\n                            }\n                            break;\n                        case \"triangles\":\n                            for(i = 0, ii = ps.length; i < ii; i += 3){\n                                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n                            }\n                            break;\n                        default:\n                            throw new Error(\"illegal figure\");\n                    }\n                }\n                class MeshShadingPattern extends BaseShadingPattern {\n                    constructor(IR){\n                        super();\n                        this._coords = IR[2];\n                        this._colors = IR[3];\n                        this._figures = IR[4];\n                        this._bounds = IR[5];\n                        this._bbox = IR[7];\n                        this._background = IR[8];\n                        this.matrix = null;\n                    }\n                    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n                        const EXPECTED_SCALE = 1.1;\n                        const MAX_PATTERN_SIZE = 3000;\n                        const BORDER_SIZE = 2;\n                        const offsetX = Math.floor(this._bounds[0]);\n                        const offsetY = Math.floor(this._bounds[1]);\n                        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n                        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n                        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n                        const scaleX = boundsWidth / width;\n                        const scaleY = boundsHeight / height;\n                        const context = {\n                            coords: this._coords,\n                            colors: this._colors,\n                            offsetX: -offsetX,\n                            offsetY: -offsetY,\n                            scaleX: 1 / scaleX,\n                            scaleY: 1 / scaleY\n                        };\n                        const paddedWidth = width + BORDER_SIZE * 2;\n                        const paddedHeight = height + BORDER_SIZE * 2;\n                        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n                        const tmpCtx = tmpCanvas.context;\n                        const data = tmpCtx.createImageData(width, height);\n                        if (backgroundColor) {\n                            const bytes = data.data;\n                            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                                bytes[i] = backgroundColor[0];\n                                bytes[i + 1] = backgroundColor[1];\n                                bytes[i + 2] = backgroundColor[2];\n                                bytes[i + 3] = 255;\n                            }\n                        }\n                        for (const figure of this._figures){\n                            drawFigure(data, figure, context);\n                        }\n                        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n                        const canvas = tmpCanvas.canvas;\n                        return {\n                            canvas,\n                            offsetX: offsetX - BORDER_SIZE * scaleX,\n                            offsetY: offsetY - BORDER_SIZE * scaleY,\n                            scaleX,\n                            scaleY\n                        };\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        applyBoundingBox(ctx, this._bbox);\n                        let scale;\n                        if (pathType === PathType.SHADING) {\n                            scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n                        } else {\n                            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n                            if (this.matrix) {\n                                const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n                                scale = [\n                                    scale[0] * matrixScale[0],\n                                    scale[1] * matrixScale[1]\n                                ];\n                            }\n                        }\n                        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n                        if (pathType !== PathType.SHADING) {\n                            ctx.setTransform(...owner.baseTransform);\n                            if (this.matrix) {\n                                ctx.transform(...this.matrix);\n                            }\n                        }\n                        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n                        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n                    }\n                }\n                class DummyShadingPattern extends BaseShadingPattern {\n                    getPattern() {\n                        return \"hotpink\";\n                    }\n                }\n                function getShadingPattern(IR) {\n                    switch(IR[0]){\n                        case \"RadialAxial\":\n                            return new RadialAxialShadingPattern(IR);\n                        case \"Mesh\":\n                            return new MeshShadingPattern(IR);\n                        case \"Dummy\":\n                            return new DummyShadingPattern();\n                    }\n                    throw new Error(`Unknown IR type: ${IR[0]}`);\n                }\n                const PaintType = {\n                    COLORED: 1,\n                    UNCOLORED: 2\n                };\n                class TilingPattern {\n                    static{\n                        this.MAX_PATTERN_SIZE = 3000;\n                    }\n                    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n                        this.operatorList = IR[2];\n                        this.matrix = IR[3] || [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0\n                        ];\n                        this.bbox = IR[4];\n                        this.xstep = IR[5];\n                        this.ystep = IR[6];\n                        this.paintType = IR[7];\n                        this.tilingType = IR[8];\n                        this.color = color;\n                        this.ctx = ctx;\n                        this.canvasGraphicsFactory = canvasGraphicsFactory;\n                        this.baseTransform = baseTransform;\n                    }\n                    createPatternCanvas(owner) {\n                        const operatorList = this.operatorList;\n                        const bbox = this.bbox;\n                        const xstep = this.xstep;\n                        const ystep = this.ystep;\n                        const paintType = this.paintType;\n                        const tilingType = this.tilingType;\n                        const color = this.color;\n                        const canvasGraphicsFactory = this.canvasGraphicsFactory;\n                        (0, _util.info)(\"TilingType: \" + tilingType);\n                        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n                        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n                        const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n                        const combinedScale = [\n                            matrixScale[0] * curMatrixScale[0],\n                            matrixScale[1] * curMatrixScale[1]\n                        ];\n                        const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n                        const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n                        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n                        const tmpCtx = tmpCanvas.context;\n                        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n                        graphics.groupLevel = owner.groupLevel;\n                        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n                        let adjustedX0 = x0;\n                        let adjustedY0 = y0;\n                        let adjustedX1 = x1;\n                        let adjustedY1 = y1;\n                        if (x0 < 0) {\n                            adjustedX0 = 0;\n                            adjustedX1 += Math.abs(x0);\n                        }\n                        if (y0 < 0) {\n                            adjustedY0 = 0;\n                            adjustedY1 += Math.abs(y0);\n                        }\n                        tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n                        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n                        tmpCtx.save();\n                        this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n                        graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n                        graphics.executeOperatorList(operatorList);\n                        graphics.endDrawing();\n                        return {\n                            canvas: tmpCanvas.canvas,\n                            scaleX: dimx.scale,\n                            scaleY: dimy.scale,\n                            offsetX: adjustedX0,\n                            offsetY: adjustedY0\n                        };\n                    }\n                    getSizeAndScale(step, realOutputSize, scale) {\n                        step = Math.abs(step);\n                        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n                        let size = Math.ceil(step * scale);\n                        if (size >= maxSize) {\n                            size = maxSize;\n                        } else {\n                            scale = size / step;\n                        }\n                        return {\n                            scale,\n                            size\n                        };\n                    }\n                    clipBbox(graphics, x0, y0, x1, y1) {\n                        const bboxWidth = x1 - x0;\n                        const bboxHeight = y1 - y0;\n                        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n                        graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [\n                            x0,\n                            y0,\n                            x1,\n                            y1\n                        ]);\n                        graphics.clip();\n                        graphics.endPath();\n                    }\n                    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n                        const context = graphics.ctx, current = graphics.current;\n                        switch(paintType){\n                            case PaintType.COLORED:\n                                const ctx = this.ctx;\n                                context.fillStyle = ctx.fillStyle;\n                                context.strokeStyle = ctx.strokeStyle;\n                                current.fillColor = ctx.fillStyle;\n                                current.strokeColor = ctx.strokeStyle;\n                                break;\n                            case PaintType.UNCOLORED:\n                                const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n                                context.fillStyle = cssColor;\n                                context.strokeStyle = cssColor;\n                                current.fillColor = cssColor;\n                                current.strokeColor = cssColor;\n                                break;\n                            default:\n                                throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n                        }\n                    }\n                    getPattern(ctx, owner, inverse, pathType) {\n                        let matrix = inverse;\n                        if (pathType !== PathType.SHADING) {\n                            matrix = _util.Util.transform(matrix, owner.baseTransform);\n                            if (this.matrix) {\n                                matrix = _util.Util.transform(matrix, this.matrix);\n                            }\n                        }\n                        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n                        let domMatrix = new DOMMatrix(matrix);\n                        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n                        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n                        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n                        pattern.setTransform(domMatrix);\n                        return pattern;\n                    }\n                }\n                exports1.TilingPattern = TilingPattern;\n            /***/ },\n            /* 13 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;\n                exports1.convertToRGBA = convertToRGBA;\n                exports1.grayToRGBA = grayToRGBA;\n                var _util = __w_pdfjs_require__(1);\n                function convertToRGBA(params) {\n                    switch(params.kind){\n                        case _util.ImageKind.GRAYSCALE_1BPP:\n                            return convertBlackAndWhiteToRGBA(params);\n                        case _util.ImageKind.RGB_24BPP:\n                            return convertRGBToRGBA(params);\n                    }\n                    return null;\n                }\n                function convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n                    const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                    const [zeroMapping, oneMapping] = inverseDecode ? [\n                        nonBlackColor,\n                        black\n                    ] : [\n                        black,\n                        nonBlackColor\n                    ];\n                    const widthInSource = width >> 3;\n                    const widthRemainder = width & 7;\n                    const srcLength = src.length;\n                    dest = new Uint32Array(dest.buffer);\n                    let destPos = 0;\n                    for(let i = 0; i < height; i++){\n                        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n                            const elem = srcPos < srcLength ? src[srcPos] : 255;\n                            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n                            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n                        }\n                        if (widthRemainder === 0) {\n                            continue;\n                        }\n                        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n                        for(let j = 0; j < widthRemainder; j++){\n                            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n                        }\n                    }\n                    return {\n                        srcPos,\n                        destPos\n                    };\n                }\n                function convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n                    let i = 0;\n                    const len32 = src.length >> 2;\n                    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n                    if (_util.FeatureTest.isLittleEndian) {\n                        for(; i < len32 - 2; i += 3, destPos += 4){\n                            const s1 = src32[i];\n                            const s2 = src32[i + 1];\n                            const s3 = src32[i + 2];\n                            dest[destPos] = s1 | 0xff000000;\n                            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n                            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n                            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n                        }\n                        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n                        }\n                    } else {\n                        for(; i < len32 - 2; i += 3, destPos += 4){\n                            const s1 = src32[i];\n                            const s2 = src32[i + 1];\n                            const s3 = src32[i + 2];\n                            dest[destPos] = s1 | 0xff;\n                            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n                            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n                            dest[destPos + 3] = s3 << 8 | 0xff;\n                        }\n                        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n                            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n                        }\n                    }\n                    return {\n                        srcPos,\n                        destPos\n                    };\n                }\n                function grayToRGBA(src, dest) {\n                    if (_util.FeatureTest.isLittleEndian) {\n                        for(let i = 0, ii = src.length; i < ii; i++){\n                            dest[i] = src[i] * 0x10101 | 0xff000000;\n                        }\n                    } else {\n                        for(let i = 0, ii = src.length; i < ii; i++){\n                            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n                        }\n                    }\n                }\n            /***/ },\n            /* 14 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.GlobalWorkerOptions = void 0;\n                const GlobalWorkerOptions = Object.create(null);\n                exports1.GlobalWorkerOptions = GlobalWorkerOptions;\n                GlobalWorkerOptions.workerPort = null;\n                GlobalWorkerOptions.workerSrc = \"\";\n            /***/ },\n            /* 15 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MessageHandler = void 0;\n                var _util = __w_pdfjs_require__(1);\n                const CallbackKind = {\n                    UNKNOWN: 0,\n                    DATA: 1,\n                    ERROR: 2\n                };\n                const StreamKind = {\n                    UNKNOWN: 0,\n                    CANCEL: 1,\n                    CANCEL_COMPLETE: 2,\n                    CLOSE: 3,\n                    ENQUEUE: 4,\n                    ERROR: 5,\n                    PULL: 6,\n                    PULL_COMPLETE: 7,\n                    START_COMPLETE: 8\n                };\n                function wrapReason(reason) {\n                    if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n                        (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n                    }\n                    switch(reason.name){\n                        case \"AbortException\":\n                            return new _util.AbortException(reason.message);\n                        case \"MissingPDFException\":\n                            return new _util.MissingPDFException(reason.message);\n                        case \"PasswordException\":\n                            return new _util.PasswordException(reason.message, reason.code);\n                        case \"UnexpectedResponseException\":\n                            return new _util.UnexpectedResponseException(reason.message, reason.status);\n                        case \"UnknownErrorException\":\n                            return new _util.UnknownErrorException(reason.message, reason.details);\n                        default:\n                            return new _util.UnknownErrorException(reason.message, reason.toString());\n                    }\n                }\n                class MessageHandler {\n                    constructor(sourceName, targetName, comObj){\n                        this.sourceName = sourceName;\n                        this.targetName = targetName;\n                        this.comObj = comObj;\n                        this.callbackId = 1;\n                        this.streamId = 1;\n                        this.streamSinks = Object.create(null);\n                        this.streamControllers = Object.create(null);\n                        this.callbackCapabilities = Object.create(null);\n                        this.actionHandler = Object.create(null);\n                        this._onComObjOnMessage = (event)=>{\n                            const data = event.data;\n                            if (data.targetName !== this.sourceName) {\n                                return;\n                            }\n                            if (data.stream) {\n                                this.#processStreamMessage(data);\n                                return;\n                            }\n                            if (data.callback) {\n                                const callbackId = data.callbackId;\n                                const capability = this.callbackCapabilities[callbackId];\n                                if (!capability) {\n                                    throw new Error(`Cannot resolve callback ${callbackId}`);\n                                }\n                                delete this.callbackCapabilities[callbackId];\n                                if (data.callback === CallbackKind.DATA) {\n                                    capability.resolve(data.data);\n                                } else if (data.callback === CallbackKind.ERROR) {\n                                    capability.reject(wrapReason(data.reason));\n                                } else {\n                                    throw new Error(\"Unexpected callback case\");\n                                }\n                                return;\n                            }\n                            const action = this.actionHandler[data.action];\n                            if (!action) {\n                                throw new Error(`Unknown action from worker: ${data.action}`);\n                            }\n                            if (data.callbackId) {\n                                const cbSourceName = this.sourceName;\n                                const cbTargetName = data.sourceName;\n                                new Promise(function(resolve) {\n                                    resolve(action(data.data));\n                                }).then(function(result) {\n                                    comObj.postMessage({\n                                        sourceName: cbSourceName,\n                                        targetName: cbTargetName,\n                                        callback: CallbackKind.DATA,\n                                        callbackId: data.callbackId,\n                                        data: result\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName: cbSourceName,\n                                        targetName: cbTargetName,\n                                        callback: CallbackKind.ERROR,\n                                        callbackId: data.callbackId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                return;\n                            }\n                            if (data.streamId) {\n                                this.#createStreamSink(data);\n                                return;\n                            }\n                            action(data.data);\n                        };\n                        comObj.addEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                    on(actionName, handler) {\n                        const ah = this.actionHandler;\n                        if (ah[actionName]) {\n                            throw new Error(`There is already an actionName called \"${actionName}\"`);\n                        }\n                        ah[actionName] = handler;\n                    }\n                    send(actionName, data, transfers) {\n                        this.comObj.postMessage({\n                            sourceName: this.sourceName,\n                            targetName: this.targetName,\n                            action: actionName,\n                            data\n                        }, transfers);\n                    }\n                    sendWithPromise(actionName, data, transfers) {\n                        const callbackId = this.callbackId++;\n                        const capability = new _util.PromiseCapability();\n                        this.callbackCapabilities[callbackId] = capability;\n                        try {\n                            this.comObj.postMessage({\n                                sourceName: this.sourceName,\n                                targetName: this.targetName,\n                                action: actionName,\n                                callbackId,\n                                data\n                            }, transfers);\n                        } catch (ex) {\n                            capability.reject(ex);\n                        }\n                        return capability.promise;\n                    }\n                    sendWithStream(actionName, data, queueingStrategy, transfers) {\n                        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n                        return new ReadableStream({\n                            start: (controller)=>{\n                                const startCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId] = {\n                                    controller,\n                                    startCall: startCapability,\n                                    pullCall: null,\n                                    cancelCall: null,\n                                    isClosed: false\n                                };\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    action: actionName,\n                                    streamId,\n                                    data,\n                                    desiredSize: controller.desiredSize\n                                }, transfers);\n                                return startCapability.promise;\n                            },\n                            pull: (controller)=>{\n                                const pullCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId].pullCall = pullCapability;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.PULL,\n                                    streamId,\n                                    desiredSize: controller.desiredSize\n                                });\n                                return pullCapability.promise;\n                            },\n                            cancel: (reason)=>{\n                                (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n                                const cancelCapability = new _util.PromiseCapability();\n                                this.streamControllers[streamId].cancelCall = cancelCapability;\n                                this.streamControllers[streamId].isClosed = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.CANCEL,\n                                    streamId,\n                                    reason: wrapReason(reason)\n                                });\n                                return cancelCapability.promise;\n                            }\n                        }, queueingStrategy);\n                    }\n                    #createStreamSink(data) {\n                        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                        const self = this, action = this.actionHandler[data.action];\n                        const streamSink = {\n                            enqueue (chunk, size = 1, transfers) {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                const lastDesiredSize = this.desiredSize;\n                                this.desiredSize -= size;\n                                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                                    this.sinkCapability = new _util.PromiseCapability();\n                                    this.ready = this.sinkCapability.promise;\n                                }\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.ENQUEUE,\n                                    streamId,\n                                    chunk\n                                }, transfers);\n                            },\n                            close () {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.CLOSE,\n                                    streamId\n                                });\n                                delete self.streamSinks[streamId];\n                            },\n                            error (reason) {\n                                (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj.postMessage({\n                                    sourceName,\n                                    targetName,\n                                    stream: StreamKind.ERROR,\n                                    streamId,\n                                    reason: wrapReason(reason)\n                                });\n                            },\n                            sinkCapability: new _util.PromiseCapability(),\n                            onPull: null,\n                            onCancel: null,\n                            isCancelled: false,\n                            desiredSize: data.desiredSize,\n                            ready: null\n                        };\n                        streamSink.sinkCapability.resolve();\n                        streamSink.ready = streamSink.sinkCapability.promise;\n                        this.streamSinks[streamId] = streamSink;\n                        new Promise(function(resolve) {\n                            resolve(action(data.data, streamSink));\n                        }).then(function() {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.START_COMPLETE,\n                                streamId,\n                                success: true\n                            });\n                        }, function(reason) {\n                            comObj.postMessage({\n                                sourceName,\n                                targetName,\n                                stream: StreamKind.START_COMPLETE,\n                                streamId,\n                                reason: wrapReason(reason)\n                            });\n                        });\n                    }\n                    #processStreamMessage(data) {\n                        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n                        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n                        switch(data.stream){\n                            case StreamKind.START_COMPLETE:\n                                if (data.success) {\n                                    streamController.startCall.resolve();\n                                } else {\n                                    streamController.startCall.reject(wrapReason(data.reason));\n                                }\n                                break;\n                            case StreamKind.PULL_COMPLETE:\n                                if (data.success) {\n                                    streamController.pullCall.resolve();\n                                } else {\n                                    streamController.pullCall.reject(wrapReason(data.reason));\n                                }\n                                break;\n                            case StreamKind.PULL:\n                                if (!streamSink) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                    break;\n                                }\n                                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                                    streamSink.sinkCapability.resolve();\n                                }\n                                streamSink.desiredSize = data.desiredSize;\n                                new Promise(function(resolve) {\n                                    resolve(streamSink.onPull?.());\n                                }).then(function() {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.PULL_COMPLETE,\n                                        streamId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                break;\n                            case StreamKind.ENQUEUE:\n                                (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n                                if (streamController.isClosed) {\n                                    break;\n                                }\n                                streamController.controller.enqueue(data.chunk);\n                                break;\n                            case StreamKind.CLOSE:\n                                (0, _util.assert)(streamController, \"close should have stream controller\");\n                                if (streamController.isClosed) {\n                                    break;\n                                }\n                                streamController.isClosed = true;\n                                streamController.controller.close();\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.ERROR:\n                                (0, _util.assert)(streamController, \"error should have stream controller\");\n                                streamController.controller.error(wrapReason(data.reason));\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.CANCEL_COMPLETE:\n                                if (data.success) {\n                                    streamController.cancelCall.resolve();\n                                } else {\n                                    streamController.cancelCall.reject(wrapReason(data.reason));\n                                }\n                                this.#deleteStreamController(streamController, streamId);\n                                break;\n                            case StreamKind.CANCEL:\n                                if (!streamSink) {\n                                    break;\n                                }\n                                new Promise(function(resolve) {\n                                    resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n                                }).then(function() {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.CANCEL_COMPLETE,\n                                        streamId,\n                                        success: true\n                                    });\n                                }, function(reason) {\n                                    comObj.postMessage({\n                                        sourceName,\n                                        targetName,\n                                        stream: StreamKind.CANCEL_COMPLETE,\n                                        streamId,\n                                        reason: wrapReason(reason)\n                                    });\n                                });\n                                streamSink.sinkCapability.reject(wrapReason(data.reason));\n                                streamSink.isCancelled = true;\n                                delete this.streamSinks[streamId];\n                                break;\n                            default:\n                                throw new Error(\"Unexpected stream case\");\n                        }\n                    }\n                    async #deleteStreamController(streamController, streamId) {\n                        await Promise.allSettled([\n                            streamController.startCall?.promise,\n                            streamController.pullCall?.promise,\n                            streamController.cancelCall?.promise\n                        ]);\n                        delete this.streamControllers[streamId];\n                    }\n                    destroy() {\n                        this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                }\n                exports1.MessageHandler = MessageHandler;\n            /***/ },\n            /* 16 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Metadata = void 0;\n                var _util = __w_pdfjs_require__(1);\n                class Metadata {\n                    #metadataMap;\n                    #data;\n                    constructor({ parsedData, rawData }){\n                        this.#metadataMap = parsedData;\n                        this.#data = rawData;\n                    }\n                    getRaw() {\n                        return this.#data;\n                    }\n                    get(name) {\n                        return this.#metadataMap.get(name) ?? null;\n                    }\n                    getAll() {\n                        return (0, _util.objectFromMap)(this.#metadataMap);\n                    }\n                    has(name) {\n                        return this.#metadataMap.has(name);\n                    }\n                }\n                exports1.Metadata = Metadata;\n            /***/ },\n            /* 17 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.OptionalContentConfig = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _murmurhash = __w_pdfjs_require__(8);\n                const INTERNAL = Symbol(\"INTERNAL\");\n                class OptionalContentGroup {\n                    #visible;\n                    constructor(name, intent){\n                        this.#visible = true;\n                        this.name = name;\n                        this.intent = intent;\n                    }\n                    get visible() {\n                        return this.#visible;\n                    }\n                    _setVisible(internal, visible) {\n                        if (internal !== INTERNAL) {\n                            (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n                        }\n                        this.#visible = visible;\n                    }\n                }\n                class OptionalContentConfig {\n                    #cachedGetHash;\n                    #groups;\n                    #initialHash;\n                    #order;\n                    constructor(data){\n                        this.#cachedGetHash = null;\n                        this.#groups = new Map();\n                        this.#initialHash = null;\n                        this.#order = null;\n                        this.name = null;\n                        this.creator = null;\n                        if (data === null) {\n                            return;\n                        }\n                        this.name = data.name;\n                        this.creator = data.creator;\n                        this.#order = data.order;\n                        for (const group of data.groups){\n                            this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n                        }\n                        if (data.baseState === \"OFF\") {\n                            for (const group of this.#groups.values()){\n                                group._setVisible(INTERNAL, false);\n                            }\n                        }\n                        for (const on of data.on){\n                            this.#groups.get(on)._setVisible(INTERNAL, true);\n                        }\n                        for (const off of data.off){\n                            this.#groups.get(off)._setVisible(INTERNAL, false);\n                        }\n                        this.#initialHash = this.getHash();\n                    }\n                    #evaluateVisibilityExpression(array) {\n                        const length = array.length;\n                        if (length < 2) {\n                            return true;\n                        }\n                        const operator = array[0];\n                        for(let i = 1; i < length; i++){\n                            const element = array[i];\n                            let state;\n                            if (Array.isArray(element)) {\n                                state = this.#evaluateVisibilityExpression(element);\n                            } else if (this.#groups.has(element)) {\n                                state = this.#groups.get(element).visible;\n                            } else {\n                                (0, _util.warn)(`Optional content group not found: ${element}`);\n                                return true;\n                            }\n                            switch(operator){\n                                case \"And\":\n                                    if (!state) {\n                                        return false;\n                                    }\n                                    break;\n                                case \"Or\":\n                                    if (state) {\n                                        return true;\n                                    }\n                                    break;\n                                case \"Not\":\n                                    return !state;\n                                default:\n                                    return true;\n                            }\n                        }\n                        return operator === \"And\";\n                    }\n                    isVisible(group) {\n                        if (this.#groups.size === 0) {\n                            return true;\n                        }\n                        if (!group) {\n                            (0, _util.warn)(\"Optional content group not defined.\");\n                            return true;\n                        }\n                        if (group.type === \"OCG\") {\n                            if (!this.#groups.has(group.id)) {\n                                (0, _util.warn)(`Optional content group not found: ${group.id}`);\n                                return true;\n                            }\n                            return this.#groups.get(group.id).visible;\n                        } else if (group.type === \"OCMD\") {\n                            if (group.expression) {\n                                return this.#evaluateVisibilityExpression(group.expression);\n                            }\n                            if (!group.policy || group.policy === \"AnyOn\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group.policy === \"AllOn\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            } else if (group.policy === \"AnyOff\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group.policy === \"AllOff\") {\n                                for (const id of group.ids){\n                                    if (!this.#groups.has(id)) {\n                                        (0, _util.warn)(`Optional content group not found: ${id}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                            (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n                            return true;\n                        }\n                        (0, _util.warn)(`Unknown group type ${group.type}.`);\n                        return true;\n                    }\n                    setVisibility(id, visible = true) {\n                        if (!this.#groups.has(id)) {\n                            (0, _util.warn)(`Optional content group not found: ${id}`);\n                            return;\n                        }\n                        this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n                        this.#cachedGetHash = null;\n                    }\n                    get hasInitialVisibility() {\n                        return this.#initialHash === null || this.getHash() === this.#initialHash;\n                    }\n                    getOrder() {\n                        if (!this.#groups.size) {\n                            return null;\n                        }\n                        if (this.#order) {\n                            return this.#order.slice();\n                        }\n                        return [\n                            ...this.#groups.keys()\n                        ];\n                    }\n                    getGroups() {\n                        return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n                    }\n                    getGroup(id) {\n                        return this.#groups.get(id) || null;\n                    }\n                    getHash() {\n                        if (this.#cachedGetHash !== null) {\n                            return this.#cachedGetHash;\n                        }\n                        const hash = new _murmurhash.MurmurHash3_64();\n                        for (const [id, group] of this.#groups){\n                            hash.update(`${id}:${group.visible}`);\n                        }\n                        return this.#cachedGetHash = hash.hexdigest();\n                    }\n                }\n                exports1.OptionalContentConfig = OptionalContentConfig;\n            /***/ },\n            /* 18 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFDataTransportStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                class PDFDataTransportStream {\n                    constructor({ length, initialData, progressiveDone = false, contentDispositionFilename = null, disableRange = false, disableStream = false }, pdfDataRangeTransport){\n                        (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n                        this._queuedChunks = [];\n                        this._progressiveDone = progressiveDone;\n                        this._contentDispositionFilename = contentDispositionFilename;\n                        if (initialData?.length > 0) {\n                            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n                            this._queuedChunks.push(buffer);\n                        }\n                        this._pdfDataRangeTransport = pdfDataRangeTransport;\n                        this._isStreamingSupported = !disableStream;\n                        this._isRangeSupported = !disableRange;\n                        this._contentLength = length;\n                        this._fullRequestReader = null;\n                        this._rangeReaders = [];\n                        this._pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n                            this._onReceiveData({\n                                begin,\n                                chunk\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n                            this._onProgress({\n                                loaded,\n                                total\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n                            this._onReceiveData({\n                                chunk\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n                            this._onProgressiveDone();\n                        });\n                        this._pdfDataRangeTransport.transportReady();\n                    }\n                    _onReceiveData({ begin, chunk }) {\n                        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n                        if (begin === undefined) {\n                            if (this._fullRequestReader) {\n                                this._fullRequestReader._enqueue(buffer);\n                            } else {\n                                this._queuedChunks.push(buffer);\n                            }\n                        } else {\n                            const found = this._rangeReaders.some(function(rangeReader) {\n                                if (rangeReader._begin !== begin) {\n                                    return false;\n                                }\n                                rangeReader._enqueue(buffer);\n                                return true;\n                            });\n                            (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n                        }\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    _onProgress(evt) {\n                        if (evt.total === undefined) {\n                            this._rangeReaders[0]?.onProgress?.({\n                                loaded: evt.loaded\n                            });\n                        } else {\n                            this._fullRequestReader?.onProgress?.({\n                                loaded: evt.loaded,\n                                total: evt.total\n                            });\n                        }\n                    }\n                    _onProgressiveDone() {\n                        this._fullRequestReader?.progressiveDone();\n                        this._progressiveDone = true;\n                    }\n                    _removeRangeReader(reader) {\n                        const i = this._rangeReaders.indexOf(reader);\n                        if (i >= 0) {\n                            this._rangeReaders.splice(i, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n                        const queuedChunks = this._queuedChunks;\n                        this._queuedChunks = null;\n                        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n                    }\n                    getRangeReader(begin, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n                        this._pdfDataRangeTransport.requestDataRange(begin, end);\n                        this._rangeReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                        this._pdfDataRangeTransport.abort();\n                    }\n                }\n                exports1.PDFDataTransportStream = PDFDataTransportStream;\n                class PDFDataTransportStreamReader {\n                    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n                        this._stream = stream;\n                        this._done = progressiveDone || false;\n                        this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n                        this._queuedChunks = queuedChunks || [];\n                        this._loaded = 0;\n                        for (const chunk of this._queuedChunks){\n                            this._loaded += chunk.byteLength;\n                        }\n                        this._requests = [];\n                        this._headersReady = Promise.resolve();\n                        stream._fullRequestReader = this;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length > 0) {\n                            const requestCapability = this._requests.shift();\n                            requestCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunks.push(chunk);\n                        }\n                        this._loaded += chunk.byteLength;\n                    }\n                    get headersReady() {\n                        return this._headersReady;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._stream._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._stream._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._stream._contentLength;\n                    }\n                    async read() {\n                        if (this._queuedChunks.length > 0) {\n                            const chunk = this._queuedChunks.shift();\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    progressiveDone() {\n                        if (this._done) {\n                            return;\n                        }\n                        this._done = true;\n                    }\n                }\n                class PDFDataTransportStreamRangeReader {\n                    constructor(stream, begin, end){\n                        this._stream = stream;\n                        this._begin = begin;\n                        this._end = end;\n                        this._queuedChunk = null;\n                        this._requests = [];\n                        this._done = false;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length === 0) {\n                            this._queuedChunk = chunk;\n                        } else {\n                            const requestsCapability = this._requests.shift();\n                            requestsCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                            for (const requestCapability of this._requests){\n                                requestCapability.resolve({\n                                    value: undefined,\n                                    done: true\n                                });\n                            }\n                            this._requests.length = 0;\n                        }\n                        this._done = true;\n                        this._stream._removeRangeReader(this);\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._queuedChunk) {\n                            const chunk = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._stream._removeRangeReader(this);\n                    }\n                }\n            /***/ },\n            /* 19 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFFetchStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                function createFetchOptions(headers, withCredentials, abortController) {\n                    return {\n                        method: \"GET\",\n                        headers,\n                        signal: abortController.signal,\n                        mode: \"cors\",\n                        credentials: withCredentials ? \"include\" : \"same-origin\",\n                        redirect: \"follow\"\n                    };\n                }\n                function createHeaders(httpHeaders) {\n                    const headers = new Headers();\n                    for(const property in httpHeaders){\n                        const value = httpHeaders[property];\n                        if (value === undefined) {\n                            continue;\n                        }\n                        headers.append(property, value);\n                    }\n                    return headers;\n                }\n                function getArrayBuffer(val) {\n                    if (val instanceof Uint8Array) {\n                        return val.buffer;\n                    }\n                    if (val instanceof ArrayBuffer) {\n                        return val;\n                    }\n                    (0, _util.warn)(`getArrayBuffer - unexpected data format: ${val}`);\n                    return new Uint8Array(val).buffer;\n                }\n                class PDFFetchStream {\n                    constructor(source){\n                        this.source = source;\n                        this.isHttp = /^https?:/i.test(source.url);\n                        this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFFetchStreamReader(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n                        this._rangeRequestReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFFetchStream = PDFFetchStream;\n                class PDFFetchStreamReader {\n                    constructor(stream){\n                        this._stream = stream;\n                        this._reader = null;\n                        this._loaded = 0;\n                        this._filename = null;\n                        const source = stream.source;\n                        this._withCredentials = source.withCredentials || false;\n                        this._contentLength = source.length;\n                        this._headersCapability = new _util.PromiseCapability();\n                        this._disableRange = source.disableRange || false;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._abortController = new AbortController();\n                        this._isStreamingSupported = !source.disableStream;\n                        this._isRangeSupported = !source.disableRange;\n                        this._headers = createHeaders(this._stream.httpHeaders);\n                        const url = source.url;\n                        fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n                            }\n                            this._reader = response.body.getReader();\n                            this._headersCapability.resolve();\n                            const getResponseHeader = (name)=>{\n                                return response.headers.get(name);\n                            };\n                            const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                                getResponseHeader,\n                                isHttp: this._stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests;\n                            this._contentLength = suggestedLength || this._contentLength;\n                            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                            if (!this._isStreamingSupported && this._isRangeSupported) {\n                                this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n                            }\n                        }).catch(this._headersCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._headersCapability.promise;\n                        const { value, done } = await this._reader.read();\n                        if (done) {\n                            return {\n                                value,\n                                done\n                            };\n                        }\n                        this._loaded += value.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        return {\n                            value: getArrayBuffer(value),\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        this._reader?.cancel(reason);\n                        this._abortController.abort();\n                    }\n                }\n                class PDFFetchStreamRangeReader {\n                    constructor(stream, begin, end){\n                        this._stream = stream;\n                        this._reader = null;\n                        this._loaded = 0;\n                        const source = stream.source;\n                        this._withCredentials = source.withCredentials || false;\n                        this._readCapability = new _util.PromiseCapability();\n                        this._isStreamingSupported = !source.disableStream;\n                        this._abortController = new AbortController();\n                        this._headers = createHeaders(this._stream.httpHeaders);\n                        this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n                        const url = source.url;\n                        fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response)=>{\n                            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n                                throw (0, _network_utils.createResponseStatusError)(response.status, url);\n                            }\n                            this._readCapability.resolve();\n                            this._reader = response.body.getReader();\n                        }).catch(this._readCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        const { value, done } = await this._reader.read();\n                        if (done) {\n                            return {\n                                value,\n                                done\n                            };\n                        }\n                        this._loaded += value.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        return {\n                            value: getArrayBuffer(value),\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        this._reader?.cancel(reason);\n                        this._abortController.abort();\n                    }\n                }\n            /***/ },\n            /* 20 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.createResponseStatusError = createResponseStatusError;\n                exports1.extractFilenameFromHeader = extractFilenameFromHeader;\n                exports1.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\n                exports1.validateResponseStatus = validateResponseStatus;\n                var _util = __w_pdfjs_require__(1);\n                var _content_disposition = __w_pdfjs_require__(21);\n                var _display_utils = __w_pdfjs_require__(6);\n                function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) {\n                    const returnValues = {\n                        allowRangeRequests: false,\n                        suggestedLength: undefined\n                    };\n                    const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n                    if (!Number.isInteger(length)) {\n                        return returnValues;\n                    }\n                    returnValues.suggestedLength = length;\n                    if (length <= 2 * rangeChunkSize) {\n                        return returnValues;\n                    }\n                    if (disableRange || !isHttp) {\n                        return returnValues;\n                    }\n                    if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n                        return returnValues;\n                    }\n                    const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n                    if (contentEncoding !== \"identity\") {\n                        return returnValues;\n                    }\n                    returnValues.allowRangeRequests = true;\n                    return returnValues;\n                }\n                function extractFilenameFromHeader(getResponseHeader) {\n                    const contentDisposition = getResponseHeader(\"Content-Disposition\");\n                    if (contentDisposition) {\n                        let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n                        if (filename.includes(\"%\")) {\n                            try {\n                                filename = decodeURIComponent(filename);\n                            } catch  {}\n                        }\n                        if ((0, _display_utils.isPdfFile)(filename)) {\n                            return filename;\n                        }\n                    }\n                    return null;\n                }\n                function createResponseStatusError(status, url) {\n                    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n                        return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n                    }\n                    return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n                }\n                function validateResponseStatus(status) {\n                    return status === 200 || status === 206;\n                }\n            /***/ },\n            /* 21 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n                var _util = __w_pdfjs_require__(1);\n                function getFilenameFromContentDispositionHeader(contentDisposition) {\n                    let needsEncodingFixup = true;\n                    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n                    if (tmp) {\n                        tmp = tmp[1];\n                        let filename = rfc2616unquote(tmp);\n                        filename = unescape(filename);\n                        filename = rfc5987decode(filename);\n                        filename = rfc2047decode(filename);\n                        return fixupEncoding(filename);\n                    }\n                    tmp = rfc2231getparam(contentDisposition);\n                    if (tmp) {\n                        const filename = rfc2047decode(tmp);\n                        return fixupEncoding(filename);\n                    }\n                    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n                    if (tmp) {\n                        tmp = tmp[1];\n                        let filename = rfc2616unquote(tmp);\n                        filename = rfc2047decode(filename);\n                        return fixupEncoding(filename);\n                    }\n                    function toParamRegExp(attributePattern, flags) {\n                        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n                    }\n                    function textdecode(encoding, value) {\n                        if (encoding) {\n                            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                                return value;\n                            }\n                            try {\n                                const decoder = new TextDecoder(encoding, {\n                                    fatal: true\n                                });\n                                const buffer = (0, _util.stringToBytes)(value);\n                                value = decoder.decode(buffer);\n                                needsEncodingFixup = false;\n                            } catch  {}\n                        }\n                        return value;\n                    }\n                    function fixupEncoding(value) {\n                        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n                            value = textdecode(\"utf-8\", value);\n                            if (needsEncodingFixup) {\n                                value = textdecode(\"iso-8859-1\", value);\n                            }\n                        }\n                        return value;\n                    }\n                    function rfc2231getparam(contentDispositionStr) {\n                        const matches = [];\n                        let match;\n                        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n                        while((match = iter.exec(contentDispositionStr)) !== null){\n                            let [, n, quot, part] = match;\n                            n = parseInt(n, 10);\n                            if (n in matches) {\n                                if (n === 0) {\n                                    break;\n                                }\n                                continue;\n                            }\n                            matches[n] = [\n                                quot,\n                                part\n                            ];\n                        }\n                        const parts = [];\n                        for(let n = 0; n < matches.length; ++n){\n                            if (!(n in matches)) {\n                                break;\n                            }\n                            let [quot, part] = matches[n];\n                            part = rfc2616unquote(part);\n                            if (quot) {\n                                part = unescape(part);\n                                if (n === 0) {\n                                    part = rfc5987decode(part);\n                                }\n                            }\n                            parts.push(part);\n                        }\n                        return parts.join(\"\");\n                    }\n                    function rfc2616unquote(value) {\n                        if (value.startsWith('\"')) {\n                            const parts = value.slice(1).split('\\\\\"');\n                            for(let i = 0; i < parts.length; ++i){\n                                const quotindex = parts[i].indexOf('\"');\n                                if (quotindex !== -1) {\n                                    parts[i] = parts[i].slice(0, quotindex);\n                                    parts.length = i + 1;\n                                }\n                                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n                            }\n                            value = parts.join('\"');\n                        }\n                        return value;\n                    }\n                    function rfc5987decode(extvalue) {\n                        const encodingend = extvalue.indexOf(\"'\");\n                        if (encodingend === -1) {\n                            return extvalue;\n                        }\n                        const encoding = extvalue.slice(0, encodingend);\n                        const langvalue = extvalue.slice(encodingend + 1);\n                        const value = langvalue.replace(/^[^']*'/, \"\");\n                        return textdecode(encoding, value);\n                    }\n                    function rfc2047decode(value) {\n                        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n                            return value;\n                        }\n                        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n                            if (encoding === \"q\" || encoding === \"Q\") {\n                                text = text.replaceAll(\"_\", \" \");\n                                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                                    return String.fromCharCode(parseInt(hex, 16));\n                                });\n                                return textdecode(charset, text);\n                            }\n                            try {\n                                text = atob(text);\n                            } catch  {}\n                            return textdecode(charset, text);\n                        });\n                    }\n                    return \"\";\n                }\n            /***/ },\n            /* 22 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNetworkStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                const OK_RESPONSE = 200;\n                const PARTIAL_CONTENT_RESPONSE = 206;\n                function getArrayBuffer(xhr) {\n                    const data = xhr.response;\n                    if (typeof data !== \"string\") {\n                        return data;\n                    }\n                    return (0, _util.stringToBytes)(data).buffer;\n                }\n                class NetworkManager {\n                    constructor(url, args = {}){\n                        this.url = url;\n                        this.isHttp = /^https?:/i.test(url);\n                        this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n                        this.withCredentials = args.withCredentials || false;\n                        this.currXhrId = 0;\n                        this.pendingRequests = Object.create(null);\n                    }\n                    requestRange(begin, end, listeners) {\n                        const args = {\n                            begin,\n                            end\n                        };\n                        for(const prop in listeners){\n                            args[prop] = listeners[prop];\n                        }\n                        return this.request(args);\n                    }\n                    requestFull(listeners) {\n                        return this.request(listeners);\n                    }\n                    request(args) {\n                        const xhr = new XMLHttpRequest();\n                        const xhrId = this.currXhrId++;\n                        const pendingRequest = this.pendingRequests[xhrId] = {\n                            xhr\n                        };\n                        xhr.open(\"GET\", this.url);\n                        xhr.withCredentials = this.withCredentials;\n                        for(const property in this.httpHeaders){\n                            const value = this.httpHeaders[property];\n                            if (value === undefined) {\n                                continue;\n                            }\n                            xhr.setRequestHeader(property, value);\n                        }\n                        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n                            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n                            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n                        } else {\n                            pendingRequest.expectedStatus = OK_RESPONSE;\n                        }\n                        xhr.responseType = \"arraybuffer\";\n                        if (args.onError) {\n                            xhr.onerror = function(evt) {\n                                args.onError(xhr.status);\n                            };\n                        }\n                        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n                        xhr.onprogress = this.onProgress.bind(this, xhrId);\n                        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n                        pendingRequest.onDone = args.onDone;\n                        pendingRequest.onError = args.onError;\n                        pendingRequest.onProgress = args.onProgress;\n                        xhr.send(null);\n                        return xhrId;\n                    }\n                    onProgress(xhrId, evt) {\n                        const pendingRequest = this.pendingRequests[xhrId];\n                        if (!pendingRequest) {\n                            return;\n                        }\n                        pendingRequest.onProgress?.(evt);\n                    }\n                    onStateChange(xhrId, evt) {\n                        const pendingRequest = this.pendingRequests[xhrId];\n                        if (!pendingRequest) {\n                            return;\n                        }\n                        const xhr = pendingRequest.xhr;\n                        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n                            pendingRequest.onHeadersReceived();\n                            delete pendingRequest.onHeadersReceived;\n                        }\n                        if (xhr.readyState !== 4) {\n                            return;\n                        }\n                        if (!(xhrId in this.pendingRequests)) {\n                            return;\n                        }\n                        delete this.pendingRequests[xhrId];\n                        if (xhr.status === 0 && this.isHttp) {\n                            pendingRequest.onError?.(xhr.status);\n                            return;\n                        }\n                        const xhrStatus = xhr.status || OK_RESPONSE;\n                        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n                        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n                            pendingRequest.onError?.(xhr.status);\n                            return;\n                        }\n                        const chunk = getArrayBuffer(xhr);\n                        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n                            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n                            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n                            pendingRequest.onDone({\n                                begin: parseInt(matches[1], 10),\n                                chunk\n                            });\n                        } else if (chunk) {\n                            pendingRequest.onDone({\n                                begin: 0,\n                                chunk\n                            });\n                        } else {\n                            pendingRequest.onError?.(xhr.status);\n                        }\n                    }\n                    getRequestXhr(xhrId) {\n                        return this.pendingRequests[xhrId].xhr;\n                    }\n                    isPendingRequest(xhrId) {\n                        return xhrId in this.pendingRequests;\n                    }\n                    abortRequest(xhrId) {\n                        const xhr = this.pendingRequests[xhrId].xhr;\n                        delete this.pendingRequests[xhrId];\n                        xhr.abort();\n                    }\n                }\n                class PDFNetworkStream {\n                    constructor(source){\n                        this._source = source;\n                        this._manager = new NetworkManager(source.url, {\n                            httpHeaders: source.httpHeaders,\n                            withCredentials: source.withCredentials\n                        });\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    _onRangeRequestReaderClosed(reader) {\n                        const i = this._rangeRequestReaders.indexOf(reader);\n                        if (i >= 0) {\n                            this._rangeRequestReaders.splice(i, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin, end) {\n                        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n                        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n                        this._rangeRequestReaders.push(reader);\n                        return reader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFNetworkStream = PDFNetworkStream;\n                class PDFNetworkStreamFullRequestReader {\n                    constructor(manager, source){\n                        this._manager = manager;\n                        const args = {\n                            onHeadersReceived: this._onHeadersReceived.bind(this),\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = source.url;\n                        this._fullRequestId = manager.requestFull(args);\n                        this._headersReceivedCapability = new _util.PromiseCapability();\n                        this._disableRange = source.disableRange || false;\n                        this._contentLength = source.length;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = false;\n                        this._isRangeSupported = false;\n                        this._cachedChunks = [];\n                        this._requests = [];\n                        this._done = false;\n                        this._storedError = undefined;\n                        this._filename = null;\n                        this.onProgress = null;\n                    }\n                    _onHeadersReceived() {\n                        const fullRequestXhrId = this._fullRequestId;\n                        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n                        const getResponseHeader = (name)=>{\n                            return fullRequestXhr.getResponseHeader(name);\n                        };\n                        const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                            getResponseHeader,\n                            isHttp: this._manager.isHttp,\n                            rangeChunkSize: this._rangeChunkSize,\n                            disableRange: this._disableRange\n                        });\n                        if (allowRangeRequests) {\n                            this._isRangeSupported = true;\n                        }\n                        this._contentLength = suggestedLength || this._contentLength;\n                        this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                        if (this._isRangeSupported) {\n                            this._manager.abortRequest(fullRequestXhrId);\n                        }\n                        this._headersReceivedCapability.resolve();\n                    }\n                    _onDone(data) {\n                        if (data) {\n                            if (this._requests.length > 0) {\n                                const requestCapability = this._requests.shift();\n                                requestCapability.resolve({\n                                    value: data.chunk,\n                                    done: false\n                                });\n                            } else {\n                                this._cachedChunks.push(data.chunk);\n                            }\n                        }\n                        this._done = true;\n                        if (this._cachedChunks.length > 0) {\n                            return;\n                        }\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    _onError(status) {\n                        this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n                        this._headersReceivedCapability.reject(this._storedError);\n                        for (const requestCapability of this._requests){\n                            requestCapability.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._cachedChunks.length = 0;\n                    }\n                    _onProgress(evt) {\n                        this.onProgress?.({\n                            loaded: evt.loaded,\n                            total: evt.lengthComputable ? evt.total : this._contentLength\n                        });\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get headersReady() {\n                        return this._headersReceivedCapability.promise;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._cachedChunks.length > 0) {\n                            const chunk = this._cachedChunks.shift();\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        this._headersReceivedCapability.reject(reason);\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._fullRequestId)) {\n                            this._manager.abortRequest(this._fullRequestId);\n                        }\n                        this._fullRequestReader = null;\n                    }\n                }\n                class PDFNetworkStreamRangeRequestReader {\n                    constructor(manager, begin, end){\n                        this._manager = manager;\n                        const args = {\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = manager.url;\n                        this._requestId = manager.requestRange(begin, end, args);\n                        this._requests = [];\n                        this._queuedChunk = null;\n                        this._done = false;\n                        this._storedError = undefined;\n                        this.onProgress = null;\n                        this.onClosed = null;\n                    }\n                    _close() {\n                        this.onClosed?.(this);\n                    }\n                    _onDone(data) {\n                        const chunk = data.chunk;\n                        if (this._requests.length > 0) {\n                            const requestCapability = this._requests.shift();\n                            requestCapability.resolve({\n                                value: chunk,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunk = chunk;\n                        }\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._close();\n                    }\n                    _onError(status) {\n                        this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n                        for (const requestCapability of this._requests){\n                            requestCapability.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._queuedChunk = null;\n                    }\n                    _onProgress(evt) {\n                        if (!this.isStreamingSupported) {\n                            this.onProgress?.({\n                                loaded: evt.loaded\n                            });\n                        }\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._queuedChunk !== null) {\n                            const chunk = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability = new _util.PromiseCapability();\n                        this._requests.push(requestCapability);\n                        return requestCapability.promise;\n                    }\n                    cancel(reason) {\n                        this._done = true;\n                        for (const requestCapability of this._requests){\n                            requestCapability.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._requestId)) {\n                            this._manager.abortRequest(this._requestId);\n                        }\n                        this._close();\n                    }\n                }\n            /***/ },\n            /* 23 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNodeStream = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _network_utils = __w_pdfjs_require__(20);\n                ;\n                const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n                function parseUrl(sourceUrl) {\n                    const url = __webpack_require__(/*! url */ \"url\");\n                    const parsedUrl = url.parse(sourceUrl);\n                    if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n                        return parsedUrl;\n                    }\n                    if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n                        return url.parse(`file:///${sourceUrl}`);\n                    }\n                    if (!parsedUrl.host) {\n                        parsedUrl.protocol = \"file:\";\n                    }\n                    return parsedUrl;\n                }\n                class PDFNodeStream {\n                    constructor(source){\n                        this.source = source;\n                        this.url = parseUrl(source.url);\n                        this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n                        this.isFsUrl = this.url.protocol === \"file:\";\n                        this.httpHeaders = this.isHttp && source.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(start, end) {\n                        if (end <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n                        this._rangeRequestReaders.push(rangeReader);\n                        return rangeReader;\n                    }\n                    cancelAllRequests(reason) {\n                        this._fullRequestReader?.cancel(reason);\n                        for (const reader of this._rangeRequestReaders.slice(0)){\n                            reader.cancel(reason);\n                        }\n                    }\n                }\n                exports1.PDFNodeStream = PDFNodeStream;\n                class BaseFullReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        const source = stream.source;\n                        this._contentLength = source.length;\n                        this._loaded = 0;\n                        this._filename = null;\n                        this._disableRange = source.disableRange || false;\n                        this._rangeChunkSize = source.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = !source.disableStream;\n                        this._isRangeSupported = !source.disableRange;\n                        this._readableStream = null;\n                        this._readCapability = new _util.PromiseCapability();\n                        this._headersCapability = new _util.PromiseCapability();\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _util.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (!this._isStreamingSupported && this._isRangeSupported) {\n                            this._error(new _util.AbortException(\"streaming is disabled\"));\n                        }\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                class BaseRangeReader {\n                    constructor(stream){\n                        this._url = stream.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        this._loaded = 0;\n                        this._readableStream = null;\n                        this._readCapability = new _util.PromiseCapability();\n                        const source = stream.source;\n                        this._isStreamingSupported = !source.disableStream;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk = this._readableStream.read();\n                        if (chunk === null) {\n                            this._readCapability = new _util.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk.length;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        const buffer = new Uint8Array(chunk).buffer;\n                        return {\n                            value: buffer,\n                            done: false\n                        };\n                    }\n                    cancel(reason) {\n                        if (!this._readableStream) {\n                            this._error(reason);\n                            return;\n                        }\n                        this._readableStream.destroy(reason);\n                    }\n                    _error(reason) {\n                        this._storedError = reason;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream) {\n                        this._readableStream = readableStream;\n                        readableStream.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"end\", ()=>{\n                            readableStream.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream.on(\"error\", (reason)=>{\n                            this._error(reason);\n                        });\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                function createRequestOptions(parsedUrl, headers) {\n                    return {\n                        protocol: parsedUrl.protocol,\n                        auth: parsedUrl.auth,\n                        host: parsedUrl.hostname,\n                        port: parsedUrl.port,\n                        path: parsedUrl.path,\n                        method: \"GET\",\n                        headers\n                    };\n                }\n                class PDFNodeStreamFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._headersCapability.resolve();\n                            this._setReadableStream(response);\n                            const getResponseHeader = (name)=>{\n                                return this._readableStream.headers[name.toLowerCase()];\n                            };\n                            const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({\n                                getResponseHeader,\n                                isHttp: stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests;\n                            this._contentLength = suggestedLength || this._contentLength;\n                            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http = __webpack_require__(/*! http */ \"http\");\n                            this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        } else {\n                            const https = __webpack_require__(/*! https */ \"https\");\n                            this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                            this._headersCapability.reject(reason);\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        this._httpHeaders = {};\n                        for(const property in stream.httpHeaders){\n                            const value = stream.httpHeaders[property];\n                            if (value === undefined) {\n                                continue;\n                            }\n                            this._httpHeaders[property] = value;\n                        }\n                        this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n                        const handleResponse = (response)=>{\n                            if (response.statusCode === 404) {\n                                const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error;\n                                return;\n                            }\n                            this._setReadableStream(response);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http = __webpack_require__(/*! http */ \"http\");\n                            this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        } else {\n                            const https = __webpack_require__(/*! https */ \"https\");\n                            this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n                        }\n                        this._request.on(\"error\", (reason)=>{\n                            this._storedError = reason;\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamFsFullReader extends BaseFullReader {\n                    constructor(stream){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        fs.lstat(path, (error, stat)=>{\n                            if (error) {\n                                if (error.code === \"ENOENT\") {\n                                    error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n                                }\n                                this._storedError = error;\n                                this._headersCapability.reject(error);\n                                return;\n                            }\n                            this._contentLength = stat.size;\n                            this._setReadableStream(fs.createReadStream(path));\n                            this._headersCapability.resolve();\n                        });\n                    }\n                }\n                class PDFNodeStreamFsRangeReader extends BaseRangeReader {\n                    constructor(stream, start, end){\n                        super(stream);\n                        let path = decodeURIComponent(this._url.path);\n                        if (fileUriRegex.test(this._url.href)) {\n                            path = path.replace(/^\\//, \"\");\n                        }\n                        const fs = __webpack_require__(/*! fs */ \"fs\");\n                        this._setReadableStream(fs.createReadStream(path, {\n                            start,\n                            end: end - 1\n                        }));\n                    }\n                }\n            /***/ },\n            /* 24 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SVGGraphics = void 0;\n                var _display_utils = __w_pdfjs_require__(6);\n                var _util = __w_pdfjs_require__(1);\n                ;\n                const SVG_DEFAULTS = {\n                    fontStyle: \"normal\",\n                    fontWeight: \"normal\",\n                    fillColor: \"#000000\"\n                };\n                const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n                const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n                const LINE_CAP_STYLES = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const createObjectURL = function(data, contentType = \"\", forceDataSchema = false) {\n                    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n                        return URL.createObjectURL(new Blob([\n                            data\n                        ], {\n                            type: contentType\n                        }));\n                    }\n                    const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n                    let buffer = `data:${contentType};base64,`;\n                    for(let i = 0, ii = data.length; i < ii; i += 3){\n                        const b1 = data[i] & 0xff;\n                        const b2 = data[i + 1] & 0xff;\n                        const b3 = data[i + 2] & 0xff;\n                        const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;\n                        const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n                        const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n                        buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n                    }\n                    return buffer;\n                };\n                const convertImgDataToPng = function() {\n                    const PNG_HEADER = new Uint8Array([\n                        0x89,\n                        0x50,\n                        0x4e,\n                        0x47,\n                        0x0d,\n                        0x0a,\n                        0x1a,\n                        0x0a\n                    ]);\n                    const CHUNK_WRAPPER_SIZE = 12;\n                    const crcTable = new Int32Array(256);\n                    for(let i = 0; i < 256; i++){\n                        let c = i;\n                        for(let h = 0; h < 8; h++){\n                            c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;\n                        }\n                        crcTable[i] = c;\n                    }\n                    function crc32(data, start, end) {\n                        let crc = -1;\n                        for(let i = start; i < end; i++){\n                            const a = (crc ^ data[i]) & 0xff;\n                            const b = crcTable[a];\n                            crc = crc >>> 8 ^ b;\n                        }\n                        return crc ^ -1;\n                    }\n                    function writePngChunk(type, body, data, offset) {\n                        let p = offset;\n                        const len = body.length;\n                        data[p] = len >> 24 & 0xff;\n                        data[p + 1] = len >> 16 & 0xff;\n                        data[p + 2] = len >> 8 & 0xff;\n                        data[p + 3] = len & 0xff;\n                        p += 4;\n                        data[p] = type.charCodeAt(0) & 0xff;\n                        data[p + 1] = type.charCodeAt(1) & 0xff;\n                        data[p + 2] = type.charCodeAt(2) & 0xff;\n                        data[p + 3] = type.charCodeAt(3) & 0xff;\n                        p += 4;\n                        data.set(body, p);\n                        p += body.length;\n                        const crc = crc32(data, offset + 4, p);\n                        data[p] = crc >> 24 & 0xff;\n                        data[p + 1] = crc >> 16 & 0xff;\n                        data[p + 2] = crc >> 8 & 0xff;\n                        data[p + 3] = crc & 0xff;\n                    }\n                    function adler32(data, start, end) {\n                        let a = 1;\n                        let b = 0;\n                        for(let i = start; i < end; ++i){\n                            a = (a + (data[i] & 0xff)) % 65521;\n                            b = (b + a) % 65521;\n                        }\n                        return b << 16 | a;\n                    }\n                    function deflateSync(literals) {\n                        if (!_util.isNodeJS) {\n                            return deflateSyncUncompressed(literals);\n                        }\n                        try {\n                            const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);\n                            const output = (__webpack_require__(/*! zlib */ \"zlib\").deflateSync)(input, {\n                                level: 9\n                            });\n                            return output instanceof Uint8Array ? output : new Uint8Array(output);\n                        } catch (e) {\n                            (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n                        }\n                        return deflateSyncUncompressed(literals);\n                    }\n                    function deflateSyncUncompressed(literals) {\n                        let len = literals.length;\n                        const maxBlockLength = 0xffff;\n                        const deflateBlocks = Math.ceil(len / maxBlockLength);\n                        const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n                        let pi = 0;\n                        idat[pi++] = 0x78;\n                        idat[pi++] = 0x9c;\n                        let pos = 0;\n                        while(len > maxBlockLength){\n                            idat[pi++] = 0x00;\n                            idat[pi++] = 0xff;\n                            idat[pi++] = 0xff;\n                            idat[pi++] = 0x00;\n                            idat[pi++] = 0x00;\n                            idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n                            pi += maxBlockLength;\n                            pos += maxBlockLength;\n                            len -= maxBlockLength;\n                        }\n                        idat[pi++] = 0x01;\n                        idat[pi++] = len & 0xff;\n                        idat[pi++] = len >> 8 & 0xff;\n                        idat[pi++] = ~len & 0xffff & 0xff;\n                        idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n                        idat.set(literals.subarray(pos), pi);\n                        pi += literals.length - pos;\n                        const adler = adler32(literals, 0, literals.length);\n                        idat[pi++] = adler >> 24 & 0xff;\n                        idat[pi++] = adler >> 16 & 0xff;\n                        idat[pi++] = adler >> 8 & 0xff;\n                        idat[pi++] = adler & 0xff;\n                        return idat;\n                    }\n                    function encode(imgData, kind, forceDataSchema, isMask) {\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        let bitDepth, colorType, lineSize;\n                        const bytes = imgData.data;\n                        switch(kind){\n                            case _util.ImageKind.GRAYSCALE_1BPP:\n                                colorType = 0;\n                                bitDepth = 1;\n                                lineSize = width + 7 >> 3;\n                                break;\n                            case _util.ImageKind.RGB_24BPP:\n                                colorType = 2;\n                                bitDepth = 8;\n                                lineSize = width * 3;\n                                break;\n                            case _util.ImageKind.RGBA_32BPP:\n                                colorType = 6;\n                                bitDepth = 8;\n                                lineSize = width * 4;\n                                break;\n                            default:\n                                throw new Error(\"invalid format\");\n                        }\n                        const literals = new Uint8Array((1 + lineSize) * height);\n                        let offsetLiterals = 0, offsetBytes = 0;\n                        for(let y = 0; y < height; ++y){\n                            literals[offsetLiterals++] = 0;\n                            literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n                            offsetBytes += lineSize;\n                            offsetLiterals += lineSize;\n                        }\n                        if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n                            offsetLiterals = 0;\n                            for(let y = 0; y < height; y++){\n                                offsetLiterals++;\n                                for(let i = 0; i < lineSize; i++){\n                                    literals[offsetLiterals++] ^= 0xff;\n                                }\n                            }\n                        }\n                        const ihdr = new Uint8Array([\n                            width >> 24 & 0xff,\n                            width >> 16 & 0xff,\n                            width >> 8 & 0xff,\n                            width & 0xff,\n                            height >> 24 & 0xff,\n                            height >> 16 & 0xff,\n                            height >> 8 & 0xff,\n                            height & 0xff,\n                            bitDepth,\n                            colorType,\n                            0x00,\n                            0x00,\n                            0x00\n                        ]);\n                        const idat = deflateSync(literals);\n                        const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n                        const data = new Uint8Array(pngLength);\n                        let offset = 0;\n                        data.set(PNG_HEADER, offset);\n                        offset += PNG_HEADER.length;\n                        writePngChunk(\"IHDR\", ihdr, data, offset);\n                        offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n                        writePngChunk(\"IDATA\", idat, data, offset);\n                        offset += CHUNK_WRAPPER_SIZE + idat.length;\n                        writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n                        return createObjectURL(data, \"image/png\", forceDataSchema);\n                    }\n                    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n                        const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n                        return encode(imgData, kind, forceDataSchema, isMask);\n                    };\n                }();\n                class SVGExtraState {\n                    constructor(){\n                        this.fontSizeScale = 1;\n                        this.fontWeight = SVG_DEFAULTS.fontWeight;\n                        this.fontSize = 0;\n                        this.textMatrix = _util.IDENTITY_MATRIX;\n                        this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.textRenderingMode = _util.TextRenderingMode.FILL;\n                        this.textMatrixScale = 1;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRise = 0;\n                        this.fillColor = SVG_DEFAULTS.fillColor;\n                        this.strokeColor = \"#000000\";\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.lineJoin = \"\";\n                        this.lineCap = \"\";\n                        this.miterLimit = 0;\n                        this.dashArray = [];\n                        this.dashPhase = 0;\n                        this.dependencies = [];\n                        this.activeClipUrl = null;\n                        this.clipGroup = null;\n                        this.maskId = \"\";\n                    }\n                    clone() {\n                        return Object.create(this);\n                    }\n                    setCurrentPoint(x, y) {\n                        this.x = x;\n                        this.y = y;\n                    }\n                }\n                function opListToTree(opList) {\n                    let opTree = [];\n                    const tmp = [];\n                    for (const opListElement of opList){\n                        if (opListElement.fn === \"save\") {\n                            opTree.push({\n                                fnId: 92,\n                                fn: \"group\",\n                                items: []\n                            });\n                            tmp.push(opTree);\n                            opTree = opTree.at(-1).items;\n                            continue;\n                        }\n                        if (opListElement.fn === \"restore\") {\n                            opTree = tmp.pop();\n                        } else {\n                            opTree.push(opListElement);\n                        }\n                    }\n                    return opTree;\n                }\n                function pf(value) {\n                    if (Number.isInteger(value)) {\n                        return value.toString();\n                    }\n                    const s = value.toFixed(10);\n                    let i = s.length - 1;\n                    if (s[i] !== \"0\") {\n                        return s;\n                    }\n                    do {\n                        i--;\n                    }while (s[i] === \"0\");\n                    return s.substring(0, s[i] === \".\" ? i : i + 1);\n                }\n                function pm(m) {\n                    if (m[4] === 0 && m[5] === 0) {\n                        if (m[1] === 0 && m[2] === 0) {\n                            if (m[0] === 1 && m[3] === 1) {\n                                return \"\";\n                            }\n                            return `scale(${pf(m[0])} ${pf(m[3])})`;\n                        }\n                        if (m[0] === m[3] && m[1] === -m[2]) {\n                            const a = Math.acos(m[0]) * 180 / Math.PI;\n                            return `rotate(${pf(a)})`;\n                        }\n                    } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n                        return `translate(${pf(m[4])} ${pf(m[5])})`;\n                    }\n                    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n                }\n                let clipCount = 0;\n                let maskCount = 0;\n                let shadingCount = 0;\n                class SVGGraphics {\n                    constructor(commonObjs, objs, forceDataSchema = false){\n                        (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n                        this.svgFactory = new _display_utils.DOMSVGFactory();\n                        this.current = new SVGExtraState();\n                        this.transformMatrix = _util.IDENTITY_MATRIX;\n                        this.transformStack = [];\n                        this.extraStack = [];\n                        this.commonObjs = commonObjs;\n                        this.objs = objs;\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.embedFonts = false;\n                        this.embeddedFonts = Object.create(null);\n                        this.cssStyle = null;\n                        this.forceDataSchema = !!forceDataSchema;\n                        this._operatorIdMapping = [];\n                        for(const op in _util.OPS){\n                            this._operatorIdMapping[_util.OPS[op]] = op;\n                        }\n                    }\n                    getObject(data, fallback = null) {\n                        if (typeof data === \"string\") {\n                            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n                        }\n                        return fallback;\n                    }\n                    save() {\n                        this.transformStack.push(this.transformMatrix);\n                        const old = this.current;\n                        this.extraStack.push(old);\n                        this.current = old.clone();\n                    }\n                    restore() {\n                        this.transformMatrix = this.transformStack.pop();\n                        this.current = this.extraStack.pop();\n                        this.pendingClip = null;\n                        this.tgrp = null;\n                    }\n                    group(items) {\n                        this.save();\n                        this.executeOpTree(items);\n                        this.restore();\n                    }\n                    loadDependencies(operatorList) {\n                        const fnArray = operatorList.fnArray;\n                        const argsArray = operatorList.argsArray;\n                        for(let i = 0, ii = fnArray.length; i < ii; i++){\n                            if (fnArray[i] !== _util.OPS.dependency) {\n                                continue;\n                            }\n                            for (const obj of argsArray[i]){\n                                const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n                                const promise = new Promise((resolve)=>{\n                                    objsPool.get(obj, resolve);\n                                });\n                                this.current.dependencies.push(promise);\n                            }\n                        }\n                        return Promise.all(this.current.dependencies);\n                    }\n                    transform(a, b, c, d, e, f) {\n                        const transformMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n                        this.tgrp = null;\n                    }\n                    getSVG(operatorList, viewport) {\n                        this.viewport = viewport;\n                        const svgElement = this._initialize(viewport);\n                        return this.loadDependencies(operatorList).then(()=>{\n                            this.transformMatrix = _util.IDENTITY_MATRIX;\n                            this.executeOpTree(this.convertOpList(operatorList));\n                            return svgElement;\n                        });\n                    }\n                    convertOpList(operatorList) {\n                        const operatorIdMapping = this._operatorIdMapping;\n                        const argsArray = operatorList.argsArray;\n                        const fnArray = operatorList.fnArray;\n                        const opList = [];\n                        for(let i = 0, ii = fnArray.length; i < ii; i++){\n                            const fnId = fnArray[i];\n                            opList.push({\n                                fnId,\n                                fn: operatorIdMapping[fnId],\n                                args: argsArray[i]\n                            });\n                        }\n                        return opListToTree(opList);\n                    }\n                    executeOpTree(opTree) {\n                        for (const opTreeElement of opTree){\n                            const fn = opTreeElement.fn;\n                            const fnId = opTreeElement.fnId;\n                            const args = opTreeElement.args;\n                            switch(fnId | 0){\n                                case _util.OPS.beginText:\n                                    this.beginText();\n                                    break;\n                                case _util.OPS.dependency:\n                                    break;\n                                case _util.OPS.setLeading:\n                                    this.setLeading(args);\n                                    break;\n                                case _util.OPS.setLeadingMoveText:\n                                    this.setLeadingMoveText(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setFont:\n                                    this.setFont(args);\n                                    break;\n                                case _util.OPS.showText:\n                                    this.showText(args[0]);\n                                    break;\n                                case _util.OPS.showSpacedText:\n                                    this.showText(args[0]);\n                                    break;\n                                case _util.OPS.endText:\n                                    this.endText();\n                                    break;\n                                case _util.OPS.moveText:\n                                    this.moveText(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setCharSpacing:\n                                    this.setCharSpacing(args[0]);\n                                    break;\n                                case _util.OPS.setWordSpacing:\n                                    this.setWordSpacing(args[0]);\n                                    break;\n                                case _util.OPS.setHScale:\n                                    this.setHScale(args[0]);\n                                    break;\n                                case _util.OPS.setTextMatrix:\n                                    this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                                    break;\n                                case _util.OPS.setTextRise:\n                                    this.setTextRise(args[0]);\n                                    break;\n                                case _util.OPS.setTextRenderingMode:\n                                    this.setTextRenderingMode(args[0]);\n                                    break;\n                                case _util.OPS.setLineWidth:\n                                    this.setLineWidth(args[0]);\n                                    break;\n                                case _util.OPS.setLineJoin:\n                                    this.setLineJoin(args[0]);\n                                    break;\n                                case _util.OPS.setLineCap:\n                                    this.setLineCap(args[0]);\n                                    break;\n                                case _util.OPS.setMiterLimit:\n                                    this.setMiterLimit(args[0]);\n                                    break;\n                                case _util.OPS.setFillRGBColor:\n                                    this.setFillRGBColor(args[0], args[1], args[2]);\n                                    break;\n                                case _util.OPS.setStrokeRGBColor:\n                                    this.setStrokeRGBColor(args[0], args[1], args[2]);\n                                    break;\n                                case _util.OPS.setStrokeColorN:\n                                    this.setStrokeColorN(args);\n                                    break;\n                                case _util.OPS.setFillColorN:\n                                    this.setFillColorN(args);\n                                    break;\n                                case _util.OPS.shadingFill:\n                                    this.shadingFill(args[0]);\n                                    break;\n                                case _util.OPS.setDash:\n                                    this.setDash(args[0], args[1]);\n                                    break;\n                                case _util.OPS.setRenderingIntent:\n                                    this.setRenderingIntent(args[0]);\n                                    break;\n                                case _util.OPS.setFlatness:\n                                    this.setFlatness(args[0]);\n                                    break;\n                                case _util.OPS.setGState:\n                                    this.setGState(args[0]);\n                                    break;\n                                case _util.OPS.fill:\n                                    this.fill();\n                                    break;\n                                case _util.OPS.eoFill:\n                                    this.eoFill();\n                                    break;\n                                case _util.OPS.stroke:\n                                    this.stroke();\n                                    break;\n                                case _util.OPS.fillStroke:\n                                    this.fillStroke();\n                                    break;\n                                case _util.OPS.eoFillStroke:\n                                    this.eoFillStroke();\n                                    break;\n                                case _util.OPS.clip:\n                                    this.clip(\"nonzero\");\n                                    break;\n                                case _util.OPS.eoClip:\n                                    this.clip(\"evenodd\");\n                                    break;\n                                case _util.OPS.paintSolidColorImageMask:\n                                    this.paintSolidColorImageMask();\n                                    break;\n                                case _util.OPS.paintImageXObject:\n                                    this.paintImageXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintInlineImageXObject:\n                                    this.paintInlineImageXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintImageMaskXObject:\n                                    this.paintImageMaskXObject(args[0]);\n                                    break;\n                                case _util.OPS.paintFormXObjectBegin:\n                                    this.paintFormXObjectBegin(args[0], args[1]);\n                                    break;\n                                case _util.OPS.paintFormXObjectEnd:\n                                    this.paintFormXObjectEnd();\n                                    break;\n                                case _util.OPS.closePath:\n                                    this.closePath();\n                                    break;\n                                case _util.OPS.closeStroke:\n                                    this.closeStroke();\n                                    break;\n                                case _util.OPS.closeFillStroke:\n                                    this.closeFillStroke();\n                                    break;\n                                case _util.OPS.closeEOFillStroke:\n                                    this.closeEOFillStroke();\n                                    break;\n                                case _util.OPS.nextLine:\n                                    this.nextLine();\n                                    break;\n                                case _util.OPS.transform:\n                                    this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                                    break;\n                                case _util.OPS.constructPath:\n                                    this.constructPath(args[0], args[1]);\n                                    break;\n                                case _util.OPS.endPath:\n                                    this.endPath();\n                                    break;\n                                case 92:\n                                    this.group(opTreeElement.items);\n                                    break;\n                                default:\n                                    (0, _util.warn)(`Unimplemented operator ${fn}`);\n                                    break;\n                            }\n                        }\n                    }\n                    setWordSpacing(wordSpacing) {\n                        this.current.wordSpacing = wordSpacing;\n                    }\n                    setCharSpacing(charSpacing) {\n                        this.current.charSpacing = charSpacing;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    setTextMatrix(a, b, c, d, e, f) {\n                        const current = this.current;\n                        current.textMatrix = current.lineMatrix = [\n                            a,\n                            b,\n                            c,\n                            d,\n                            e,\n                            f\n                        ];\n                        current.textMatrixScale = Math.hypot(a, b);\n                        current.x = current.lineX = 0;\n                        current.y = current.lineY = 0;\n                        current.xcoords = [];\n                        current.ycoords = [];\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current.txtElement.append(current.tspan);\n                    }\n                    beginText() {\n                        const current = this.current;\n                        current.x = current.lineX = 0;\n                        current.y = current.lineY = 0;\n                        current.textMatrix = _util.IDENTITY_MATRIX;\n                        current.lineMatrix = _util.IDENTITY_MATRIX;\n                        current.textMatrixScale = 1;\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n                        current.xcoords = [];\n                        current.ycoords = [];\n                    }\n                    moveText(x, y) {\n                        const current = this.current;\n                        current.x = current.lineX += x;\n                        current.y = current.lineY += y;\n                        current.xcoords = [];\n                        current.ycoords = [];\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                    }\n                    showText(glyphs) {\n                        const current = this.current;\n                        const font = current.font;\n                        const fontSize = current.fontSize;\n                        if (fontSize === 0) {\n                            return;\n                        }\n                        const fontSizeScale = current.fontSizeScale;\n                        const charSpacing = current.charSpacing;\n                        const wordSpacing = current.wordSpacing;\n                        const fontDirection = current.fontDirection;\n                        const textHScale = current.textHScale * fontDirection;\n                        const vertical = font.vertical;\n                        const spacingDir = vertical ? 1 : -1;\n                        const defaultVMetrics = font.defaultVMetrics;\n                        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n                        let x = 0;\n                        for (const glyph of glyphs){\n                            if (glyph === null) {\n                                x += fontDirection * wordSpacing;\n                                continue;\n                            } else if (typeof glyph === \"number\") {\n                                x += spacingDir * glyph * fontSize / 1000;\n                                continue;\n                            }\n                            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n                            const character = glyph.fontChar;\n                            let scaledX, scaledY;\n                            let width = glyph.width;\n                            if (vertical) {\n                                let vx;\n                                const vmetric = glyph.vmetric || defaultVMetrics;\n                                vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n                                vx = -vx * widthAdvanceScale;\n                                const vy = vmetric[2] * widthAdvanceScale;\n                                width = vmetric ? -vmetric[0] : width;\n                                scaledX = vx / fontSizeScale;\n                                scaledY = (x + vy) / fontSizeScale;\n                            } else {\n                                scaledX = x / fontSizeScale;\n                                scaledY = 0;\n                            }\n                            if (glyph.isInFont || font.missingFile) {\n                                current.xcoords.push(current.x + scaledX);\n                                if (vertical) {\n                                    current.ycoords.push(-current.y + scaledY);\n                                }\n                                current.tspan.textContent += character;\n                            } else {}\n                            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n                            x += charWidth;\n                        }\n                        current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n                        if (vertical) {\n                            current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n                        } else {\n                            current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        }\n                        if (vertical) {\n                            current.y -= x;\n                        } else {\n                            current.x += x * textHScale;\n                        }\n                        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n                        current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n                        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n                            current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n                        }\n                        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n                            current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n                        }\n                        const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n                        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                            if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n                                current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n                            }\n                            if (current.fillAlpha < 1) {\n                                current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                            }\n                        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n                            current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n                        } else {\n                            current.tspan.setAttributeNS(null, \"fill\", \"none\");\n                        }\n                        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n                            const lineWidthScale = 1 / (current.textMatrixScale || 1);\n                            this._setStrokeAttributes(current.tspan, lineWidthScale);\n                        }\n                        let textMatrix = current.textMatrix;\n                        if (current.textRise !== 0) {\n                            textMatrix = textMatrix.slice();\n                            textMatrix[5] += current.textRise;\n                        }\n                        current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n                        current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n                        current.txtElement.append(current.tspan);\n                        current.txtgrp.append(current.txtElement);\n                        this._ensureTransformGroup().append(current.txtElement);\n                    }\n                    setLeadingMoveText(x, y) {\n                        this.setLeading(-y);\n                        this.moveText(x, y);\n                    }\n                    addFontStyle(fontObj) {\n                        if (!fontObj.data) {\n                            throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n                        }\n                        if (!this.cssStyle) {\n                            this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n                            this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n                            this.defs.append(this.cssStyle);\n                        }\n                        const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n                        this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n                    }\n                    setFont(details) {\n                        const current = this.current;\n                        const fontObj = this.commonObjs.get(details[0]);\n                        let size = details[1];\n                        current.font = fontObj;\n                        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n                            this.addFontStyle(fontObj);\n                            this.embeddedFonts[fontObj.loadedName] = fontObj;\n                        }\n                        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n                        let bold = \"normal\";\n                        if (fontObj.black) {\n                            bold = \"900\";\n                        } else if (fontObj.bold) {\n                            bold = \"bold\";\n                        }\n                        const italic = fontObj.italic ? \"italic\" : \"normal\";\n                        if (size < 0) {\n                            size = -size;\n                            current.fontDirection = -1;\n                        } else {\n                            current.fontDirection = 1;\n                        }\n                        current.fontSize = size;\n                        current.fontFamily = fontObj.loadedName;\n                        current.fontWeight = bold;\n                        current.fontStyle = italic;\n                        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n                        current.xcoords = [];\n                        current.ycoords = [];\n                    }\n                    endText() {\n                        const current = this.current;\n                        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n                            current.element = current.txtElement;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    setLineWidth(width) {\n                        if (width > 0) {\n                            this.current.lineWidth = width;\n                        }\n                    }\n                    setLineCap(style) {\n                        this.current.lineCap = LINE_CAP_STYLES[style];\n                    }\n                    setLineJoin(style) {\n                        this.current.lineJoin = LINE_JOIN_STYLES[style];\n                    }\n                    setMiterLimit(limit) {\n                        this.current.miterLimit = limit;\n                    }\n                    setStrokeAlpha(strokeAlpha) {\n                        this.current.strokeAlpha = strokeAlpha;\n                    }\n                    setStrokeRGBColor(r, g, b) {\n                        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n                    }\n                    setFillAlpha(fillAlpha) {\n                        this.current.fillAlpha = fillAlpha;\n                    }\n                    setFillRGBColor(r, g, b) {\n                        this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n                        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        this.current.xcoords = [];\n                        this.current.ycoords = [];\n                    }\n                    setStrokeColorN(args) {\n                        this.current.strokeColor = this._makeColorN_Pattern(args);\n                    }\n                    setFillColorN(args) {\n                        this.current.fillColor = this._makeColorN_Pattern(args);\n                    }\n                    shadingFill(args) {\n                        const { width, height } = this.viewport;\n                        const inv = _util.Util.inverseTransform(this.transformMatrix);\n                        const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([\n                            0,\n                            0,\n                            width,\n                            height\n                        ], inv);\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", x0);\n                        rect.setAttributeNS(null, \"y\", y0);\n                        rect.setAttributeNS(null, \"width\", x1 - x0);\n                        rect.setAttributeNS(null, \"height\", y1 - y0);\n                        rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n                        if (this.current.fillAlpha < 1) {\n                            rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n                        }\n                        this._ensureTransformGroup().append(rect);\n                    }\n                    _makeColorN_Pattern(args) {\n                        if (args[0] === \"TilingPattern\") {\n                            return this._makeTilingPattern(args);\n                        }\n                        return this._makeShadingPattern(args);\n                    }\n                    _makeTilingPattern(args) {\n                        const color = args[1];\n                        const operatorList = args[2];\n                        const matrix = args[3] || _util.IDENTITY_MATRIX;\n                        const [x0, y0, x1, y1] = args[4];\n                        const xstep = args[5];\n                        const ystep = args[6];\n                        const paintType = args[7];\n                        const tilingId = `shading${shadingCount++}`;\n                        const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([\n                            ..._util.Util.applyTransform([\n                                x0,\n                                y0\n                            ], matrix),\n                            ..._util.Util.applyTransform([\n                                x1,\n                                y1\n                            ], matrix)\n                        ]);\n                        const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n                        const txstep = xstep * xscale;\n                        const tystep = ystep * yscale;\n                        const tiling = this.svgFactory.createElement(\"svg:pattern\");\n                        tiling.setAttributeNS(null, \"id\", tilingId);\n                        tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n                        tiling.setAttributeNS(null, \"width\", txstep);\n                        tiling.setAttributeNS(null, \"height\", tystep);\n                        tiling.setAttributeNS(null, \"x\", `${tx0}`);\n                        tiling.setAttributeNS(null, \"y\", `${ty0}`);\n                        const svg = this.svg;\n                        const transformMatrix = this.transformMatrix;\n                        const fillColor = this.current.fillColor;\n                        const strokeColor = this.current.strokeColor;\n                        const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n                        this.svg = bbox;\n                        this.transformMatrix = matrix;\n                        if (paintType === 2) {\n                            const cssColor = _util.Util.makeHexColor(...color);\n                            this.current.fillColor = cssColor;\n                            this.current.strokeColor = cssColor;\n                        }\n                        this.executeOpTree(this.convertOpList(operatorList));\n                        this.svg = svg;\n                        this.transformMatrix = transformMatrix;\n                        this.current.fillColor = fillColor;\n                        this.current.strokeColor = strokeColor;\n                        tiling.append(bbox.childNodes[0]);\n                        this.defs.append(tiling);\n                        return `url(#${tilingId})`;\n                    }\n                    _makeShadingPattern(args) {\n                        if (typeof args === \"string\") {\n                            args = this.objs.get(args);\n                        }\n                        switch(args[0]){\n                            case \"RadialAxial\":\n                                const shadingId = `shading${shadingCount++}`;\n                                const colorStops = args[3];\n                                let gradient;\n                                switch(args[1]){\n                                    case \"axial\":\n                                        const point0 = args[4];\n                                        const point1 = args[5];\n                                        gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                                        gradient.setAttributeNS(null, \"id\", shadingId);\n                                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient.setAttributeNS(null, \"x1\", point0[0]);\n                                        gradient.setAttributeNS(null, \"y1\", point0[1]);\n                                        gradient.setAttributeNS(null, \"x2\", point1[0]);\n                                        gradient.setAttributeNS(null, \"y2\", point1[1]);\n                                        break;\n                                    case \"radial\":\n                                        const focalPoint = args[4];\n                                        const circlePoint = args[5];\n                                        const focalRadius = args[6];\n                                        const circleRadius = args[7];\n                                        gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                                        gradient.setAttributeNS(null, \"id\", shadingId);\n                                        gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                                        gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                                        gradient.setAttributeNS(null, \"r\", circleRadius);\n                                        gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                                        gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                                        gradient.setAttributeNS(null, \"fr\", focalRadius);\n                                        break;\n                                    default:\n                                        throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n                                }\n                                for (const colorStop of colorStops){\n                                    const stop = this.svgFactory.createElement(\"svg:stop\");\n                                    stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                                    stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                                    gradient.append(stop);\n                                }\n                                this.defs.append(gradient);\n                                return `url(#${shadingId})`;\n                            case \"Mesh\":\n                                (0, _util.warn)(\"Unimplemented pattern Mesh\");\n                                return null;\n                            case \"Dummy\":\n                                return \"hotpink\";\n                            default:\n                                throw new Error(`Unknown IR type: ${args[0]}`);\n                        }\n                    }\n                    setDash(dashArray, dashPhase) {\n                        this.current.dashArray = dashArray;\n                        this.current.dashPhase = dashPhase;\n                    }\n                    constructPath(ops, args) {\n                        const current = this.current;\n                        let x = current.x, y = current.y;\n                        let d = [];\n                        let j = 0;\n                        for (const op of ops){\n                            switch(op | 0){\n                                case _util.OPS.rectangle:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    const width = args[j++];\n                                    const height = args[j++];\n                                    const xw = x + width;\n                                    const yh = y + height;\n                                    d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                                    break;\n                                case _util.OPS.moveTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    d.push(\"M\", pf(x), pf(y));\n                                    break;\n                                case _util.OPS.lineTo:\n                                    x = args[j++];\n                                    y = args[j++];\n                                    d.push(\"L\", pf(x), pf(y));\n                                    break;\n                                case _util.OPS.curveTo:\n                                    x = args[j + 4];\n                                    y = args[j + 5];\n                                    d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                                    j += 6;\n                                    break;\n                                case _util.OPS.curveTo2:\n                                    d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    j += 4;\n                                    break;\n                                case _util.OPS.curveTo3:\n                                    x = args[j + 2];\n                                    y = args[j + 3];\n                                    d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                                    j += 4;\n                                    break;\n                                case _util.OPS.closePath:\n                                    d.push(\"Z\");\n                                    break;\n                            }\n                        }\n                        d = d.join(\" \");\n                        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n                            d = current.path.getAttributeNS(null, \"d\") + d;\n                        } else {\n                            current.path = this.svgFactory.createElement(\"svg:path\");\n                            this._ensureTransformGroup().append(current.path);\n                        }\n                        current.path.setAttributeNS(null, \"d\", d);\n                        current.path.setAttributeNS(null, \"fill\", \"none\");\n                        current.element = current.path;\n                        current.setCurrentPoint(x, y);\n                    }\n                    endPath() {\n                        const current = this.current;\n                        current.path = null;\n                        if (!this.pendingClip) {\n                            return;\n                        }\n                        if (!current.element) {\n                            this.pendingClip = null;\n                            return;\n                        }\n                        const clipId = `clippath${clipCount++}`;\n                        const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n                        clipPath.setAttributeNS(null, \"id\", clipId);\n                        clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                        const clipElement = current.element.cloneNode(true);\n                        if (this.pendingClip === \"evenodd\") {\n                            clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n                        } else {\n                            clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n                        }\n                        this.pendingClip = null;\n                        clipPath.append(clipElement);\n                        this.defs.append(clipPath);\n                        if (current.activeClipUrl) {\n                            current.clipGroup = null;\n                            for (const prev of this.extraStack){\n                                prev.clipGroup = null;\n                            }\n                            clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n                        }\n                        current.activeClipUrl = `url(#${clipId})`;\n                        this.tgrp = null;\n                    }\n                    clip(type) {\n                        this.pendingClip = type;\n                    }\n                    closePath() {\n                        const current = this.current;\n                        if (current.path) {\n                            const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n                            current.path.setAttributeNS(null, \"d\", d);\n                        }\n                    }\n                    setLeading(leading) {\n                        this.current.leading = -leading;\n                    }\n                    setTextRise(textRise) {\n                        this.current.textRise = textRise;\n                    }\n                    setTextRenderingMode(textRenderingMode) {\n                        this.current.textRenderingMode = textRenderingMode;\n                    }\n                    setHScale(scale) {\n                        this.current.textHScale = scale / 100;\n                    }\n                    setRenderingIntent(intent) {}\n                    setFlatness(flatness) {}\n                    setGState(states) {\n                        for (const [key, value] of states){\n                            switch(key){\n                                case \"LW\":\n                                    this.setLineWidth(value);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value[0], value[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value);\n                                    break;\n                                case \"CA\":\n                                    this.setStrokeAlpha(value);\n                                    break;\n                                case \"ca\":\n                                    this.setFillAlpha(value);\n                                    break;\n                                default:\n                                    (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n                                    break;\n                            }\n                        }\n                    }\n                    fill() {\n                        const current = this.current;\n                        if (current.element) {\n                            current.element.setAttributeNS(null, \"fill\", current.fillColor);\n                            current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n                            this.endPath();\n                        }\n                    }\n                    stroke() {\n                        const current = this.current;\n                        if (current.element) {\n                            this._setStrokeAttributes(current.element);\n                            current.element.setAttributeNS(null, \"fill\", \"none\");\n                            this.endPath();\n                        }\n                    }\n                    _setStrokeAttributes(element, lineWidthScale = 1) {\n                        const current = this.current;\n                        let dashArray = current.dashArray;\n                        if (lineWidthScale !== 1 && dashArray.length > 0) {\n                            dashArray = dashArray.map(function(value) {\n                                return lineWidthScale * value;\n                            });\n                        }\n                        element.setAttributeNS(null, \"stroke\", current.strokeColor);\n                        element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n                        element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n                        element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n                        element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n                        element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n                        element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n                        element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n                    }\n                    eoFill() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.stroke();\n                        this.fill();\n                    }\n                    eoFillStroke() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fillStroke();\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.closePath();\n                        this.eoFillStroke();\n                    }\n                    paintSolidColorImageMask() {\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", \"0\");\n                        rect.setAttributeNS(null, \"y\", \"0\");\n                        rect.setAttributeNS(null, \"width\", \"1px\");\n                        rect.setAttributeNS(null, \"height\", \"1px\");\n                        rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n                        this._ensureTransformGroup().append(rect);\n                    }\n                    paintImageXObject(objId) {\n                        const imgData = this.getObject(objId);\n                        if (!imgData) {\n                            (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData);\n                    }\n                    paintInlineImageXObject(imgData, mask) {\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n                        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n                        cliprect.setAttributeNS(null, \"x\", \"0\");\n                        cliprect.setAttributeNS(null, \"y\", \"0\");\n                        cliprect.setAttributeNS(null, \"width\", pf(width));\n                        cliprect.setAttributeNS(null, \"height\", pf(height));\n                        this.current.element = cliprect;\n                        this.clip(\"nonzero\");\n                        const imgEl = this.svgFactory.createElement(\"svg:image\");\n                        imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n                        imgEl.setAttributeNS(null, \"x\", \"0\");\n                        imgEl.setAttributeNS(null, \"y\", pf(-height));\n                        imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n                        imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n                        imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n                        if (mask) {\n                            mask.append(imgEl);\n                        } else {\n                            this._ensureTransformGroup().append(imgEl);\n                        }\n                    }\n                    paintImageMaskXObject(img) {\n                        const imgData = this.getObject(img.data, img);\n                        if (imgData.bitmap) {\n                            (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n                            return;\n                        }\n                        const current = this.current;\n                        const width = imgData.width;\n                        const height = imgData.height;\n                        const fillColor = current.fillColor;\n                        current.maskId = `mask${maskCount++}`;\n                        const mask = this.svgFactory.createElement(\"svg:mask\");\n                        mask.setAttributeNS(null, \"id\", current.maskId);\n                        const rect = this.svgFactory.createElement(\"svg:rect\");\n                        rect.setAttributeNS(null, \"x\", \"0\");\n                        rect.setAttributeNS(null, \"y\", \"0\");\n                        rect.setAttributeNS(null, \"width\", pf(width));\n                        rect.setAttributeNS(null, \"height\", pf(height));\n                        rect.setAttributeNS(null, \"fill\", fillColor);\n                        rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n                        this.defs.append(mask);\n                        this._ensureTransformGroup().append(rect);\n                        this.paintInlineImageXObject(imgData, mask);\n                    }\n                    paintFormXObjectBegin(matrix, bbox) {\n                        if (Array.isArray(matrix) && matrix.length === 6) {\n                            this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n                        }\n                        if (bbox) {\n                            const width = bbox[2] - bbox[0];\n                            const height = bbox[3] - bbox[1];\n                            const cliprect = this.svgFactory.createElement(\"svg:rect\");\n                            cliprect.setAttributeNS(null, \"x\", bbox[0]);\n                            cliprect.setAttributeNS(null, \"y\", bbox[1]);\n                            cliprect.setAttributeNS(null, \"width\", pf(width));\n                            cliprect.setAttributeNS(null, \"height\", pf(height));\n                            this.current.element = cliprect;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {}\n                    _initialize(viewport) {\n                        const svg = this.svgFactory.create(viewport.width, viewport.height);\n                        const definitions = this.svgFactory.createElement(\"svg:defs\");\n                        svg.append(definitions);\n                        this.defs = definitions;\n                        const rootGroup = this.svgFactory.createElement(\"svg:g\");\n                        rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n                        svg.append(rootGroup);\n                        this.svg = rootGroup;\n                        return svg;\n                    }\n                    _ensureClipGroup() {\n                        if (!this.current.clipGroup) {\n                            const clipGroup = this.svgFactory.createElement(\"svg:g\");\n                            clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n                            this.svg.append(clipGroup);\n                            this.current.clipGroup = clipGroup;\n                        }\n                        return this.current.clipGroup;\n                    }\n                    _ensureTransformGroup() {\n                        if (!this.tgrp) {\n                            this.tgrp = this.svgFactory.createElement(\"svg:g\");\n                            this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n                            if (this.current.activeClipUrl) {\n                                this._ensureClipGroup().append(this.tgrp);\n                            } else {\n                                this.svg.append(this.tgrp);\n                            }\n                        }\n                        return this.tgrp;\n                    }\n                }\n                exports1.SVGGraphics = SVGGraphics;\n            /***/ },\n            /* 25 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaText = void 0;\n                class XfaText {\n                    static textContent(xfa) {\n                        const items = [];\n                        const output = {\n                            items,\n                            styles: Object.create(null)\n                        };\n                        function walk(node) {\n                            if (!node) {\n                                return;\n                            }\n                            let str = null;\n                            const name = node.name;\n                            if (name === \"#text\") {\n                                str = node.value;\n                            } else if (!XfaText.shouldBuildText(name)) {\n                                return;\n                            } else if (node?.attributes?.textContent) {\n                                str = node.attributes.textContent;\n                            } else if (node.value) {\n                                str = node.value;\n                            }\n                            if (str !== null) {\n                                items.push({\n                                    str\n                                });\n                            }\n                            if (!node.children) {\n                                return;\n                            }\n                            for (const child of node.children){\n                                walk(child);\n                            }\n                        }\n                        walk(xfa);\n                        return output;\n                    }\n                    static shouldBuildText(name) {\n                        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n                    }\n                }\n                exports1.XfaText = XfaText;\n            /***/ },\n            /* 26 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TextLayerRenderTask = void 0;\n                exports1.renderTextLayer = renderTextLayer;\n                exports1.updateTextLayer = updateTextLayer;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                const MAX_TEXT_DIVS_TO_RENDER = 100000;\n                const DEFAULT_FONT_SIZE = 30;\n                const DEFAULT_FONT_ASCENT = 0.8;\n                const ascentCache = new Map();\n                function getCtx(size, isOffscreenCanvasSupported) {\n                    let ctx;\n                    if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {\n                        ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n                            alpha: false\n                        });\n                    } else {\n                        const canvas = document.createElement(\"canvas\");\n                        canvas.width = canvas.height = size;\n                        ctx = canvas.getContext(\"2d\", {\n                            alpha: false\n                        });\n                    }\n                    return ctx;\n                }\n                function getAscent(fontFamily, isOffscreenCanvasSupported) {\n                    const cachedAscent = ascentCache.get(fontFamily);\n                    if (cachedAscent) {\n                        return cachedAscent;\n                    }\n                    const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n                    ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n                    const metrics = ctx.measureText(\"\");\n                    let ascent = metrics.fontBoundingBoxAscent;\n                    let descent = Math.abs(metrics.fontBoundingBoxDescent);\n                    if (ascent) {\n                        const ratio = ascent / (ascent + descent);\n                        ascentCache.set(fontFamily, ratio);\n                        ctx.canvas.width = ctx.canvas.height = 0;\n                        return ratio;\n                    }\n                    ctx.strokeStyle = \"red\";\n                    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n                    ctx.strokeText(\"g\", 0, 0);\n                    let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n                    descent = 0;\n                    for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n                        if (pixels[i] > 0) {\n                            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                            break;\n                        }\n                    }\n                    ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n                    ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n                    pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n                    ascent = 0;\n                    for(let i = 0, ii = pixels.length; i < ii; i += 4){\n                        if (pixels[i] > 0) {\n                            ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                            break;\n                        }\n                    }\n                    ctx.canvas.width = ctx.canvas.height = 0;\n                    if (ascent) {\n                        const ratio = ascent / (ascent + descent);\n                        ascentCache.set(fontFamily, ratio);\n                        return ratio;\n                    }\n                    ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n                    return DEFAULT_FONT_ASCENT;\n                }\n                function appendText(task, geom, styles) {\n                    const textDiv = document.createElement(\"span\");\n                    const textDivProperties = {\n                        angle: 0,\n                        canvasWidth: 0,\n                        hasText: geom.str !== \"\",\n                        hasEOL: geom.hasEOL,\n                        fontSize: 0\n                    };\n                    task._textDivs.push(textDiv);\n                    const tx = _util.Util.transform(task._transform, geom.transform);\n                    let angle = Math.atan2(tx[1], tx[0]);\n                    const style = styles[geom.fontName];\n                    if (style.vertical) {\n                        angle += Math.PI / 2;\n                    }\n                    const fontHeight = Math.hypot(tx[2], tx[3]);\n                    const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);\n                    let left, top;\n                    if (angle === 0) {\n                        left = tx[4];\n                        top = tx[5] - fontAscent;\n                    } else {\n                        left = tx[4] + fontAscent * Math.sin(angle);\n                        top = tx[5] - fontAscent * Math.cos(angle);\n                    }\n                    const scaleFactorStr = \"calc(var(--scale-factor)*\";\n                    const divStyle = textDiv.style;\n                    if (task._container === task._rootContainer) {\n                        divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;\n                        divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;\n                    } else {\n                        divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n                        divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n                    }\n                    divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;\n                    divStyle.fontFamily = style.fontFamily;\n                    textDivProperties.fontSize = fontHeight;\n                    textDiv.setAttribute(\"role\", \"presentation\");\n                    textDiv.textContent = geom.str;\n                    textDiv.dir = geom.dir;\n                    if (task._fontInspectorEnabled) {\n                        textDiv.dataset.fontName = geom.fontName;\n                    }\n                    if (angle !== 0) {\n                        textDivProperties.angle = angle * (180 / Math.PI);\n                    }\n                    let shouldScaleText = false;\n                    if (geom.str.length > 1) {\n                        shouldScaleText = true;\n                    } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n                        const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n                        if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                            shouldScaleText = true;\n                        }\n                    }\n                    if (shouldScaleText) {\n                        textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n                    }\n                    task._textDivProperties.set(textDiv, textDivProperties);\n                    if (task._isReadableStream) {\n                        task._layoutText(textDiv);\n                    }\n                }\n                function layout(params) {\n                    const { div, scale, properties, ctx, prevFontSize, prevFontFamily } = params;\n                    const { style } = div;\n                    let transform = \"\";\n                    if (properties.canvasWidth !== 0 && properties.hasText) {\n                        const { fontFamily } = style;\n                        const { canvasWidth, fontSize } = properties;\n                        if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n                            ctx.font = `${fontSize * scale}px ${fontFamily}`;\n                            params.prevFontSize = fontSize;\n                            params.prevFontFamily = fontFamily;\n                        }\n                        const { width } = ctx.measureText(div.textContent);\n                        if (width > 0) {\n                            transform = `scaleX(${canvasWidth * scale / width})`;\n                        }\n                    }\n                    if (properties.angle !== 0) {\n                        transform = `rotate(${properties.angle}deg) ${transform}`;\n                    }\n                    if (transform.length > 0) {\n                        style.transform = transform;\n                    }\n                }\n                function render(task) {\n                    if (task._canceled) {\n                        return;\n                    }\n                    const textDivs = task._textDivs;\n                    const capability = task._capability;\n                    const textDivsLength = textDivs.length;\n                    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n                        capability.resolve();\n                        return;\n                    }\n                    if (!task._isReadableStream) {\n                        for (const textDiv of textDivs){\n                            task._layoutText(textDiv);\n                        }\n                    }\n                    capability.resolve();\n                }\n                class TextLayerRenderTask {\n                    constructor({ textContentSource, container, viewport, textDivs, textDivProperties, textContentItemsStr, isOffscreenCanvasSupported }){\n                        this._textContentSource = textContentSource;\n                        this._isReadableStream = textContentSource instanceof ReadableStream;\n                        this._container = this._rootContainer = container;\n                        this._textDivs = textDivs || [];\n                        this._textContentItemsStr = textContentItemsStr || [];\n                        this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n                        this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n                        this._reader = null;\n                        this._textDivProperties = textDivProperties || new WeakMap();\n                        this._canceled = false;\n                        this._capability = new _util.PromiseCapability();\n                        this._layoutTextParams = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n                            properties: null,\n                            ctx: getCtx(0, isOffscreenCanvasSupported)\n                        };\n                        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                        this._transform = [\n                            1,\n                            0,\n                            0,\n                            -1,\n                            -pageX,\n                            pageY + pageHeight\n                        ];\n                        this._pageWidth = pageWidth;\n                        this._pageHeight = pageHeight;\n                        (0, _display_utils.setLayerDimensions)(container, viewport);\n                        this._capability.promise.finally(()=>{\n                            this._layoutTextParams = null;\n                        }).catch(()=>{});\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    cancel() {\n                        this._canceled = true;\n                        if (this._reader) {\n                            this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(()=>{});\n                            this._reader = null;\n                        }\n                        this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\"));\n                    }\n                    _processItems(items, styleCache) {\n                        for (const item of items){\n                            if (item.str === undefined) {\n                                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                                    const parent = this._container;\n                                    this._container = document.createElement(\"span\");\n                                    this._container.classList.add(\"markedContent\");\n                                    if (item.id !== null) {\n                                        this._container.setAttribute(\"id\", `${item.id}`);\n                                    }\n                                    parent.append(this._container);\n                                } else if (item.type === \"endMarkedContent\") {\n                                    this._container = this._container.parentNode;\n                                }\n                                continue;\n                            }\n                            this._textContentItemsStr.push(item.str);\n                            appendText(this, item, styleCache);\n                        }\n                    }\n                    _layoutText(textDiv) {\n                        const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n                        this._layoutTextParams.div = textDiv;\n                        layout(this._layoutTextParams);\n                        if (textDivProperties.hasText) {\n                            this._container.append(textDiv);\n                        }\n                        if (textDivProperties.hasEOL) {\n                            const br = document.createElement(\"br\");\n                            br.setAttribute(\"role\", \"presentation\");\n                            this._container.append(br);\n                        }\n                    }\n                    _render() {\n                        const capability = new _util.PromiseCapability();\n                        let styleCache = Object.create(null);\n                        if (this._isReadableStream) {\n                            const pump = ()=>{\n                                this._reader.read().then(({ value, done })=>{\n                                    if (done) {\n                                        capability.resolve();\n                                        return;\n                                    }\n                                    Object.assign(styleCache, value.styles);\n                                    this._processItems(value.items, styleCache);\n                                    pump();\n                                }, capability.reject);\n                            };\n                            this._reader = this._textContentSource.getReader();\n                            pump();\n                        } else if (this._textContentSource) {\n                            const { items, styles } = this._textContentSource;\n                            this._processItems(items, styles);\n                            capability.resolve();\n                        } else {\n                            throw new Error('No \"textContentSource\" parameter specified.');\n                        }\n                        capability.promise.then(()=>{\n                            styleCache = null;\n                            render(this);\n                        }, this._capability.reject);\n                    }\n                }\n                exports1.TextLayerRenderTask = TextLayerRenderTask;\n                function renderTextLayer(params) {\n                    if (!params.textContentSource && (params.textContent || params.textContentStream)) {\n                        (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n                        params.textContentSource = params.textContent || params.textContentStream;\n                    }\n                    const { container, viewport } = params;\n                    const style = getComputedStyle(container);\n                    const visibility = style.getPropertyValue(\"visibility\");\n                    const scaleFactor = parseFloat(style.getPropertyValue(\"--scale-factor\"));\n                    if (visibility === \"visible\" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {\n                        console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n                    }\n                    const task = new TextLayerRenderTask(params);\n                    task._render();\n                    return task;\n                }\n                function updateTextLayer({ container, viewport, textDivs, textDivProperties, isOffscreenCanvasSupported, mustRotate = true, mustRescale = true }) {\n                    if (mustRotate) {\n                        (0, _display_utils.setLayerDimensions)(container, {\n                            rotation: viewport.rotation\n                        });\n                    }\n                    if (mustRescale) {\n                        const ctx = getCtx(0, isOffscreenCanvasSupported);\n                        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n                        const params = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale,\n                            properties: null,\n                            ctx\n                        };\n                        for (const div of textDivs){\n                            params.properties = textDivProperties.get(div);\n                            params.div = div;\n                            layout(params);\n                        }\n                    }\n                }\n            /***/ },\n            /* 27 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditorLayer = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _freetext = __w_pdfjs_require__(28);\n                var _ink = __w_pdfjs_require__(33);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _stamp = __w_pdfjs_require__(34);\n                class AnnotationEditorLayer {\n                    #accessibilityManager;\n                    #allowClick;\n                    #annotationLayer;\n                    #boundPointerup;\n                    #boundPointerdown;\n                    #editors;\n                    #hadPointerDown;\n                    #isCleaningUp;\n                    #isDisabling;\n                    #uiManager;\n                    static{\n                        this._initialized = false;\n                    }\n                    constructor({ uiManager, pageIndex, div, accessibilityManager, annotationLayer, viewport, l10n }){\n                        this.#allowClick = false;\n                        this.#annotationLayer = null;\n                        this.#boundPointerup = this.pointerup.bind(this);\n                        this.#boundPointerdown = this.pointerdown.bind(this);\n                        this.#editors = new Map();\n                        this.#hadPointerDown = false;\n                        this.#isCleaningUp = false;\n                        this.#isDisabling = false;\n                        const editorTypes = [\n                            _freetext.FreeTextEditor,\n                            _ink.InkEditor,\n                            _stamp.StampEditor\n                        ];\n                        if (!AnnotationEditorLayer._initialized) {\n                            AnnotationEditorLayer._initialized = true;\n                            for (const editorType of editorTypes){\n                                editorType.initialize(l10n);\n                            }\n                        }\n                        uiManager.registerEditorTypes(editorTypes);\n                        this.#uiManager = uiManager;\n                        this.pageIndex = pageIndex;\n                        this.div = div;\n                        this.#accessibilityManager = accessibilityManager;\n                        this.#annotationLayer = annotationLayer;\n                        this.viewport = viewport;\n                        this.#uiManager.addLayer(this);\n                    }\n                    get isEmpty() {\n                        return this.#editors.size === 0;\n                    }\n                    updateToolbar(mode) {\n                        this.#uiManager.updateToolbar(mode);\n                    }\n                    updateMode(mode = this.#uiManager.getMode()) {\n                        this.#cleanup();\n                        if (mode === _util.AnnotationEditorType.INK) {\n                            this.addInkEditorIfNeeded(false);\n                            this.disableClick();\n                        } else {\n                            this.enableClick();\n                        }\n                        if (mode !== _util.AnnotationEditorType.NONE) {\n                            this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT);\n                            this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK);\n                            this.div.classList.toggle(\"stampEditing\", mode === _util.AnnotationEditorType.STAMP);\n                            this.div.hidden = false;\n                        }\n                    }\n                    addInkEditorIfNeeded(isCommitting) {\n                        if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n                            return;\n                        }\n                        if (!isCommitting) {\n                            for (const editor of this.#editors.values()){\n                                if (editor.isEmpty()) {\n                                    editor.setInBackground();\n                                    return;\n                                }\n                            }\n                        }\n                        const editor = this.#createAndAddNewEditor({\n                            offsetX: 0,\n                            offsetY: 0\n                        }, false);\n                        editor.setInBackground();\n                    }\n                    setEditingState(isEditing) {\n                        this.#uiManager.setEditingState(isEditing);\n                    }\n                    addCommands(params) {\n                        this.#uiManager.addCommands(params);\n                    }\n                    enable() {\n                        this.div.style.pointerEvents = \"auto\";\n                        const annotationElementIds = new Set();\n                        for (const editor of this.#editors.values()){\n                            editor.enableEditing();\n                            if (editor.annotationElementId) {\n                                annotationElementIds.add(editor.annotationElementId);\n                            }\n                        }\n                        if (!this.#annotationLayer) {\n                            return;\n                        }\n                        const editables = this.#annotationLayer.getEditableAnnotations();\n                        for (const editable of editables){\n                            editable.hide();\n                            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                                continue;\n                            }\n                            if (annotationElementIds.has(editable.data.id)) {\n                                continue;\n                            }\n                            const editor = this.deserialize(editable);\n                            if (!editor) {\n                                continue;\n                            }\n                            this.addOrRebuild(editor);\n                            editor.enableEditing();\n                        }\n                    }\n                    disable() {\n                        this.#isDisabling = true;\n                        this.div.style.pointerEvents = \"none\";\n                        const hiddenAnnotationIds = new Set();\n                        for (const editor of this.#editors.values()){\n                            editor.disableEditing();\n                            if (!editor.annotationElementId || editor.serialize() !== null) {\n                                hiddenAnnotationIds.add(editor.annotationElementId);\n                                continue;\n                            }\n                            this.getEditableAnnotation(editor.annotationElementId)?.show();\n                            editor.remove();\n                        }\n                        if (this.#annotationLayer) {\n                            const editables = this.#annotationLayer.getEditableAnnotations();\n                            for (const editable of editables){\n                                const { id } = editable.data;\n                                if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {\n                                    continue;\n                                }\n                                editable.show();\n                            }\n                        }\n                        this.#cleanup();\n                        if (this.isEmpty) {\n                            this.div.hidden = true;\n                        }\n                        this.#isDisabling = false;\n                    }\n                    getEditableAnnotation(id) {\n                        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n                    }\n                    setActiveEditor(editor) {\n                        const currentActive = this.#uiManager.getActive();\n                        if (currentActive === editor) {\n                            return;\n                        }\n                        this.#uiManager.setActiveEditor(editor);\n                    }\n                    enableClick() {\n                        this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    disableClick() {\n                        this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    attach(editor) {\n                        this.#editors.set(editor.id, editor);\n                        const { annotationElementId } = editor;\n                        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n                            this.#uiManager.removeDeletedAnnotationElement(editor);\n                        }\n                    }\n                    detach(editor) {\n                        this.#editors.delete(editor.id);\n                        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                        if (!this.#isDisabling && editor.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor);\n                        }\n                    }\n                    remove(editor) {\n                        this.detach(editor);\n                        this.#uiManager.removeEditor(editor);\n                        if (editor.div.contains(document.activeElement)) {\n                            setTimeout(()=>{\n                                this.#uiManager.focusMainContainer();\n                            }, 0);\n                        }\n                        editor.div.remove();\n                        editor.isAttachedToDOM = false;\n                        if (!this.#isCleaningUp) {\n                            this.addInkEditorIfNeeded(false);\n                        }\n                    }\n                    changeParent(editor) {\n                        if (editor.parent === this) {\n                            return;\n                        }\n                        if (editor.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n                            _editor.AnnotationEditor.deleteAnnotationElement(editor);\n                            editor.annotationElementId = null;\n                        }\n                        this.attach(editor);\n                        editor.parent?.detach(editor);\n                        editor.setParent(this);\n                        if (editor.div && editor.isAttachedToDOM) {\n                            editor.div.remove();\n                            this.div.append(editor.div);\n                        }\n                    }\n                    add(editor) {\n                        this.changeParent(editor);\n                        this.#uiManager.addEditor(editor);\n                        this.attach(editor);\n                        if (!editor.isAttachedToDOM) {\n                            const div = editor.render();\n                            this.div.append(div);\n                            editor.isAttachedToDOM = true;\n                        }\n                        editor.fixAndSetPosition();\n                        editor.onceAdded();\n                        this.#uiManager.addToAnnotationStorage(editor);\n                    }\n                    moveEditorInDOM(editor) {\n                        if (!editor.isAttachedToDOM) {\n                            return;\n                        }\n                        const { activeElement } = document;\n                        if (editor.div.contains(activeElement)) {\n                            editor._focusEventsAllowed = false;\n                            setTimeout(()=>{\n                                if (!editor.div.contains(document.activeElement)) {\n                                    editor.div.addEventListener(\"focusin\", ()=>{\n                                        editor._focusEventsAllowed = true;\n                                    }, {\n                                        once: true\n                                    });\n                                    activeElement.focus();\n                                } else {\n                                    editor._focusEventsAllowed = true;\n                                }\n                            }, 0);\n                        }\n                        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n                    }\n                    addOrRebuild(editor) {\n                        if (editor.needsToBeRebuilt()) {\n                            editor.rebuild();\n                        } else {\n                            this.add(editor);\n                        }\n                    }\n                    addUndoableEditor(editor) {\n                        const cmd = ()=>editor._uiManager.rebuild(editor);\n                        const undo = ()=>{\n                            editor.remove();\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: false\n                        });\n                    }\n                    getNextId() {\n                        return this.#uiManager.getId();\n                    }\n                    #createNewEditor(params) {\n                        switch(this.#uiManager.getMode()){\n                            case _util.AnnotationEditorType.FREETEXT:\n                                return new _freetext.FreeTextEditor(params);\n                            case _util.AnnotationEditorType.INK:\n                                return new _ink.InkEditor(params);\n                            case _util.AnnotationEditorType.STAMP:\n                                return new _stamp.StampEditor(params);\n                        }\n                        return null;\n                    }\n                    pasteEditor(mode, params) {\n                        this.#uiManager.updateToolbar(mode);\n                        this.#uiManager.updateMode(mode);\n                        const { offsetX, offsetY } = this.#getCenterPoint();\n                        const id = this.getNextId();\n                        const editor = this.#createNewEditor({\n                            parent: this,\n                            id,\n                            x: offsetX,\n                            y: offsetY,\n                            uiManager: this.#uiManager,\n                            isCentered: true,\n                            ...params\n                        });\n                        if (editor) {\n                            this.add(editor);\n                        }\n                    }\n                    deserialize(data) {\n                        switch(data.annotationType ?? data.annotationEditorType){\n                            case _util.AnnotationEditorType.FREETEXT:\n                                return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager);\n                            case _util.AnnotationEditorType.INK:\n                                return _ink.InkEditor.deserialize(data, this, this.#uiManager);\n                            case _util.AnnotationEditorType.STAMP:\n                                return _stamp.StampEditor.deserialize(data, this, this.#uiManager);\n                        }\n                        return null;\n                    }\n                    #createAndAddNewEditor(event, isCentered) {\n                        const id = this.getNextId();\n                        const editor = this.#createNewEditor({\n                            parent: this,\n                            id,\n                            x: event.offsetX,\n                            y: event.offsetY,\n                            uiManager: this.#uiManager,\n                            isCentered\n                        });\n                        if (editor) {\n                            this.add(editor);\n                        }\n                        return editor;\n                    }\n                    #getCenterPoint() {\n                        const { x, y, width, height } = this.div.getBoundingClientRect();\n                        const tlX = Math.max(0, x);\n                        const tlY = Math.max(0, y);\n                        const brX = Math.min(window.innerWidth, x + width);\n                        const brY = Math.min(window.innerHeight, y + height);\n                        const centerX = (tlX + brX) / 2 - x;\n                        const centerY = (tlY + brY) / 2 - y;\n                        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n                            centerX,\n                            centerY\n                        ] : [\n                            centerY,\n                            centerX\n                        ];\n                        return {\n                            offsetX,\n                            offsetY\n                        };\n                    }\n                    addNewEditor() {\n                        this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n                    }\n                    setSelected(editor) {\n                        this.#uiManager.setSelected(editor);\n                    }\n                    toggleSelected(editor) {\n                        this.#uiManager.toggleSelected(editor);\n                    }\n                    isSelected(editor) {\n                        return this.#uiManager.isSelected(editor);\n                    }\n                    unselect(editor) {\n                        this.#uiManager.unselect(editor);\n                    }\n                    pointerup(event) {\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        if (event.target !== this.div) {\n                            return;\n                        }\n                        if (!this.#hadPointerDown) {\n                            return;\n                        }\n                        this.#hadPointerDown = false;\n                        if (!this.#allowClick) {\n                            this.#allowClick = true;\n                            return;\n                        }\n                        if (this.#uiManager.getMode() === _util.AnnotationEditorType.STAMP) {\n                            this.#uiManager.unselectAll();\n                            return;\n                        }\n                        this.#createAndAddNewEditor(event, false);\n                    }\n                    pointerdown(event) {\n                        if (this.#hadPointerDown) {\n                            this.#hadPointerDown = false;\n                            return;\n                        }\n                        const { isMac } = _util.FeatureTest.platform;\n                        if (event.button !== 0 || event.ctrlKey && isMac) {\n                            return;\n                        }\n                        if (event.target !== this.div) {\n                            return;\n                        }\n                        this.#hadPointerDown = true;\n                        const editor = this.#uiManager.getActive();\n                        this.#allowClick = !editor || editor.isEmpty();\n                    }\n                    findNewParent(editor, x, y) {\n                        const layer = this.#uiManager.findParent(x, y);\n                        if (layer === null || layer === this) {\n                            return false;\n                        }\n                        layer.changeParent(editor);\n                        return true;\n                    }\n                    destroy() {\n                        if (this.#uiManager.getActive()?.parent === this) {\n                            this.#uiManager.commitOrRemove();\n                            this.#uiManager.setActiveEditor(null);\n                        }\n                        for (const editor of this.#editors.values()){\n                            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n                            editor.setParent(null);\n                            editor.isAttachedToDOM = false;\n                            editor.div.remove();\n                        }\n                        this.div = null;\n                        this.#editors.clear();\n                        this.#uiManager.removeLayer(this);\n                    }\n                    #cleanup() {\n                        this.#isCleaningUp = true;\n                        for (const editor of this.#editors.values()){\n                            if (editor.isEmpty()) {\n                                editor.remove();\n                            }\n                        }\n                        this.#isCleaningUp = false;\n                    }\n                    render({ viewport }) {\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(this.div, viewport);\n                        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n                            this.add(editor);\n                        }\n                        this.updateMode();\n                    }\n                    update({ viewport }) {\n                        this.#uiManager.commitOrRemove();\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(this.div, {\n                            rotation: viewport.rotation\n                        });\n                        this.updateMode();\n                    }\n                    get pageDimensions() {\n                        const { pageWidth, pageHeight } = this.viewport.rawDims;\n                        return [\n                            pageWidth,\n                            pageHeight\n                        ];\n                    }\n                }\n                exports1.AnnotationEditorLayer = AnnotationEditorLayer;\n            /***/ },\n            /* 28 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FreeTextEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _tools = __w_pdfjs_require__(5);\n                var _editor = __w_pdfjs_require__(4);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                class FreeTextEditor extends _editor.AnnotationEditor {\n                    #boundEditorDivBlur;\n                    #boundEditorDivFocus;\n                    #boundEditorDivInput;\n                    #boundEditorDivKeydown;\n                    #color;\n                    #content;\n                    #editorDivId;\n                    #fontSize;\n                    #initialData;\n                    static{\n                        this._freeTextDefaultContent = \"\";\n                    }\n                    static{\n                        this._internalPadding = 0;\n                    }\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultFontSize = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto = FreeTextEditor.prototype;\n                        const arrowChecker = (self)=>self.isEmpty();\n                        const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n                        const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n                        return (0, _util.shadow)(this, \"_keyboardManager\", new _tools.KeyboardManager([\n                            [\n                                [\n                                    \"ctrl+s\",\n                                    \"mac+meta+s\",\n                                    \"ctrl+p\",\n                                    \"mac+meta+p\"\n                                ],\n                                proto.commitOrRemove,\n                                {\n                                    bubbles: true\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+Enter\",\n                                    \"mac+meta+Enter\",\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto.commitOrRemove\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        -small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        -big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        small,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        big,\n                                        0\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        small\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        big\n                                    ],\n                                    checker: arrowChecker\n                                }\n                            ]\n                        ]));\n                    }\n                    static{\n                        this._type = \"freetext\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"freeTextEditor\"\n                        });\n                        this.#boundEditorDivBlur = this.editorDivBlur.bind(this);\n                        this.#boundEditorDivFocus = this.editorDivFocus.bind(this);\n                        this.#boundEditorDivInput = this.editorDivInput.bind(this);\n                        this.#boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n                        this.#content = \"\";\n                        this.#editorDivId = `${this.id}-editor`;\n                        this.#initialData = null;\n                        this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n                        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n, {\n                            strings: [\n                                \"free_text2_default_content\",\n                                \"editor_free_text2_aria_label\"\n                            ]\n                        });\n                        const style = getComputedStyle(document.documentElement);\n                        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n                    }\n                    static updateDefaultParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                FreeTextEditor._defaultFontSize = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                FreeTextEditor._defaultColor = value;\n                                break;\n                        }\n                    }\n                    updateParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                this.#updateFontSize(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                this.#updateColor(value);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                FreeTextEditor._defaultFontSize\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                this.#fontSize\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                this.#color\n                            ]\n                        ];\n                    }\n                    #updateFontSize(fontSize) {\n                        const setFontsize = (size)=>{\n                            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n                            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n                            this.#fontSize = size;\n                            this.#setEditorDimensions();\n                        };\n                        const savedFontsize = this.#fontSize;\n                        this.addCommands({\n                            cmd: ()=>{\n                                setFontsize(fontSize);\n                            },\n                            undo: ()=>{\n                                setFontsize(savedFontsize);\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color) {\n                        const savedColor = this.#color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.#color = this.editorDiv.style.color = color;\n                            },\n                            undo: ()=>{\n                                this.#color = this.editorDiv.style.color = savedColor;\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    _translateEmpty(x, y) {\n                        this._uiManager.translateSelectedEditors(x, y, true);\n                    }\n                    getInitialTranslation() {\n                        const scale = this.parentScale;\n                        return [\n                            -FreeTextEditor._internalPadding * scale,\n                            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n                        ];\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    enableEditMode() {\n                        if (this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(false);\n                        this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n                        super.enableEditMode();\n                        this.overlayDiv.classList.remove(\"enabled\");\n                        this.editorDiv.contentEditable = true;\n                        this._isDraggable = false;\n                        this.div.removeAttribute(\"aria-activedescendant\");\n                        this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(true);\n                        super.disableEditMode();\n                        this.overlayDiv.classList.add(\"enabled\");\n                        this.editorDiv.contentEditable = false;\n                        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n                        this._isDraggable = true;\n                        this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                        this.isEditing = false;\n                        this.parent.div.classList.add(\"freeTextEditing\");\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event);\n                        if (event.target !== this.editorDiv) {\n                            this.editorDiv.focus();\n                        }\n                    }\n                    onceAdded() {\n                        if (this.width) {\n                            this.#cheatInitialRect();\n                            return;\n                        }\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        }\n                        this._initialOptions = null;\n                    }\n                    isEmpty() {\n                        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n                    }\n                    remove() {\n                        this.isEditing = false;\n                        if (this.parent) {\n                            this.parent.setEditingState(true);\n                            this.parent.div.classList.add(\"freeTextEditing\");\n                        }\n                        super.remove();\n                    }\n                    #extractText() {\n                        const divs = this.editorDiv.getElementsByTagName(\"div\");\n                        if (divs.length === 0) {\n                            return this.editorDiv.innerText;\n                        }\n                        const buffer = [];\n                        for (const div of divs){\n                            buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n                        }\n                        return buffer.join(\"\\n\");\n                    }\n                    #setEditorDimensions() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        let rect;\n                        if (this.isAttachedToDOM) {\n                            rect = this.div.getBoundingClientRect();\n                        } else {\n                            const { currentLayer, div } = this;\n                            const savedDisplay = div.style.display;\n                            div.style.display = \"hidden\";\n                            currentLayer.div.append(this.div);\n                            rect = div.getBoundingClientRect();\n                            div.remove();\n                            div.style.display = savedDisplay;\n                        }\n                        if (this.rotation % 180 === this.parentRotation % 180) {\n                            this.width = rect.width / parentWidth;\n                            this.height = rect.height / parentHeight;\n                        } else {\n                            this.width = rect.height / parentWidth;\n                            this.height = rect.width / parentHeight;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    commit() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        super.commit();\n                        this.disableEditMode();\n                        const savedText = this.#content;\n                        const newText = this.#content = this.#extractText().trimEnd();\n                        if (savedText === newText) {\n                            return;\n                        }\n                        const setText = (text)=>{\n                            this.#content = text;\n                            if (!text) {\n                                this.remove();\n                                return;\n                            }\n                            this.#setContent();\n                            this._uiManager.rebuild(this);\n                            this.#setEditorDimensions();\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                setText(newText);\n                            },\n                            undo: ()=>{\n                                setText(savedText);\n                            },\n                            mustExec: false\n                        });\n                        this.#setEditorDimensions();\n                    }\n                    shouldGetKeyboardEvents() {\n                        return this.isInEditMode();\n                    }\n                    enterInEditMode() {\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                    }\n                    dblclick(event) {\n                        this.enterInEditMode();\n                    }\n                    keydown(event) {\n                        if (event.target === this.div && event.key === \"Enter\") {\n                            this.enterInEditMode();\n                            event.preventDefault();\n                        }\n                    }\n                    editorDivKeydown(event) {\n                        FreeTextEditor._keyboardManager.exec(this, event);\n                    }\n                    editorDivFocus(event) {\n                        this.isEditing = true;\n                    }\n                    editorDivBlur(event) {\n                        this.isEditing = false;\n                    }\n                    editorDivInput(event) {\n                        this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n                    }\n                    disableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"comment\");\n                        this.editorDiv.removeAttribute(\"aria-multiline\");\n                    }\n                    enableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"textbox\");\n                        this.editorDiv.setAttribute(\"aria-multiline\", true);\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        this.editorDiv = document.createElement(\"div\");\n                        this.editorDiv.className = \"internal\";\n                        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n                        this.enableEditing();\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then((msg)=>this.editorDiv?.setAttribute(\"aria-label\", msg));\n                        _editor.AnnotationEditor._l10nPromise.get(\"free_text2_default_content\").then((msg)=>this.editorDiv?.setAttribute(\"default-content\", msg));\n                        this.editorDiv.contentEditable = true;\n                        const { style } = this.editorDiv;\n                        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n                        style.color = this.#color;\n                        this.div.append(this.editorDiv);\n                        this.overlayDiv = document.createElement(\"div\");\n                        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n                        this.div.append(this.overlayDiv);\n                        (0, _tools.bindEvents)(this, this.div, [\n                            \"dblclick\",\n                            \"keydown\"\n                        ]);\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            if (this.annotationElementId) {\n                                const { position } = this.#initialData;\n                                let [tx, ty] = this.getInitialTranslation();\n                                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                                const [pageWidth, pageHeight] = this.pageDimensions;\n                                const [pageX, pageY] = this.pageTranslation;\n                                let posX, posY;\n                                switch(this.rotation){\n                                    case 0:\n                                        posX = baseX + (position[0] - pageX) / pageWidth;\n                                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                                        break;\n                                    case 90:\n                                        posX = baseX + (position[0] - pageX) / pageWidth;\n                                        posY = baseY - (position[1] - pageY) / pageHeight;\n                                        [tx, ty] = [\n                                            ty,\n                                            -tx\n                                        ];\n                                        break;\n                                    case 180:\n                                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                                        posY = baseY - (position[1] - pageY) / pageHeight;\n                                        [tx, ty] = [\n                                            -tx,\n                                            -ty\n                                        ];\n                                        break;\n                                    case 270:\n                                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                                        [tx, ty] = [\n                                            -ty,\n                                            tx\n                                        ];\n                                        break;\n                                }\n                                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n                            } else {\n                                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                            }\n                            this.#setContent();\n                            this._isDraggable = true;\n                            this.editorDiv.contentEditable = false;\n                        } else {\n                            this._isDraggable = false;\n                            this.editorDiv.contentEditable = true;\n                        }\n                        return this.div;\n                    }\n                    #setContent() {\n                        this.editorDiv.replaceChildren();\n                        if (!this.#content) {\n                            return;\n                        }\n                        for (const line of this.#content.split(\"\\n\")){\n                            const div = document.createElement(\"div\");\n                            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n                            this.editorDiv.append(div);\n                        }\n                    }\n                    get contentDiv() {\n                        return this.editorDiv;\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        let initialData = null;\n                        if (data instanceof _annotation_layer.FreeTextAnnotationElement) {\n                            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n                            if (!textContent || textContent.length === 0) {\n                                return null;\n                            }\n                            initialData = data = {\n                                annotationType: _util.AnnotationEditorType.FREETEXT,\n                                color: Array.from(fontColor),\n                                fontSize,\n                                value: textContent.join(\"\\n\"),\n                                position: textPosition,\n                                pageIndex: pageNumber - 1,\n                                rect,\n                                rotation,\n                                id,\n                                deleted: false\n                            };\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        editor.#fontSize = data.fontSize;\n                        editor.#color = _util.Util.makeHexColor(...data.color);\n                        editor.#content = data.value;\n                        editor.annotationElementId = data.id || null;\n                        editor.#initialData = initialData;\n                        return editor;\n                    }\n                    serialize(isForCopying = false) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        if (this.deleted) {\n                            return {\n                                pageIndex: this.pageIndex,\n                                id: this.annotationElementId,\n                                deleted: true\n                            };\n                        }\n                        const padding = FreeTextEditor._internalPadding * this.parentScale;\n                        const rect = this.getRect(padding, padding);\n                        const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n                        const serialized = {\n                            annotationType: _util.AnnotationEditorType.FREETEXT,\n                            color,\n                            fontSize: this.#fontSize,\n                            value: this.#content,\n                            pageIndex: this.pageIndex,\n                            rect,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying) {\n                            return serialized;\n                        }\n                        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n                            return null;\n                        }\n                        serialized.id = this.annotationElementId;\n                        return serialized;\n                    }\n                    #hasElementChanged(serialized) {\n                        const { value, fontSize, color, rect, pageIndex } = this.#initialData;\n                        return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i)=>Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n                    }\n                    #cheatInitialRect(delayed = false) {\n                        if (!this.annotationElementId) {\n                            return;\n                        }\n                        this.#setEditorDimensions();\n                        if (!delayed && (this.width === 0 || this.height === 0)) {\n                            setTimeout(()=>this.#cheatInitialRect(true), 0);\n                            return;\n                        }\n                        const padding = FreeTextEditor._internalPadding * this.parentScale;\n                        this.#initialData.rect = this.getRect(padding, padding);\n                    }\n                }\n                exports1.FreeTextEditor = FreeTextEditor;\n            /***/ },\n            /* 29 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampAnnotationElement = exports1.InkAnnotationElement = exports1.FreeTextAnnotationElement = exports1.AnnotationLayer = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _annotation_storage = __w_pdfjs_require__(3);\n                var _scripting_utils = __w_pdfjs_require__(30);\n                var _displayL10n_utils = __w_pdfjs_require__(31);\n                var _xfa_layer = __w_pdfjs_require__(32);\n                const DEFAULT_TAB_INDEX = 1000;\n                const DEFAULT_FONT_SIZE = 9;\n                const GetElementsByNameSet = new WeakSet();\n                function getRectDims(rect) {\n                    return {\n                        width: rect[2] - rect[0],\n                        height: rect[3] - rect[1]\n                    };\n                }\n                class AnnotationElementFactory {\n                    static create(parameters) {\n                        const subtype = parameters.data.annotationType;\n                        switch(subtype){\n                            case _util.AnnotationType.LINK:\n                                return new LinkAnnotationElement(parameters);\n                            case _util.AnnotationType.TEXT:\n                                return new TextAnnotationElement(parameters);\n                            case _util.AnnotationType.WIDGET:\n                                const fieldType = parameters.data.fieldType;\n                                switch(fieldType){\n                                    case \"Tx\":\n                                        return new TextWidgetAnnotationElement(parameters);\n                                    case \"Btn\":\n                                        if (parameters.data.radioButton) {\n                                            return new RadioButtonWidgetAnnotationElement(parameters);\n                                        } else if (parameters.data.checkBox) {\n                                            return new CheckboxWidgetAnnotationElement(parameters);\n                                        }\n                                        return new PushButtonWidgetAnnotationElement(parameters);\n                                    case \"Ch\":\n                                        return new ChoiceWidgetAnnotationElement(parameters);\n                                    case \"Sig\":\n                                        return new SignatureWidgetAnnotationElement(parameters);\n                                }\n                                return new WidgetAnnotationElement(parameters);\n                            case _util.AnnotationType.POPUP:\n                                return new PopupAnnotationElement(parameters);\n                            case _util.AnnotationType.FREETEXT:\n                                return new FreeTextAnnotationElement(parameters);\n                            case _util.AnnotationType.LINE:\n                                return new LineAnnotationElement(parameters);\n                            case _util.AnnotationType.SQUARE:\n                                return new SquareAnnotationElement(parameters);\n                            case _util.AnnotationType.CIRCLE:\n                                return new CircleAnnotationElement(parameters);\n                            case _util.AnnotationType.POLYLINE:\n                                return new PolylineAnnotationElement(parameters);\n                            case _util.AnnotationType.CARET:\n                                return new CaretAnnotationElement(parameters);\n                            case _util.AnnotationType.INK:\n                                return new InkAnnotationElement(parameters);\n                            case _util.AnnotationType.POLYGON:\n                                return new PolygonAnnotationElement(parameters);\n                            case _util.AnnotationType.HIGHLIGHT:\n                                return new HighlightAnnotationElement(parameters);\n                            case _util.AnnotationType.UNDERLINE:\n                                return new UnderlineAnnotationElement(parameters);\n                            case _util.AnnotationType.SQUIGGLY:\n                                return new SquigglyAnnotationElement(parameters);\n                            case _util.AnnotationType.STRIKEOUT:\n                                return new StrikeOutAnnotationElement(parameters);\n                            case _util.AnnotationType.STAMP:\n                                return new StampAnnotationElement(parameters);\n                            case _util.AnnotationType.FILEATTACHMENT:\n                                return new FileAttachmentAnnotationElement(parameters);\n                            default:\n                                return new AnnotationElement(parameters);\n                        }\n                    }\n                }\n                class AnnotationElement {\n                    #hasBorder;\n                    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n                        this.#hasBorder = false;\n                        this.isRenderable = isRenderable;\n                        this.data = parameters.data;\n                        this.layer = parameters.layer;\n                        this.linkService = parameters.linkService;\n                        this.downloadManager = parameters.downloadManager;\n                        this.imageResourcesPath = parameters.imageResourcesPath;\n                        this.renderForms = parameters.renderForms;\n                        this.svgFactory = parameters.svgFactory;\n                        this.annotationStorage = parameters.annotationStorage;\n                        this.enableScripting = parameters.enableScripting;\n                        this.hasJSActions = parameters.hasJSActions;\n                        this._fieldObjects = parameters.fieldObjects;\n                        this.parent = parameters.parent;\n                        if (isRenderable) {\n                            this.container = this._createContainer(ignoreBorder);\n                        }\n                        if (createQuadrilaterals) {\n                            this._createQuadrilaterals();\n                        }\n                    }\n                    static _hasPopupData({ titleObj, contentsObj, richText }) {\n                        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n                    }\n                    get hasPopupData() {\n                        return AnnotationElement._hasPopupData(this.data);\n                    }\n                    _createContainer(ignoreBorder) {\n                        const { data, parent: { page, viewport } } = this;\n                        const container = document.createElement(\"section\");\n                        container.setAttribute(\"data-annotation-id\", data.id);\n                        if (!(this instanceof WidgetAnnotationElement)) {\n                            container.tabIndex = DEFAULT_TAB_INDEX;\n                        }\n                        container.style.zIndex = this.parent.zIndex++;\n                        if (this.data.popupRef) {\n                            container.setAttribute(\"aria-haspopup\", \"dialog\");\n                        }\n                        if (data.noRotate) {\n                            container.classList.add(\"norotate\");\n                        }\n                        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n                        if (!data.rect || this instanceof PopupAnnotationElement) {\n                            const { rotation } = data;\n                            if (!data.hasOwnCanvas && rotation !== 0) {\n                                this.setRotation(rotation, container);\n                            }\n                            return container;\n                        }\n                        const { width, height } = getRectDims(data.rect);\n                        const rect = _util.Util.normalizeRect([\n                            data.rect[0],\n                            page.view[3] - data.rect[1] + page.view[1],\n                            data.rect[2],\n                            page.view[3] - data.rect[3] + page.view[1]\n                        ]);\n                        if (!ignoreBorder && data.borderStyle.width > 0) {\n                            container.style.borderWidth = `${data.borderStyle.width}px`;\n                            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n                            const verticalRadius = data.borderStyle.verticalCornerRadius;\n                            if (horizontalRadius > 0 || verticalRadius > 0) {\n                                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                                container.style.borderRadius = radius;\n                            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                                container.style.borderRadius = radius;\n                            }\n                            switch(data.borderStyle.style){\n                                case _util.AnnotationBorderStyleType.SOLID:\n                                    container.style.borderStyle = \"solid\";\n                                    break;\n                                case _util.AnnotationBorderStyleType.DASHED:\n                                    container.style.borderStyle = \"dashed\";\n                                    break;\n                                case _util.AnnotationBorderStyleType.BEVELED:\n                                    (0, _util.warn)(\"Unimplemented border style: beveled\");\n                                    break;\n                                case _util.AnnotationBorderStyleType.INSET:\n                                    (0, _util.warn)(\"Unimplemented border style: inset\");\n                                    break;\n                                case _util.AnnotationBorderStyleType.UNDERLINE:\n                                    container.style.borderBottomStyle = \"solid\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                            const borderColor = data.borderColor || null;\n                            if (borderColor) {\n                                this.#hasBorder = true;\n                                container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n                            } else {\n                                container.style.borderWidth = 0;\n                            }\n                        }\n                        container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n                        container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n                        const { rotation } = data;\n                        if (data.hasOwnCanvas || rotation === 0) {\n                            container.style.width = `${100 * width / pageWidth}%`;\n                            container.style.height = `${100 * height / pageHeight}%`;\n                        } else {\n                            this.setRotation(rotation, container);\n                        }\n                        return container;\n                    }\n                    setRotation(angle, container = this.container) {\n                        if (!this.data.rect) {\n                            return;\n                        }\n                        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n                        const { width, height } = getRectDims(this.data.rect);\n                        let elementWidth, elementHeight;\n                        if (angle % 180 === 0) {\n                            elementWidth = 100 * width / pageWidth;\n                            elementHeight = 100 * height / pageHeight;\n                        } else {\n                            elementWidth = 100 * height / pageWidth;\n                            elementHeight = 100 * width / pageHeight;\n                        }\n                        container.style.width = `${elementWidth}%`;\n                        container.style.height = `${elementHeight}%`;\n                        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n                    }\n                    get _commonActions() {\n                        const setColor = (jsName, styleName, event)=>{\n                            const color = event.detail[jsName];\n                            const colorType = color[0];\n                            const colorArray = color.slice(1);\n                            event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);\n                            this.annotationStorage.setValue(this.data.id, {\n                                [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)\n                            });\n                        };\n                        return (0, _util.shadow)(this, \"_commonActions\", {\n                            display: (event)=>{\n                                const { display } = event.detail;\n                                const hidden = display % 2 === 1;\n                                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noView: hidden,\n                                    noPrint: display === 1 || display === 2\n                                });\n                            },\n                            print: (event)=>{\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: !event.detail.print\n                                });\n                            },\n                            hidden: (event)=>{\n                                const { hidden } = event.detail;\n                                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: hidden,\n                                    noView: hidden\n                                });\n                            },\n                            focus: (event)=>{\n                                setTimeout(()=>event.target.focus({\n                                        preventScroll: false\n                                    }), 0);\n                            },\n                            userName: (event)=>{\n                                event.target.title = event.detail.userName;\n                            },\n                            readonly: (event)=>{\n                                event.target.disabled = event.detail.readonly;\n                            },\n                            required: (event)=>{\n                                this._setRequired(event.target, event.detail.required);\n                            },\n                            bgColor: (event)=>{\n                                setColor(\"bgColor\", \"backgroundColor\", event);\n                            },\n                            fillColor: (event)=>{\n                                setColor(\"fillColor\", \"backgroundColor\", event);\n                            },\n                            fgColor: (event)=>{\n                                setColor(\"fgColor\", \"color\", event);\n                            },\n                            textColor: (event)=>{\n                                setColor(\"textColor\", \"color\", event);\n                            },\n                            borderColor: (event)=>{\n                                setColor(\"borderColor\", \"borderColor\", event);\n                            },\n                            strokeColor: (event)=>{\n                                setColor(\"strokeColor\", \"borderColor\", event);\n                            },\n                            rotation: (event)=>{\n                                const angle = event.detail.rotation;\n                                this.setRotation(angle);\n                                this.annotationStorage.setValue(this.data.id, {\n                                    rotation: angle\n                                });\n                            }\n                        });\n                    }\n                    _dispatchEventFromSandbox(actions, jsEvent) {\n                        const commonActions = this._commonActions;\n                        for (const name of Object.keys(jsEvent.detail)){\n                            const action = actions[name] || commonActions[name];\n                            action?.(jsEvent);\n                        }\n                    }\n                    _setDefaultPropertiesFromJS(element) {\n                        if (!this.enableScripting) {\n                            return;\n                        }\n                        const storedData = this.annotationStorage.getRawValue(this.data.id);\n                        if (!storedData) {\n                            return;\n                        }\n                        const commonActions = this._commonActions;\n                        for (const [actionName, detail] of Object.entries(storedData)){\n                            const action = commonActions[actionName];\n                            if (action) {\n                                const eventProxy = {\n                                    detail: {\n                                        [actionName]: detail\n                                    },\n                                    target: element\n                                };\n                                action(eventProxy);\n                                delete storedData[actionName];\n                            }\n                        }\n                    }\n                    _createQuadrilaterals() {\n                        if (!this.container) {\n                            return;\n                        }\n                        const { quadPoints } = this.data;\n                        if (!quadPoints) {\n                            return;\n                        }\n                        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;\n                        if (quadPoints.length === 1) {\n                            const [, { x: trX, y: trY }, { x: blX, y: blY }] = quadPoints[0];\n                            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                                return;\n                            }\n                        }\n                        const { style } = this.container;\n                        let svgBuffer;\n                        if (this.#hasBorder) {\n                            const { borderColor, borderWidth } = style;\n                            style.borderWidth = 0;\n                            svgBuffer = [\n                                \"url('data:image/svg+xml;utf8,\",\n                                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n                            ];\n                            this.container.classList.add(\"hasBorder\");\n                        }\n                        const width = rectTrX - rectBlX;\n                        const height = rectTrY - rectBlY;\n                        const { svgFactory } = this;\n                        const svg = svgFactory.createElement(\"svg\");\n                        svg.classList.add(\"quadrilateralsContainer\");\n                        svg.setAttribute(\"width\", 0);\n                        svg.setAttribute(\"height\", 0);\n                        const defs = svgFactory.createElement(\"defs\");\n                        svg.append(defs);\n                        const clipPath = svgFactory.createElement(\"clipPath\");\n                        const id = `clippath_${this.data.id}`;\n                        clipPath.setAttribute(\"id\", id);\n                        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n                        defs.append(clipPath);\n                        for (const [, { x: trX, y: trY }, { x: blX, y: blY }] of quadPoints){\n                            const rect = svgFactory.createElement(\"rect\");\n                            const x = (blX - rectBlX) / width;\n                            const y = (rectTrY - trY) / height;\n                            const rectWidth = (trX - blX) / width;\n                            const rectHeight = (trY - blY) / height;\n                            rect.setAttribute(\"x\", x);\n                            rect.setAttribute(\"y\", y);\n                            rect.setAttribute(\"width\", rectWidth);\n                            rect.setAttribute(\"height\", rectHeight);\n                            clipPath.append(rect);\n                            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n                        }\n                        if (this.#hasBorder) {\n                            svgBuffer.push(`</g></svg>')`);\n                            style.backgroundImage = svgBuffer.join(\"\");\n                        }\n                        this.container.append(svg);\n                        this.container.style.clipPath = `url(#${id})`;\n                    }\n                    _createPopup() {\n                        const { container, data } = this;\n                        container.setAttribute(\"aria-haspopup\", \"dialog\");\n                        const popup = new PopupAnnotationElement({\n                            data: {\n                                color: data.color,\n                                titleObj: data.titleObj,\n                                modificationDate: data.modificationDate,\n                                contentsObj: data.contentsObj,\n                                richText: data.richText,\n                                parentRect: data.rect,\n                                borderStyle: 0,\n                                id: `popup_${data.id}`,\n                                rotation: data.rotation\n                            },\n                            parent: this.parent,\n                            elements: [\n                                this\n                            ]\n                        });\n                        this.parent.div.append(popup.render());\n                    }\n                    render() {\n                        (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n                    }\n                    _getElementsByName(name, skipId = null) {\n                        const fields = [];\n                        if (this._fieldObjects) {\n                            const fieldObj = this._fieldObjects[name];\n                            if (fieldObj) {\n                                for (const { page, id, exportValues } of fieldObj){\n                                    if (page === -1) {\n                                        continue;\n                                    }\n                                    if (id === skipId) {\n                                        continue;\n                                    }\n                                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                                        (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n                                        continue;\n                                    }\n                                    fields.push({\n                                        id,\n                                        exportValue,\n                                        domElement\n                                    });\n                                }\n                            }\n                            return fields;\n                        }\n                        for (const domElement of document.getElementsByName(name)){\n                            const { exportValue } = domElement;\n                            const id = domElement.getAttribute(\"data-element-id\");\n                            if (id === skipId) {\n                                continue;\n                            }\n                            if (!GetElementsByNameSet.has(domElement)) {\n                                continue;\n                            }\n                            fields.push({\n                                id,\n                                exportValue,\n                                domElement\n                            });\n                        }\n                        return fields;\n                    }\n                    show() {\n                        if (this.container) {\n                            this.container.hidden = false;\n                        }\n                        this.popup?.maybeShow();\n                    }\n                    hide() {\n                        if (this.container) {\n                            this.container.hidden = true;\n                        }\n                        this.popup?.forceHide();\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.container;\n                    }\n                    addHighlightArea() {\n                        const triggers = this.getElementsToTriggerPopup();\n                        if (Array.isArray(triggers)) {\n                            for (const element of triggers){\n                                element.classList.add(\"highlightArea\");\n                            }\n                        } else {\n                            triggers.classList.add(\"highlightArea\");\n                        }\n                    }\n                    _editOnDoubleClick() {\n                        const { annotationEditorType: mode, data: { id: editId } } = this;\n                        this.container.addEventListener(\"dblclick\", ()=>{\n                            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                                source: this,\n                                mode,\n                                editId\n                            });\n                        });\n                    }\n                }\n                class LinkAnnotationElement extends AnnotationElement {\n                    constructor(parameters, options = null){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: !!options?.ignoreBorder,\n                            createQuadrilaterals: true\n                        });\n                        this.isTooltipOnly = parameters.data.isTooltipOnly;\n                    }\n                    render() {\n                        const { data, linkService } = this;\n                        const link = document.createElement(\"a\");\n                        link.setAttribute(\"data-element-id\", data.id);\n                        let isBound = false;\n                        if (data.url) {\n                            linkService.addLinkAttributes(link, data.url, data.newWindow);\n                            isBound = true;\n                        } else if (data.action) {\n                            this._bindNamedAction(link, data.action);\n                            isBound = true;\n                        } else if (data.attachment) {\n                            this._bindAttachment(link, data.attachment);\n                            isBound = true;\n                        } else if (data.setOCGState) {\n                            this.#bindSetOCGState(link, data.setOCGState);\n                            isBound = true;\n                        } else if (data.dest) {\n                            this._bindLink(link, data.dest);\n                            isBound = true;\n                        } else {\n                            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                                this._bindJSAction(link, data);\n                                isBound = true;\n                            }\n                            if (data.resetForm) {\n                                this._bindResetFormAction(link, data.resetForm);\n                                isBound = true;\n                            } else if (this.isTooltipOnly && !isBound) {\n                                this._bindLink(link, \"\");\n                                isBound = true;\n                            }\n                        }\n                        this.container.classList.add(\"linkAnnotation\");\n                        if (isBound) {\n                            this.container.append(link);\n                        }\n                        return this.container;\n                    }\n                    #setInternalLink() {\n                        this.container.setAttribute(\"data-internal-link\", \"\");\n                    }\n                    _bindLink(link, destination) {\n                        link.href = this.linkService.getDestinationHash(destination);\n                        link.onclick = ()=>{\n                            if (destination) {\n                                this.linkService.goToDestination(destination);\n                            }\n                            return false;\n                        };\n                        if (destination || destination === \"\") {\n                            this.#setInternalLink();\n                        }\n                    }\n                    _bindNamedAction(link, action) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.linkService.executeNamedAction(action);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindAttachment(link, attachment) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    #bindSetOCGState(link, action) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        link.onclick = ()=>{\n                            this.linkService.executeSetOCGState(action);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindJSAction(link, data) {\n                        link.href = this.linkService.getAnchorUrl(\"\");\n                        const map = new Map([\n                            [\n                                \"Action\",\n                                \"onclick\"\n                            ],\n                            [\n                                \"Mouse Up\",\n                                \"onmouseup\"\n                            ],\n                            [\n                                \"Mouse Down\",\n                                \"onmousedown\"\n                            ]\n                        ]);\n                        for (const name of Object.keys(data.actions)){\n                            const jsName = map.get(name);\n                            if (!jsName) {\n                                continue;\n                            }\n                            link[jsName] = ()=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: data.id,\n                                        name\n                                    }\n                                });\n                                return false;\n                            };\n                        }\n                        if (!link.onclick) {\n                            link.onclick = ()=>false;\n                        }\n                        this.#setInternalLink();\n                    }\n                    _bindResetFormAction(link, resetForm) {\n                        const otherClickAction = link.onclick;\n                        if (!otherClickAction) {\n                            link.href = this.linkService.getAnchorUrl(\"\");\n                        }\n                        this.#setInternalLink();\n                        if (!this._fieldObjects) {\n                            (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n                            if (!otherClickAction) {\n                                link.onclick = ()=>false;\n                            }\n                            return;\n                        }\n                        link.onclick = ()=>{\n                            otherClickAction?.();\n                            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n                            const allFields = [];\n                            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                                const fieldIds = new Set(resetFormRefs);\n                                for (const fieldName of resetFormFields){\n                                    const fields = this._fieldObjects[fieldName] || [];\n                                    for (const { id } of fields){\n                                        fieldIds.add(id);\n                                    }\n                                }\n                                for (const fields of Object.values(this._fieldObjects)){\n                                    for (const field of fields){\n                                        if (fieldIds.has(field.id) === include) {\n                                            allFields.push(field);\n                                        }\n                                    }\n                                }\n                            } else {\n                                for (const fields of Object.values(this._fieldObjects)){\n                                    allFields.push(...fields);\n                                }\n                            }\n                            const storage = this.annotationStorage;\n                            const allIds = [];\n                            for (const field of allFields){\n                                const { id } = field;\n                                allIds.push(id);\n                                switch(field.type){\n                                    case \"text\":\n                                        {\n                                            const value = field.defaultValue || \"\";\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    case \"checkbox\":\n                                    case \"radiobutton\":\n                                        {\n                                            const value = field.defaultValue === field.exportValues;\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    case \"combobox\":\n                                    case \"listbox\":\n                                        {\n                                            const value = field.defaultValue || \"\";\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            break;\n                                        }\n                                    default:\n                                        continue;\n                                }\n                                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                                if (!domElement) {\n                                    continue;\n                                } else if (!GetElementsByNameSet.has(domElement)) {\n                                    (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n                                    continue;\n                                }\n                                domElement.dispatchEvent(new Event(\"resetform\"));\n                            }\n                            if (this.enableScripting) {\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: \"app\",\n                                        ids: allIds,\n                                        name: \"ResetForm\"\n                                    }\n                                });\n                            }\n                            return false;\n                        };\n                    }\n                }\n                class TextAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"textAnnotation\");\n                        const image = document.createElement(\"img\");\n                        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n                        image.alt = \"[{{type}} Annotation]\";\n                        image.dataset.l10nId = \"text_annotation_type\";\n                        image.dataset.l10nArgs = JSON.stringify({\n                            type: this.data.name\n                        });\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.append(image);\n                        return this.container;\n                    }\n                }\n                class WidgetAnnotationElement extends AnnotationElement {\n                    render() {\n                        if (this.data.alternativeText) {\n                            this.container.title = this.data.alternativeText;\n                        }\n                        return this.container;\n                    }\n                    showElementAndHideCanvas(element) {\n                        if (this.data.hasOwnCanvas) {\n                            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                                element.previousSibling.hidden = true;\n                            }\n                            element.hidden = false;\n                        }\n                    }\n                    _getKeyModifier(event) {\n                        const { isWin, isMac } = _util.FeatureTest.platform;\n                        return isWin && event.ctrlKey || isMac && event.metaKey;\n                    }\n                    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n                        if (baseName.includes(\"mouse\")) {\n                            element.addEventListener(baseName, (event)=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName,\n                                        value: valueGetter(event),\n                                        shift: event.shiftKey,\n                                        modifier: this._getKeyModifier(event)\n                                    }\n                                });\n                            });\n                        } else {\n                            element.addEventListener(baseName, (event)=>{\n                                if (baseName === \"blur\") {\n                                    if (!elementData.focused || !event.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData.focused = false;\n                                } else if (baseName === \"focus\") {\n                                    if (elementData.focused) {\n                                        return;\n                                    }\n                                    elementData.focused = true;\n                                }\n                                if (!valueGetter) {\n                                    return;\n                                }\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName,\n                                        value: valueGetter(event)\n                                    }\n                                });\n                            });\n                        }\n                    }\n                    _setEventListeners(element, elementData, names, getter) {\n                        for (const [baseName, eventName] of names){\n                            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                                    elementData ||= {\n                                        focused: false\n                                    };\n                                }\n                                this._setEventListener(element, elementData, baseName, eventName, getter);\n                                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                                }\n                            }\n                        }\n                    }\n                    _setBackgroundColor(element) {\n                        const color = this.data.backgroundColor || null;\n                        element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n                    }\n                    _setTextStyle(element) {\n                        const TEXT_ALIGNMENT = [\n                            \"left\",\n                            \"center\",\n                            \"right\"\n                        ];\n                        const { fontColor } = this.data.defaultAppearanceData;\n                        const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n                        const style = element.style;\n                        let computedFontSize;\n                        const BORDER_SIZE = 2;\n                        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n                        if (this.data.multiLine) {\n                            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                            const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n                            const lineHeight = height / numberOfLines;\n                            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));\n                        } else {\n                            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n                            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR));\n                        }\n                        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n                        style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n                        if (this.data.textAlignment !== null) {\n                            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n                        }\n                    }\n                    _setRequired(element, isRequired) {\n                        if (isRequired) {\n                            element.setAttribute(\"required\", true);\n                        } else {\n                            element.removeAttribute(\"required\");\n                        }\n                        element.setAttribute(\"aria-required\", isRequired);\n                    }\n                }\n                class TextWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n                        super(parameters, {\n                            isRenderable\n                        });\n                    }\n                    setPropertyOnSiblings(base, key, value, keyInStorage) {\n                        const storage = this.annotationStorage;\n                        for (const element of this._getElementsByName(base.name, base.id)){\n                            if (element.domElement) {\n                                element.domElement[key] = value;\n                            }\n                            storage.setValue(element.id, {\n                                [keyInStorage]: value\n                            });\n                        }\n                    }\n                    render() {\n                        const storage = this.annotationStorage;\n                        const id = this.data.id;\n                        this.container.classList.add(\"textWidgetAnnotation\");\n                        let element = null;\n                        if (this.renderForms) {\n                            const storedData = storage.getValue(id, {\n                                value: this.data.fieldValue\n                            });\n                            let textContent = storedData.value || \"\";\n                            const maxLen = storage.getValue(id, {\n                                charLimit: this.data.maxLen\n                            }).charLimit;\n                            if (maxLen && textContent.length > maxLen) {\n                                textContent = textContent.slice(0, maxLen);\n                            }\n                            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n                            if (fieldFormattedValues && this.data.comb) {\n                                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n                            }\n                            const elementData = {\n                                userValue: textContent,\n                                formattedValue: fieldFormattedValues,\n                                lastCommittedValue: null,\n                                commitKey: 1,\n                                focused: false\n                            };\n                            if (this.data.multiLine) {\n                                element = document.createElement(\"textarea\");\n                                element.textContent = fieldFormattedValues ?? textContent;\n                                if (this.data.doNotScroll) {\n                                    element.style.overflowY = \"hidden\";\n                                }\n                            } else {\n                                element = document.createElement(\"input\");\n                                element.type = \"text\";\n                                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                                if (this.data.doNotScroll) {\n                                    element.style.overflowX = \"hidden\";\n                                }\n                            }\n                            if (this.data.hasOwnCanvas) {\n                                element.hidden = true;\n                            }\n                            GetElementsByNameSet.add(element);\n                            element.setAttribute(\"data-element-id\", id);\n                            element.disabled = this.data.readOnly;\n                            element.name = this.data.fieldName;\n                            element.tabIndex = DEFAULT_TAB_INDEX;\n                            this._setRequired(element, this.data.required);\n                            if (maxLen) {\n                                element.maxLength = maxLen;\n                            }\n                            element.addEventListener(\"input\", (event)=>{\n                                storage.setValue(id, {\n                                    value: event.target.value\n                                });\n                                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                                elementData.formattedValue = null;\n                            });\n                            element.addEventListener(\"resetform\", (event)=>{\n                                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                                element.value = elementData.userValue = defaultValue;\n                                elementData.formattedValue = null;\n                            });\n                            let blurListener = (event)=>{\n                                const { formattedValue } = elementData;\n                                if (formattedValue !== null && formattedValue !== undefined) {\n                                    event.target.value = formattedValue;\n                                }\n                                event.target.scrollLeft = 0;\n                            };\n                            if (this.enableScripting && this.hasJSActions) {\n                                element.addEventListener(\"focus\", (event)=>{\n                                    if (elementData.focused) {\n                                        return;\n                                    }\n                                    const { target } = event;\n                                    if (elementData.userValue) {\n                                        target.value = elementData.userValue;\n                                    }\n                                    elementData.lastCommittedValue = target.value;\n                                    elementData.commitKey = 1;\n                                    elementData.focused = true;\n                                });\n                                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                    this.showElementAndHideCanvas(jsEvent.target);\n                                    const actions = {\n                                        value (event) {\n                                            elementData.userValue = event.detail.value ?? \"\";\n                                            storage.setValue(id, {\n                                                value: elementData.userValue.toString()\n                                            });\n                                            event.target.value = elementData.userValue;\n                                        },\n                                        formattedValue (event) {\n                                            const { formattedValue } = event.detail;\n                                            elementData.formattedValue = formattedValue;\n                                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                                event.target.value = formattedValue;\n                                            }\n                                            storage.setValue(id, {\n                                                formattedValue\n                                            });\n                                        },\n                                        selRange (event) {\n                                            event.target.setSelectionRange(...event.detail.selRange);\n                                        },\n                                        charLimit: (event)=>{\n                                            const { charLimit } = event.detail;\n                                            const { target } = event;\n                                            if (charLimit === 0) {\n                                                target.removeAttribute(\"maxLength\");\n                                                return;\n                                            }\n                                            target.setAttribute(\"maxLength\", charLimit);\n                                            let value = elementData.userValue;\n                                            if (!value || value.length <= charLimit) {\n                                                return;\n                                            }\n                                            value = value.slice(0, charLimit);\n                                            target.value = elementData.userValue = value;\n                                            storage.setValue(id, {\n                                                value\n                                            });\n                                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                                source: this,\n                                                detail: {\n                                                    id,\n                                                    name: \"Keystroke\",\n                                                    value,\n                                                    willCommit: true,\n                                                    commitKey: 1,\n                                                    selStart: target.selectionStart,\n                                                    selEnd: target.selectionEnd\n                                                }\n                                            });\n                                        }\n                                    };\n                                    this._dispatchEventFromSandbox(actions, jsEvent);\n                                });\n                                element.addEventListener(\"keydown\", (event)=>{\n                                    elementData.commitKey = 1;\n                                    let commitKey = -1;\n                                    if (event.key === \"Escape\") {\n                                        commitKey = 0;\n                                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                                        commitKey = 2;\n                                    } else if (event.key === \"Tab\") {\n                                        elementData.commitKey = 3;\n                                    }\n                                    if (commitKey === -1) {\n                                        return;\n                                    }\n                                    const { value } = event.target;\n                                    if (elementData.lastCommittedValue === value) {\n                                        return;\n                                    }\n                                    elementData.lastCommittedValue = value;\n                                    elementData.userValue = value;\n                                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                        source: this,\n                                        detail: {\n                                            id,\n                                            name: \"Keystroke\",\n                                            value,\n                                            willCommit: true,\n                                            commitKey,\n                                            selStart: event.target.selectionStart,\n                                            selEnd: event.target.selectionEnd\n                                        }\n                                    });\n                                });\n                                const _blurListener = blurListener;\n                                blurListener = null;\n                                element.addEventListener(\"blur\", (event)=>{\n                                    if (!elementData.focused || !event.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData.focused = false;\n                                    const { value } = event.target;\n                                    elementData.userValue = value;\n                                    if (elementData.lastCommittedValue !== value) {\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id,\n                                                name: \"Keystroke\",\n                                                value,\n                                                willCommit: true,\n                                                commitKey: elementData.commitKey,\n                                                selStart: event.target.selectionStart,\n                                                selEnd: event.target.selectionEnd\n                                            }\n                                        });\n                                    }\n                                    _blurListener(event);\n                                });\n                                if (this.data.actions?.Keystroke) {\n                                    element.addEventListener(\"beforeinput\", (event)=>{\n                                        elementData.lastCommittedValue = null;\n                                        const { data, target } = event;\n                                        const { value, selectionStart, selectionEnd } = target;\n                                        let selStart = selectionStart, selEnd = selectionEnd;\n                                        switch(event.inputType){\n                                            case \"deleteWordBackward\":\n                                                {\n                                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                                    if (match) {\n                                                        selStart -= match[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteWordForward\":\n                                                {\n                                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                                    if (match) {\n                                                        selEnd += match[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteContentBackward\":\n                                                if (selectionStart === selectionEnd) {\n                                                    selStart -= 1;\n                                                }\n                                                break;\n                                            case \"deleteContentForward\":\n                                                if (selectionStart === selectionEnd) {\n                                                    selEnd += 1;\n                                                }\n                                                break;\n                                        }\n                                        event.preventDefault();\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id,\n                                                name: \"Keystroke\",\n                                                value,\n                                                change: data || \"\",\n                                                willCommit: false,\n                                                selStart,\n                                                selEnd\n                                            }\n                                        });\n                                    });\n                                }\n                                this._setEventListeners(element, elementData, [\n                                    [\n                                        \"focus\",\n                                        \"Focus\"\n                                    ],\n                                    [\n                                        \"blur\",\n                                        \"Blur\"\n                                    ],\n                                    [\n                                        \"mousedown\",\n                                        \"Mouse Down\"\n                                    ],\n                                    [\n                                        \"mouseenter\",\n                                        \"Mouse Enter\"\n                                    ],\n                                    [\n                                        \"mouseleave\",\n                                        \"Mouse Exit\"\n                                    ],\n                                    [\n                                        \"mouseup\",\n                                        \"Mouse Up\"\n                                    ]\n                                ], (event)=>event.target.value);\n                            }\n                            if (blurListener) {\n                                element.addEventListener(\"blur\", blurListener);\n                            }\n                            if (this.data.comb) {\n                                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                                const combWidth = fieldWidth / maxLen;\n                                element.classList.add(\"comb\");\n                                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n                            }\n                        } else {\n                            element = document.createElement(\"div\");\n                            element.textContent = this.data.fieldValue;\n                            element.style.verticalAlign = \"middle\";\n                            element.style.display = \"table-cell\";\n                        }\n                        this._setTextStyle(element);\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: !!parameters.data.hasOwnCanvas\n                        });\n                    }\n                }\n                class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        const storage = this.annotationStorage;\n                        const data = this.data;\n                        const id = data.id;\n                        let value = storage.getValue(id, {\n                            value: data.exportValue === data.fieldValue\n                        }).value;\n                        if (typeof value === \"string\") {\n                            value = value !== \"Off\";\n                            storage.setValue(id, {\n                                value\n                            });\n                        }\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n                        const element = document.createElement(\"input\");\n                        GetElementsByNameSet.add(element);\n                        element.setAttribute(\"data-element-id\", id);\n                        element.disabled = data.readOnly;\n                        this._setRequired(element, this.data.required);\n                        element.type = \"checkbox\";\n                        element.name = data.fieldName;\n                        if (value) {\n                            element.setAttribute(\"checked\", true);\n                        }\n                        element.setAttribute(\"exportValue\", data.exportValue);\n                        element.tabIndex = DEFAULT_TAB_INDEX;\n                        element.addEventListener(\"change\", (event)=>{\n                            const { name, checked } = event.target;\n                            for (const checkbox of this._getElementsByName(name, id)){\n                                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                                if (checkbox.domElement) {\n                                    checkbox.domElement.checked = curChecked;\n                                }\n                                storage.setValue(checkbox.id, {\n                                    value: curChecked\n                                });\n                            }\n                            storage.setValue(id, {\n                                value: checked\n                            });\n                        });\n                        element.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = data.defaultFieldValue || \"Off\";\n                            event.target.checked = defaultValue === data.exportValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value (event) {\n                                        event.target.checked = event.detail.value !== \"Off\";\n                                        storage.setValue(id, {\n                                            value: event.target.checked\n                                        });\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            this._setEventListeners(element, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event)=>event.target.checked);\n                        }\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n                        const storage = this.annotationStorage;\n                        const data = this.data;\n                        const id = data.id;\n                        let value = storage.getValue(id, {\n                            value: data.fieldValue === data.buttonValue\n                        }).value;\n                        if (typeof value === \"string\") {\n                            value = value !== data.buttonValue;\n                            storage.setValue(id, {\n                                value\n                            });\n                        }\n                        const element = document.createElement(\"input\");\n                        GetElementsByNameSet.add(element);\n                        element.setAttribute(\"data-element-id\", id);\n                        element.disabled = data.readOnly;\n                        this._setRequired(element, this.data.required);\n                        element.type = \"radio\";\n                        element.name = data.fieldName;\n                        if (value) {\n                            element.setAttribute(\"checked\", true);\n                        }\n                        element.tabIndex = DEFAULT_TAB_INDEX;\n                        element.addEventListener(\"change\", (event)=>{\n                            const { name, checked } = event.target;\n                            for (const radio of this._getElementsByName(name, id)){\n                                storage.setValue(radio.id, {\n                                    value: false\n                                });\n                            }\n                            storage.setValue(id, {\n                                value: checked\n                            });\n                        });\n                        element.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = data.defaultFieldValue;\n                            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            const pdfButtonValue = data.buttonValue;\n                            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value: (event)=>{\n                                        const checked = pdfButtonValue === event.detail.value;\n                                        for (const radio of this._getElementsByName(event.target.name)){\n                                            const curChecked = checked && radio.id === id;\n                                            if (radio.domElement) {\n                                                radio.domElement.checked = curChecked;\n                                            }\n                                            storage.setValue(radio.id, {\n                                                value: curChecked\n                                            });\n                                        }\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            this._setEventListeners(element, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event)=>event.target.checked);\n                        }\n                        this._setBackgroundColor(element);\n                        this._setDefaultPropertiesFromJS(element);\n                        this.container.append(element);\n                        return this.container;\n                    }\n                }\n                class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            ignoreBorder: parameters.data.hasAppearance\n                        });\n                    }\n                    render() {\n                        const container = super.render();\n                        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n                        if (this.data.alternativeText) {\n                            container.title = this.data.alternativeText;\n                        }\n                        const linkElement = container.lastChild;\n                        if (this.enableScripting && this.hasJSActions && linkElement) {\n                            this._setDefaultPropertiesFromJS(linkElement);\n                            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                this._dispatchEventFromSandbox({}, jsEvent);\n                            });\n                        }\n                        return container;\n                    }\n                }\n                class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: parameters.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"choiceWidgetAnnotation\");\n                        const storage = this.annotationStorage;\n                        const id = this.data.id;\n                        const storedData = storage.getValue(id, {\n                            value: this.data.fieldValue\n                        });\n                        const selectElement = document.createElement(\"select\");\n                        GetElementsByNameSet.add(selectElement);\n                        selectElement.setAttribute(\"data-element-id\", id);\n                        selectElement.disabled = this.data.readOnly;\n                        this._setRequired(selectElement, this.data.required);\n                        selectElement.name = this.data.fieldName;\n                        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n                        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n                        if (!this.data.combo) {\n                            selectElement.size = this.data.options.length;\n                            if (this.data.multiSelect) {\n                                selectElement.multiple = true;\n                            }\n                        }\n                        selectElement.addEventListener(\"resetform\", (event)=>{\n                            const defaultValue = this.data.defaultFieldValue;\n                            for (const option of selectElement.options){\n                                option.selected = option.value === defaultValue;\n                            }\n                        });\n                        for (const option of this.data.options){\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = option.displayValue;\n                            optionElement.value = option.exportValue;\n                            if (storedData.value.includes(option.exportValue)) {\n                                optionElement.setAttribute(\"selected\", true);\n                                addAnEmptyEntry = false;\n                            }\n                            selectElement.append(optionElement);\n                        }\n                        let removeEmptyEntry = null;\n                        if (addAnEmptyEntry) {\n                            const noneOptionElement = document.createElement(\"option\");\n                            noneOptionElement.value = \" \";\n                            noneOptionElement.setAttribute(\"hidden\", true);\n                            noneOptionElement.setAttribute(\"selected\", true);\n                            selectElement.prepend(noneOptionElement);\n                            removeEmptyEntry = ()=>{\n                                noneOptionElement.remove();\n                                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                                removeEmptyEntry = null;\n                            };\n                            selectElement.addEventListener(\"input\", removeEmptyEntry);\n                        }\n                        const getValue = (isExport)=>{\n                            const name = isExport ? \"value\" : \"textContent\";\n                            const { options, multiple } = selectElement;\n                            if (!multiple) {\n                                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n                            }\n                            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n                        };\n                        let selectedValues = getValue(false);\n                        const getItems = (event)=>{\n                            const options = event.target.options;\n                            return Array.prototype.map.call(options, (option)=>{\n                                return {\n                                    displayValue: option.textContent,\n                                    exportValue: option.value\n                                };\n                            });\n                        };\n                        if (this.enableScripting && this.hasJSActions) {\n                            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                                const actions = {\n                                    value (event) {\n                                        removeEmptyEntry?.();\n                                        const value = event.detail.value;\n                                        const values = new Set(Array.isArray(value) ? value : [\n                                            value\n                                        ]);\n                                        for (const option of selectElement.options){\n                                            option.selected = values.has(option.value);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    multipleSelection (event) {\n                                        selectElement.multiple = true;\n                                    },\n                                    remove (event) {\n                                        const options = selectElement.options;\n                                        const index = event.detail.remove;\n                                        options[index].selected = false;\n                                        selectElement.remove(index);\n                                        if (options.length > 0) {\n                                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                                            if (i === -1) {\n                                                options[0].selected = true;\n                                            }\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    clear (event) {\n                                        while(selectElement.length !== 0){\n                                            selectElement.remove(0);\n                                        }\n                                        storage.setValue(id, {\n                                            value: null,\n                                            items: []\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    insert (event) {\n                                        const { index, displayValue, exportValue } = event.detail.insert;\n                                        const selectChild = selectElement.children[index];\n                                        const optionElement = document.createElement(\"option\");\n                                        optionElement.textContent = displayValue;\n                                        optionElement.value = exportValue;\n                                        if (selectChild) {\n                                            selectChild.before(optionElement);\n                                        } else {\n                                            selectElement.append(optionElement);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    items (event) {\n                                        const { items } = event.detail;\n                                        while(selectElement.length !== 0){\n                                            selectElement.remove(0);\n                                        }\n                                        for (const item of items){\n                                            const { displayValue, exportValue } = item;\n                                            const optionElement = document.createElement(\"option\");\n                                            optionElement.textContent = displayValue;\n                                            optionElement.value = exportValue;\n                                            selectElement.append(optionElement);\n                                        }\n                                        if (selectElement.options.length > 0) {\n                                            selectElement.options[0].selected = true;\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true),\n                                            items: getItems(event)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    indices (event) {\n                                        const indices = new Set(event.detail.indices);\n                                        for (const option of event.target.options){\n                                            option.selected = indices.has(option.index);\n                                        }\n                                        storage.setValue(id, {\n                                            value: getValue(true)\n                                        });\n                                        selectedValues = getValue(false);\n                                    },\n                                    editable (event) {\n                                        event.target.disabled = !event.detail.editable;\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions, jsEvent);\n                            });\n                            selectElement.addEventListener(\"input\", (event)=>{\n                                const exportValue = getValue(true);\n                                storage.setValue(id, {\n                                    value: exportValue\n                                });\n                                event.preventDefault();\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id,\n                                        name: \"Keystroke\",\n                                        value: selectedValues,\n                                        changeEx: exportValue,\n                                        willCommit: false,\n                                        commitKey: 1,\n                                        keyDown: false\n                                    }\n                                });\n                            });\n                            this._setEventListeners(selectElement, null, [\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Validate\"\n                                ]\n                            ], (event)=>event.target.value);\n                        } else {\n                            selectElement.addEventListener(\"input\", function(event) {\n                                storage.setValue(id, {\n                                    value: getValue(true)\n                                });\n                            });\n                        }\n                        if (this.data.combo) {\n                            this._setTextStyle(selectElement);\n                        } else {}\n                        this._setBackgroundColor(selectElement);\n                        this._setDefaultPropertiesFromJS(selectElement);\n                        this.container.append(selectElement);\n                        return this.container;\n                    }\n                }\n                class PopupAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        const { data, elements } = parameters;\n                        super(parameters, {\n                            isRenderable: AnnotationElement._hasPopupData(data)\n                        });\n                        this.elements = elements;\n                    }\n                    render() {\n                        this.container.classList.add(\"popupAnnotation\");\n                        const popup = new PopupElement({\n                            container: this.container,\n                            color: this.data.color,\n                            titleObj: this.data.titleObj,\n                            modificationDate: this.data.modificationDate,\n                            contentsObj: this.data.contentsObj,\n                            richText: this.data.richText,\n                            rect: this.data.rect,\n                            parentRect: this.data.parentRect || null,\n                            parent: this.parent,\n                            elements: this.elements,\n                            open: this.data.open\n                        });\n                        const elementIds = [];\n                        for (const element of this.elements){\n                            element.popup = popup;\n                            elementIds.push(element.data.id);\n                            element.addHighlightArea();\n                        }\n                        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${_util.AnnotationPrefix}${id}`).join(\",\"));\n                        return this.container;\n                    }\n                }\n                class PopupElement {\n                    #dateTimePromise;\n                    #boundKeyDown;\n                    #boundHide;\n                    #boundShow;\n                    #boundToggle;\n                    #color;\n                    #container;\n                    #contentsObj;\n                    #elements;\n                    #parent;\n                    #parentRect;\n                    #pinned;\n                    #popup;\n                    #rect;\n                    #richText;\n                    #titleObj;\n                    #wasVisible;\n                    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n                        this.#dateTimePromise = null;\n                        this.#boundKeyDown = this.#keyDown.bind(this);\n                        this.#boundHide = this.#hide.bind(this);\n                        this.#boundShow = this.#show.bind(this);\n                        this.#boundToggle = this.#toggle.bind(this);\n                        this.#color = null;\n                        this.#container = null;\n                        this.#contentsObj = null;\n                        this.#elements = null;\n                        this.#parent = null;\n                        this.#parentRect = null;\n                        this.#pinned = false;\n                        this.#popup = null;\n                        this.#rect = null;\n                        this.#richText = null;\n                        this.#titleObj = null;\n                        this.#wasVisible = false;\n                        this.#container = container;\n                        this.#titleObj = titleObj;\n                        this.#contentsObj = contentsObj;\n                        this.#richText = richText;\n                        this.#parent = parent;\n                        this.#color = color;\n                        this.#rect = rect;\n                        this.#parentRect = parentRect;\n                        this.#elements = elements;\n                        const dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);\n                        if (dateObject) {\n                            this.#dateTimePromise = parent.l10n.get(\"annotation_date_string\", {\n                                date: dateObject.toLocaleDateString(),\n                                time: dateObject.toLocaleTimeString()\n                            });\n                        }\n                        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n                        for (const element of this.trigger){\n                            element.addEventListener(\"click\", this.#boundToggle);\n                            element.addEventListener(\"mouseenter\", this.#boundShow);\n                            element.addEventListener(\"mouseleave\", this.#boundHide);\n                            element.classList.add(\"popupTriggerArea\");\n                        }\n                        for (const element of elements){\n                            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                        this.#container.hidden = true;\n                        if (open) {\n                            this.#toggle();\n                        }\n                    }\n                    render() {\n                        if (this.#popup) {\n                            return;\n                        }\n                        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n                        const popup = this.#popup = document.createElement(\"div\");\n                        popup.className = \"popup\";\n                        if (this.#color) {\n                            const baseColor = popup.style.outlineColor = _util.Util.makeHexColor(...this.#color);\n                            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                                popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n                            } else {\n                                const BACKGROUND_ENLIGHT = 0.7;\n                                popup.style.backgroundColor = _util.Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n                            }\n                        }\n                        const header = document.createElement(\"span\");\n                        header.className = \"header\";\n                        const title = document.createElement(\"h1\");\n                        header.append(title);\n                        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n                        popup.append(header);\n                        if (this.#dateTimePromise) {\n                            const modificationDate = document.createElement(\"span\");\n                            modificationDate.classList.add(\"popupDate\");\n                            this.#dateTimePromise.then((localized)=>{\n                                modificationDate.textContent = localized;\n                            });\n                            header.append(modificationDate);\n                        }\n                        const contentsObj = this.#contentsObj;\n                        const richText = this.#richText;\n                        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n                            _xfa_layer.XfaLayer.render({\n                                xfaHtml: richText.html,\n                                intent: \"richText\",\n                                div: popup\n                            });\n                            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n                        } else {\n                            const contents = this._formatContents(contentsObj);\n                            popup.append(contents);\n                        }\n                        let useParentRect = !!this.#parentRect;\n                        let rect = useParentRect ? this.#parentRect : this.#rect;\n                        for (const element of this.#elements){\n                            if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {\n                                rect = element.data.rect;\n                                useParentRect = true;\n                                break;\n                            }\n                        }\n                        const normalizedRect = _util.Util.normalizeRect([\n                            rect[0],\n                            view[3] - rect[1] + view[1],\n                            rect[2],\n                            view[3] - rect[3] + view[1]\n                        ]);\n                        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n                        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n                        const popupLeft = normalizedRect[0] + parentWidth;\n                        const popupTop = normalizedRect[1];\n                        const { style } = this.#container;\n                        style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;\n                        style.top = `${100 * (popupTop - pageY) / pageHeight}%`;\n                        this.#container.append(popup);\n                    }\n                    _formatContents({ str, dir }) {\n                        const p = document.createElement(\"p\");\n                        p.classList.add(\"popupContent\");\n                        p.dir = dir;\n                        const lines = str.split(/(?:\\r\\n?|\\n)/);\n                        for(let i = 0, ii = lines.length; i < ii; ++i){\n                            const line = lines[i];\n                            p.append(document.createTextNode(line));\n                            if (i < ii - 1) {\n                                p.append(document.createElement(\"br\"));\n                            }\n                        }\n                        return p;\n                    }\n                    #keyDown(event) {\n                        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n                            return;\n                        }\n                        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n                            this.#toggle();\n                        }\n                    }\n                    #toggle() {\n                        this.#pinned = !this.#pinned;\n                        if (this.#pinned) {\n                            this.#show();\n                            this.#container.addEventListener(\"click\", this.#boundToggle);\n                            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n                        } else {\n                            this.#hide();\n                            this.#container.removeEventListener(\"click\", this.#boundToggle);\n                            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                    }\n                    #show() {\n                        if (!this.#popup) {\n                            this.render();\n                        }\n                        if (!this.isVisible) {\n                            this.#container.hidden = false;\n                            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n                        } else if (this.#pinned) {\n                            this.#container.classList.add(\"focused\");\n                        }\n                    }\n                    #hide() {\n                        this.#container.classList.remove(\"focused\");\n                        if (this.#pinned || !this.isVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n                    }\n                    forceHide() {\n                        this.#wasVisible = this.isVisible;\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                    }\n                    maybeShow() {\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#wasVisible = false;\n                        this.#container.hidden = false;\n                    }\n                    get isVisible() {\n                        return this.#container.hidden === false;\n                    }\n                }\n                class FreeTextAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.textContent = parameters.data.textContent;\n                        this.textPosition = parameters.data.textPosition;\n                        this.annotationEditorType = _util.AnnotationEditorType.FREETEXT;\n                    }\n                    render() {\n                        this.container.classList.add(\"freeTextAnnotation\");\n                        if (this.textContent) {\n                            const content = document.createElement(\"div\");\n                            content.classList.add(\"annotationTextContent\");\n                            content.setAttribute(\"role\", \"comment\");\n                            for (const line of this.textContent){\n                                const lineSpan = document.createElement(\"span\");\n                                lineSpan.textContent = line;\n                                content.append(lineSpan);\n                            }\n                            this.container.append(content);\n                        }\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this._editOnDoubleClick();\n                        return this.container;\n                    }\n                }\n                exports1.FreeTextAnnotationElement = FreeTextAnnotationElement;\n                class LineAnnotationElement extends AnnotationElement {\n                    #line;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#line = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"lineAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n                        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n                        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n                        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n                        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n                        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                        line.setAttribute(\"stroke\", \"transparent\");\n                        line.setAttribute(\"fill\", \"transparent\");\n                        svg.append(line);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#line;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class SquareAnnotationElement extends AnnotationElement {\n                    #square;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#square = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"squareAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const borderWidth = data.borderStyle.width;\n                        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n                        square.setAttribute(\"x\", borderWidth / 2);\n                        square.setAttribute(\"y\", borderWidth / 2);\n                        square.setAttribute(\"width\", width - borderWidth);\n                        square.setAttribute(\"height\", height - borderWidth);\n                        square.setAttribute(\"stroke-width\", borderWidth || 1);\n                        square.setAttribute(\"stroke\", \"transparent\");\n                        square.setAttribute(\"fill\", \"transparent\");\n                        svg.append(square);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#square;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class CircleAnnotationElement extends AnnotationElement {\n                    #circle;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#circle = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"circleAnnotation\");\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        const borderWidth = data.borderStyle.width;\n                        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n                        circle.setAttribute(\"cx\", width / 2);\n                        circle.setAttribute(\"cy\", height / 2);\n                        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n                        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n                        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n                        circle.setAttribute(\"stroke\", \"transparent\");\n                        circle.setAttribute(\"fill\", \"transparent\");\n                        svg.append(circle);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#circle;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolylineAnnotationElement extends AnnotationElement {\n                    #polyline;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polyline = null;\n                        this.containerClassName = \"polylineAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        let points = [];\n                        for (const coordinate of data.vertices){\n                            const x = coordinate.x - data.rect[0];\n                            const y = data.rect[3] - coordinate.y;\n                            points.push(x + \",\" + y);\n                        }\n                        points = points.join(\" \");\n                        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n                        polyline.setAttribute(\"points\", points);\n                        polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                        polyline.setAttribute(\"stroke\", \"transparent\");\n                        polyline.setAttribute(\"fill\", \"transparent\");\n                        svg.append(polyline);\n                        this.container.append(svg);\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polyline;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolygonAnnotationElement extends PolylineAnnotationElement {\n                    constructor(parameters){\n                        super(parameters);\n                        this.containerClassName = \"polygonAnnotation\";\n                        this.svgElementName = \"svg:polygon\";\n                    }\n                }\n                class CaretAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"caretAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                class InkAnnotationElement extends AnnotationElement {\n                    #polylines;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polylines = [];\n                        this.containerClassName = \"inkAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                        this.annotationEditorType = _util.AnnotationEditorType.INK;\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data = this.data;\n                        const { width, height } = getRectDims(data.rect);\n                        const svg = this.svgFactory.create(width, height, true);\n                        for (const inkList of data.inkLists){\n                            let points = [];\n                            for (const coordinate of inkList){\n                                const x = coordinate.x - data.rect[0];\n                                const y = data.rect[3] - coordinate.y;\n                                points.push(`${x},${y}`);\n                            }\n                            points = points.join(\" \");\n                            const polyline = this.svgFactory.createElement(this.svgElementName);\n                            this.#polylines.push(polyline);\n                            polyline.setAttribute(\"points\", points);\n                            polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n                            polyline.setAttribute(\"stroke\", \"transparent\");\n                            polyline.setAttribute(\"fill\", \"transparent\");\n                            if (!data.popupRef && this.hasPopupData) {\n                                this._createPopup();\n                            }\n                            svg.append(polyline);\n                        }\n                        this.container.append(svg);\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polylines;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                exports1.InkAnnotationElement = InkAnnotationElement;\n                class HighlightAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"highlightAnnotation\");\n                        return this.container;\n                    }\n                }\n                class UnderlineAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"underlineAnnotation\");\n                        return this.container;\n                    }\n                }\n                class SquigglyAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"squigglyAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StrikeOutAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"strikeoutAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StampAnnotationElement extends AnnotationElement {\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"stampAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                exports1.StampAnnotationElement = StampAnnotationElement;\n                class FileAttachmentAnnotationElement extends AnnotationElement {\n                    #trigger;\n                    constructor(parameters){\n                        super(parameters, {\n                            isRenderable: true\n                        });\n                        this.#trigger = null;\n                        const { filename, content } = this.data.file;\n                        this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);\n                        this.content = content;\n                        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n                            source: this,\n                            filename,\n                            content\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"fileAttachmentAnnotation\");\n                        const { container, data } = this;\n                        let trigger;\n                        if (data.hasAppearance || data.fillAlpha === 0) {\n                            trigger = document.createElement(\"div\");\n                        } else {\n                            trigger = document.createElement(\"img\");\n                            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n                            if (data.fillAlpha && data.fillAlpha < 1) {\n                                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n                            }\n                        }\n                        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n                        this.#trigger = trigger;\n                        const { isMac } = _util.FeatureTest.platform;\n                        container.addEventListener(\"keydown\", (evt)=>{\n                            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                                this.#download();\n                            }\n                        });\n                        if (!data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        } else {\n                            trigger.classList.add(\"popupTriggerArea\");\n                        }\n                        container.append(trigger);\n                        return container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#trigger;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                    #download() {\n                        this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n                    }\n                }\n                class AnnotationLayer {\n                    #accessibilityManager;\n                    #annotationCanvasMap;\n                    #editableAnnotations;\n                    constructor({ div, accessibilityManager, annotationCanvasMap, l10n, page, viewport }){\n                        this.#accessibilityManager = null;\n                        this.#annotationCanvasMap = null;\n                        this.#editableAnnotations = new Map();\n                        this.div = div;\n                        this.#accessibilityManager = accessibilityManager;\n                        this.#annotationCanvasMap = annotationCanvasMap;\n                        this.l10n = l10n;\n                        this.page = page;\n                        this.viewport = viewport;\n                        this.zIndex = 0;\n                        this.l10n ||= _displayL10n_utils.NullL10n;\n                    }\n                    #appendElement(element, id) {\n                        const contentElement = element.firstChild || element;\n                        contentElement.id = `${_util.AnnotationPrefix}${id}`;\n                        this.div.append(element);\n                        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n                    }\n                    async render(params) {\n                        const { annotations } = params;\n                        const layer = this.div;\n                        (0, _display_utils.setLayerDimensions)(layer, this.viewport);\n                        const popupToElements = new Map();\n                        const elementParams = {\n                            data: null,\n                            layer,\n                            linkService: params.linkService,\n                            downloadManager: params.downloadManager,\n                            imageResourcesPath: params.imageResourcesPath || \"\",\n                            renderForms: params.renderForms !== false,\n                            svgFactory: new _display_utils.DOMSVGFactory(),\n                            annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),\n                            enableScripting: params.enableScripting === true,\n                            hasJSActions: params.hasJSActions,\n                            fieldObjects: params.fieldObjects,\n                            parent: this,\n                            elements: null\n                        };\n                        for (const data of annotations){\n                            if (data.noHTML) {\n                                continue;\n                            }\n                            const isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;\n                            if (!isPopupAnnotation) {\n                                const { width, height } = getRectDims(data.rect);\n                                if (width <= 0 || height <= 0) {\n                                    continue;\n                                }\n                            } else {\n                                const elements = popupToElements.get(data.id);\n                                if (!elements) {\n                                    continue;\n                                }\n                                elementParams.elements = elements;\n                            }\n                            elementParams.data = data;\n                            const element = AnnotationElementFactory.create(elementParams);\n                            if (!element.isRenderable) {\n                                continue;\n                            }\n                            if (!isPopupAnnotation && data.popupRef) {\n                                const elements = popupToElements.get(data.popupRef);\n                                if (!elements) {\n                                    popupToElements.set(data.popupRef, [\n                                        element\n                                    ]);\n                                } else {\n                                    elements.push(element);\n                                }\n                            }\n                            if (element.annotationEditorType > 0) {\n                                this.#editableAnnotations.set(element.data.id, element);\n                            }\n                            const rendered = element.render();\n                            if (data.hidden) {\n                                rendered.style.visibility = \"hidden\";\n                            }\n                            this.#appendElement(rendered, data.id);\n                        }\n                        this.#setAnnotationCanvasMap();\n                        await this.l10n.translate(layer);\n                    }\n                    update({ viewport }) {\n                        const layer = this.div;\n                        this.viewport = viewport;\n                        (0, _display_utils.setLayerDimensions)(layer, {\n                            rotation: viewport.rotation\n                        });\n                        this.#setAnnotationCanvasMap();\n                        layer.hidden = false;\n                    }\n                    #setAnnotationCanvasMap() {\n                        if (!this.#annotationCanvasMap) {\n                            return;\n                        }\n                        const layer = this.div;\n                        for (const [id, canvas] of this.#annotationCanvasMap){\n                            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n                            if (!element) {\n                                continue;\n                            }\n                            const { firstChild } = element;\n                            if (!firstChild) {\n                                element.append(canvas);\n                            } else if (firstChild.nodeName === \"CANVAS\") {\n                                firstChild.replaceWith(canvas);\n                            } else {\n                                firstChild.before(canvas);\n                            }\n                        }\n                        this.#annotationCanvasMap.clear();\n                    }\n                    getEditableAnnotations() {\n                        return Array.from(this.#editableAnnotations.values());\n                    }\n                    getEditableAnnotation(id) {\n                        return this.#editableAnnotations.get(id);\n                    }\n                }\n                exports1.AnnotationLayer = AnnotationLayer;\n            /***/ },\n            /* 30 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.ColorConverters = void 0;\n                function makeColorComp(n) {\n                    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n                }\n                function scaleAndClamp(x) {\n                    return Math.max(0, Math.min(255, 255 * x));\n                }\n                class ColorConverters {\n                    static CMYK_G([c, y, m, k]) {\n                        return [\n                            \"G\",\n                            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n                        ];\n                    }\n                    static G_CMYK([g]) {\n                        return [\n                            \"CMYK\",\n                            0,\n                            0,\n                            0,\n                            1 - g\n                        ];\n                    }\n                    static G_RGB([g]) {\n                        return [\n                            \"RGB\",\n                            g,\n                            g,\n                            g\n                        ];\n                    }\n                    static G_rgb([g]) {\n                        g = scaleAndClamp(g);\n                        return [\n                            g,\n                            g,\n                            g\n                        ];\n                    }\n                    static G_HTML([g]) {\n                        const G = makeColorComp(g);\n                        return `#${G}${G}${G}`;\n                    }\n                    static RGB_G([r, g, b]) {\n                        return [\n                            \"G\",\n                            0.3 * r + 0.59 * g + 0.11 * b\n                        ];\n                    }\n                    static RGB_rgb(color) {\n                        return color.map(scaleAndClamp);\n                    }\n                    static RGB_HTML(color) {\n                        return `#${color.map(makeColorComp).join(\"\")}`;\n                    }\n                    static T_HTML() {\n                        return \"#00000000\";\n                    }\n                    static T_rgb() {\n                        return [\n                            null\n                        ];\n                    }\n                    static CMYK_RGB([c, y, m, k]) {\n                        return [\n                            \"RGB\",\n                            1 - Math.min(1, c + k),\n                            1 - Math.min(1, m + k),\n                            1 - Math.min(1, y + k)\n                        ];\n                    }\n                    static CMYK_rgb([c, y, m, k]) {\n                        return [\n                            scaleAndClamp(1 - Math.min(1, c + k)),\n                            scaleAndClamp(1 - Math.min(1, m + k)),\n                            scaleAndClamp(1 - Math.min(1, y + k))\n                        ];\n                    }\n                    static CMYK_HTML(components) {\n                        const rgb = this.CMYK_RGB(components).slice(1);\n                        return this.RGB_HTML(rgb);\n                    }\n                    static RGB_CMYK([r, g, b]) {\n                        const c = 1 - r;\n                        const m = 1 - g;\n                        const y = 1 - b;\n                        const k = Math.min(c, m, y);\n                        return [\n                            \"CMYK\",\n                            c,\n                            m,\n                            y,\n                            k\n                        ];\n                    }\n                }\n                exports1.ColorConverters = ColorConverters;\n            /***/ },\n            /* 31 */ /***/ (__unused_webpack_module, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NullL10n = void 0;\n                exports1.getL10nFallback = getL10nFallback;\n                const DEFAULT_L10N_STRINGS = {\n                    of_pages: \"of {{pagesCount}}\",\n                    page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\n                    document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\n                    document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\n                    document_properties_date_string: \"{{date}}, {{time}}\",\n                    document_properties_page_size_unit_inches: \"in\",\n                    document_properties_page_size_unit_millimeters: \"mm\",\n                    document_properties_page_size_orientation_portrait: \"portrait\",\n                    document_properties_page_size_orientation_landscape: \"landscape\",\n                    document_properties_page_size_name_a3: \"A3\",\n                    document_properties_page_size_name_a4: \"A4\",\n                    document_properties_page_size_name_letter: \"Letter\",\n                    document_properties_page_size_name_legal: \"Legal\",\n                    document_properties_page_size_dimension_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{orientation}})\",\n                    document_properties_page_size_dimension_name_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{name}}, {{orientation}})\",\n                    document_properties_linearized_yes: \"Yes\",\n                    document_properties_linearized_no: \"No\",\n                    additional_layers: \"Additional Layers\",\n                    page_landmark: \"Page {{page}}\",\n                    thumb_page_title: \"Page {{page}}\",\n                    thumb_page_canvas: \"Thumbnail of Page {{page}}\",\n                    find_reached_top: \"Reached top of document, continued from bottom\",\n                    find_reached_bottom: \"Reached end of document, continued from top\",\n                    \"find_match_count[one]\": \"{{current}} of {{total}} match\",\n                    \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\n                    \"find_match_count_limit[one]\": \"More than {{limit}} match\",\n                    \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\n                    find_not_found: \"Phrase not found\",\n                    page_scale_width: \"Page Width\",\n                    page_scale_fit: \"Page Fit\",\n                    page_scale_auto: \"Automatic Zoom\",\n                    page_scale_actual: \"Actual Size\",\n                    page_scale_percent: \"{{scale}}%\",\n                    loading_error: \"An error occurred while loading the PDF.\",\n                    invalid_file_error: \"Invalid or corrupted PDF file.\",\n                    missing_file_error: \"Missing PDF file.\",\n                    unexpected_response_error: \"Unexpected server response.\",\n                    rendering_error: \"An error occurred while rendering the page.\",\n                    annotation_date_string: \"{{date}}, {{time}}\",\n                    printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\n                    printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\n                    web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\",\n                    free_text2_default_content: \"Start typing…\",\n                    editor_free_text2_aria_label: \"Text Editor\",\n                    editor_ink2_aria_label: \"Draw Editor\",\n                    editor_ink_canvas_aria_label: \"User-created image\",\n                    editor_alt_text_button_label: \"Alt text\",\n                    editor_alt_text_edit_button_label: \"Edit alt text\",\n                    editor_alt_text_decorative_tooltip: \"Marked as decorative\"\n                };\n                {\n                    DEFAULT_L10N_STRINGS.print_progress_percent = \"{{progress}}%\";\n                }\n                function getL10nFallback(key, args) {\n                    switch(key){\n                        case \"find_match_count\":\n                            key = `find_match_count[${args.total === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                        case \"find_match_count_limit\":\n                            key = `find_match_count_limit[${args.limit === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                    }\n                    return DEFAULT_L10N_STRINGS[key] || \"\";\n                }\n                function formatL10nValue(text, args) {\n                    if (!args) {\n                        return text;\n                    }\n                    return text.replaceAll(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name)=>{\n                        return name in args ? args[name] : \"{{\" + name + \"}}\";\n                    });\n                }\n                const NullL10n = {\n                    async getLanguage () {\n                        return \"en-us\";\n                    },\n                    async getDirection () {\n                        return \"ltr\";\n                    },\n                    async get (key, args = null, fallback = getL10nFallback(key, args)) {\n                        return formatL10nValue(fallback, args);\n                    },\n                    async translate (element) {}\n                };\n                exports1.NullL10n = NullL10n;\n            /***/ },\n            /* 32 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaLayer = void 0;\n                var _xfa_text = __w_pdfjs_require__(25);\n                class XfaLayer {\n                    static setupStorage(html, id, element, storage, intent) {\n                        const storedData = storage.getValue(id, {\n                            value: null\n                        });\n                        switch(element.name){\n                            case \"textarea\":\n                                if (storedData.value !== null) {\n                                    html.textContent = storedData.value;\n                                }\n                                if (intent === \"print\") {\n                                    break;\n                                }\n                                html.addEventListener(\"input\", (event)=>{\n                                    storage.setValue(id, {\n                                        value: event.target.value\n                                    });\n                                });\n                                break;\n                            case \"input\":\n                                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                                    if (storedData.value === element.attributes.xfaOn) {\n                                        html.setAttribute(\"checked\", true);\n                                    } else if (storedData.value === element.attributes.xfaOff) {\n                                        html.removeAttribute(\"checked\");\n                                    }\n                                    if (intent === \"print\") {\n                                        break;\n                                    }\n                                    html.addEventListener(\"change\", (event)=>{\n                                        storage.setValue(id, {\n                                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                                        });\n                                    });\n                                } else {\n                                    if (storedData.value !== null) {\n                                        html.setAttribute(\"value\", storedData.value);\n                                    }\n                                    if (intent === \"print\") {\n                                        break;\n                                    }\n                                    html.addEventListener(\"input\", (event)=>{\n                                        storage.setValue(id, {\n                                            value: event.target.value\n                                        });\n                                    });\n                                }\n                                break;\n                            case \"select\":\n                                if (storedData.value !== null) {\n                                    html.setAttribute(\"value\", storedData.value);\n                                    for (const option of element.children){\n                                        if (option.attributes.value === storedData.value) {\n                                            option.attributes.selected = true;\n                                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                                            delete option.attributes.selected;\n                                        }\n                                    }\n                                }\n                                html.addEventListener(\"input\", (event)=>{\n                                    const options = event.target.options;\n                                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                                    storage.setValue(id, {\n                                        value\n                                    });\n                                });\n                                break;\n                        }\n                    }\n                    static setAttributes({ html, element, storage = null, intent, linkService }) {\n                        const { attributes } = element;\n                        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n                        if (attributes.type === \"radio\") {\n                            attributes.name = `${attributes.name}-${intent}`;\n                        }\n                        for (const [key, value] of Object.entries(attributes)){\n                            if (value === null || value === undefined) {\n                                continue;\n                            }\n                            switch(key){\n                                case \"class\":\n                                    if (value.length) {\n                                        html.setAttribute(key, value.join(\" \"));\n                                    }\n                                    break;\n                                case \"dataId\":\n                                    break;\n                                case \"id\":\n                                    html.setAttribute(\"data-element-id\", value);\n                                    break;\n                                case \"style\":\n                                    Object.assign(html.style, value);\n                                    break;\n                                case \"textContent\":\n                                    html.textContent = value;\n                                    break;\n                                default:\n                                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                                        html.setAttribute(key, value);\n                                    }\n                            }\n                        }\n                        if (isHTMLAnchorElement) {\n                            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n                        }\n                        if (storage && attributes.dataId) {\n                            this.setupStorage(html, attributes.dataId, element, storage);\n                        }\n                    }\n                    static render(parameters) {\n                        const storage = parameters.annotationStorage;\n                        const linkService = parameters.linkService;\n                        const root = parameters.xfaHtml;\n                        const intent = parameters.intent || \"display\";\n                        const rootHtml = document.createElement(root.name);\n                        if (root.attributes) {\n                            this.setAttributes({\n                                html: rootHtml,\n                                element: root,\n                                intent,\n                                linkService\n                            });\n                        }\n                        const stack = [\n                            [\n                                root,\n                                -1,\n                                rootHtml\n                            ]\n                        ];\n                        const rootDiv = parameters.div;\n                        rootDiv.append(rootHtml);\n                        if (parameters.viewport) {\n                            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                            rootDiv.style.transform = transform;\n                        }\n                        if (intent !== \"richText\") {\n                            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n                        }\n                        const textDivs = [];\n                        while(stack.length > 0){\n                            const [parent, i, html] = stack.at(-1);\n                            if (i + 1 === parent.children.length) {\n                                stack.pop();\n                                continue;\n                            }\n                            const child = parent.children[++stack.at(-1)[1]];\n                            if (child === null) {\n                                continue;\n                            }\n                            const { name } = child;\n                            if (name === \"#text\") {\n                                const node = document.createTextNode(child.value);\n                                textDivs.push(node);\n                                html.append(node);\n                                continue;\n                            }\n                            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n                            html.append(childHtml);\n                            if (child.attributes) {\n                                this.setAttributes({\n                                    html: childHtml,\n                                    element: child,\n                                    storage,\n                                    intent,\n                                    linkService\n                                });\n                            }\n                            if (child.children && child.children.length > 0) {\n                                stack.push([\n                                    child,\n                                    -1,\n                                    childHtml\n                                ]);\n                            } else if (child.value) {\n                                const node = document.createTextNode(child.value);\n                                if (_xfa_text.XfaText.shouldBuildText(name)) {\n                                    textDivs.push(node);\n                                }\n                                childHtml.append(node);\n                            }\n                        }\n                        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n                            el.setAttribute(\"readOnly\", true);\n                        }\n                        return {\n                            textDivs\n                        };\n                    }\n                    static update(parameters) {\n                        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n                        parameters.div.style.transform = transform;\n                        parameters.div.hidden = false;\n                    }\n                }\n                exports1.XfaLayer = XfaLayer;\n            /***/ },\n            /* 33 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.InkEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _tools = __w_pdfjs_require__(5);\n                class InkEditor extends _editor.AnnotationEditor {\n                    #baseHeight;\n                    #baseWidth;\n                    #boundCanvasPointermove;\n                    #boundCanvasPointerleave;\n                    #boundCanvasPointerup;\n                    #boundCanvasPointerdown;\n                    #currentPath2D;\n                    #disableEditing;\n                    #hasSomethingToDraw;\n                    #isCanvasInitialized;\n                    #observer;\n                    #realWidth;\n                    #realHeight;\n                    #requestFrameCallback;\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultOpacity = 1;\n                    }\n                    static{\n                        this._defaultThickness = 1;\n                    }\n                    static{\n                        this._type = \"ink\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"inkEditor\"\n                        });\n                        this.#baseHeight = 0;\n                        this.#baseWidth = 0;\n                        this.#boundCanvasPointermove = this.canvasPointermove.bind(this);\n                        this.#boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n                        this.#boundCanvasPointerup = this.canvasPointerup.bind(this);\n                        this.#boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n                        this.#currentPath2D = new Path2D();\n                        this.#disableEditing = false;\n                        this.#hasSomethingToDraw = false;\n                        this.#isCanvasInitialized = false;\n                        this.#observer = null;\n                        this.#realWidth = 0;\n                        this.#realHeight = 0;\n                        this.#requestFrameCallback = null;\n                        this.color = params.color || null;\n                        this.thickness = params.thickness || null;\n                        this.opacity = params.opacity || null;\n                        this.paths = [];\n                        this.bezierPath2D = [];\n                        this.allRawPaths = [];\n                        this.currentPath = [];\n                        this.scaleFactor = 1;\n                        this.translationX = this.translationY = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this._willKeepAspectRatio = true;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n, {\n                            strings: [\n                                \"editor_ink_canvas_aria_label\",\n                                \"editor_ink2_aria_label\"\n                            ]\n                        });\n                    }\n                    static updateDefaultParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                                InkEditor._defaultThickness = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_COLOR:\n                                InkEditor._defaultColor = value;\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_OPACITY:\n                                InkEditor._defaultOpacity = value / 100;\n                                break;\n                        }\n                    }\n                    updateParams(type, value) {\n                        switch(type){\n                            case _util.AnnotationEditorParamsType.INK_THICKNESS:\n                                this.#updateThickness(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_COLOR:\n                                this.#updateColor(value);\n                                break;\n                            case _util.AnnotationEditorParamsType.INK_OPACITY:\n                                this.#updateOpacity(value);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.INK_THICKNESS,\n                                InkEditor._defaultThickness\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_COLOR,\n                                InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(InkEditor._defaultOpacity * 100)\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util.AnnotationEditorParamsType.INK_THICKNESS,\n                                this.thickness || InkEditor._defaultThickness\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_COLOR,\n                                this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))\n                            ]\n                        ];\n                    }\n                    #updateThickness(thickness) {\n                        const savedThickness = this.thickness;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.thickness = thickness;\n                                this.#fitToContent();\n                            },\n                            undo: ()=>{\n                                this.thickness = savedThickness;\n                                this.#fitToContent();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color) {\n                        const savedColor = this.color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.color = color;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.color = savedColor;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateOpacity(opacity) {\n                        opacity /= 100;\n                        const savedOpacity = this.opacity;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.opacity = opacity;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.opacity = savedOpacity;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util.AnnotationEditorParamsType.INK_OPACITY,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.canvas) {\n                            this.#createCanvas();\n                            this.#createObserver();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                            this.#setCanvasDims();\n                        }\n                        this.#fitToContent();\n                    }\n                    remove() {\n                        if (this.canvas === null) {\n                            return;\n                        }\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.remove();\n                        this.canvas = null;\n                        this.#observer.disconnect();\n                        this.#observer = null;\n                        super.remove();\n                    }\n                    setParent(parent) {\n                        if (!this.parent && parent) {\n                            this._uiManager.removeShouldRescale(this);\n                        } else if (this.parent && parent === null) {\n                            this._uiManager.addShouldRescale(this);\n                        }\n                        super.setParent(parent);\n                    }\n                    onScaleChanging() {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        const width = this.width * parentWidth;\n                        const height = this.height * parentHeight;\n                        this.setDimensions(width, height);\n                    }\n                    enableEditMode() {\n                        if (this.#disableEditing || this.canvas === null) {\n                            return;\n                        }\n                        super.enableEditMode();\n                        this._isDraggable = false;\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode() || this.canvas === null) {\n                            return;\n                        }\n                        super.disableEditMode();\n                        this._isDraggable = !this.isEmpty();\n                        this.div.classList.remove(\"editing\");\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    onceAdded() {\n                        this._isDraggable = !this.isEmpty();\n                    }\n                    isEmpty() {\n                        return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n                    }\n                    #getInitialBBox() {\n                        const { parentRotation, parentDimensions: [width, height] } = this;\n                        switch(parentRotation){\n                            case 90:\n                                return [\n                                    0,\n                                    height,\n                                    height,\n                                    width\n                                ];\n                            case 180:\n                                return [\n                                    width,\n                                    height,\n                                    width,\n                                    height\n                                ];\n                            case 270:\n                                return [\n                                    width,\n                                    0,\n                                    height,\n                                    width\n                                ];\n                            default:\n                                return [\n                                    0,\n                                    0,\n                                    width,\n                                    height\n                                ];\n                        }\n                    }\n                    #setStroke() {\n                        const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this;\n                        ctx.lineWidth = thickness * parentScale / scaleFactor;\n                        ctx.lineCap = \"round\";\n                        ctx.lineJoin = \"round\";\n                        ctx.miterLimit = 10;\n                        ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;\n                    }\n                    #startDrawing(x, y) {\n                        this.canvas.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        this.isEditing = true;\n                        if (!this.#isCanvasInitialized) {\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.thickness ||= InkEditor._defaultThickness;\n                            this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n                            this.opacity ??= InkEditor._defaultOpacity;\n                        }\n                        this.currentPath.push([\n                            x,\n                            y\n                        ]);\n                        this.#hasSomethingToDraw = false;\n                        this.#setStroke();\n                        this.#requestFrameCallback = ()=>{\n                            this.#drawPoints();\n                            if (this.#requestFrameCallback) {\n                                window.requestAnimationFrame(this.#requestFrameCallback);\n                            }\n                        };\n                        window.requestAnimationFrame(this.#requestFrameCallback);\n                    }\n                    #draw(x, y) {\n                        const [lastX, lastY] = this.currentPath.at(-1);\n                        if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n                            return;\n                        }\n                        const currentPath = this.currentPath;\n                        let path2D = this.#currentPath2D;\n                        currentPath.push([\n                            x,\n                            y\n                        ]);\n                        this.#hasSomethingToDraw = true;\n                        if (currentPath.length <= 2) {\n                            path2D.moveTo(...currentPath[0]);\n                            path2D.lineTo(x, y);\n                            return;\n                        }\n                        if (currentPath.length === 3) {\n                            this.#currentPath2D = path2D = new Path2D();\n                            path2D.moveTo(...currentPath[0]);\n                        }\n                        this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n                    }\n                    #endPath() {\n                        if (this.currentPath.length === 0) {\n                            return;\n                        }\n                        const lastPoint = this.currentPath.at(-1);\n                        this.#currentPath2D.lineTo(...lastPoint);\n                    }\n                    #stopDrawing(x, y) {\n                        this.#requestFrameCallback = null;\n                        x = Math.min(Math.max(x, 0), this.canvas.width);\n                        y = Math.min(Math.max(y, 0), this.canvas.height);\n                        this.#draw(x, y);\n                        this.#endPath();\n                        let bezier;\n                        if (this.currentPath.length !== 1) {\n                            bezier = this.#generateBezierPoints();\n                        } else {\n                            const xy = [\n                                x,\n                                y\n                            ];\n                            bezier = [\n                                [\n                                    xy,\n                                    xy.slice(),\n                                    xy.slice(),\n                                    xy\n                                ]\n                            ];\n                        }\n                        const path2D = this.#currentPath2D;\n                        const currentPath = this.currentPath;\n                        this.currentPath = [];\n                        this.#currentPath2D = new Path2D();\n                        const cmd = ()=>{\n                            this.allRawPaths.push(currentPath);\n                            this.paths.push(bezier);\n                            this.bezierPath2D.push(path2D);\n                            this.rebuild();\n                        };\n                        const undo = ()=>{\n                            this.allRawPaths.pop();\n                            this.paths.pop();\n                            this.bezierPath2D.pop();\n                            if (this.paths.length === 0) {\n                                this.remove();\n                            } else {\n                                if (!this.canvas) {\n                                    this.#createCanvas();\n                                    this.#createObserver();\n                                }\n                                this.#fitToContent();\n                            }\n                        };\n                        this.addCommands({\n                            cmd,\n                            undo,\n                            mustExec: true\n                        });\n                    }\n                    #drawPoints() {\n                        if (!this.#hasSomethingToDraw) {\n                            return;\n                        }\n                        this.#hasSomethingToDraw = false;\n                        const thickness = Math.ceil(this.thickness * this.parentScale);\n                        const lastPoints = this.currentPath.slice(-3);\n                        const x = lastPoints.map((xy)=>xy[0]);\n                        const y = lastPoints.map((xy)=>xy[1]);\n                        const xMin = Math.min(...x) - thickness;\n                        const xMax = Math.max(...x) + thickness;\n                        const yMin = Math.min(...y) - thickness;\n                        const yMax = Math.max(...y) + thickness;\n                        const { ctx } = this;\n                        ctx.save();\n                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                        for (const path of this.bezierPath2D){\n                            ctx.stroke(path);\n                        }\n                        ctx.stroke(this.#currentPath2D);\n                        ctx.restore();\n                    }\n                    #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n                        const prevX = (x0 + x1) / 2;\n                        const prevY = (y0 + y1) / 2;\n                        const x3 = (x1 + x2) / 2;\n                        const y3 = (y1 + y2) / 2;\n                        path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n                    }\n                    #generateBezierPoints() {\n                        const path = this.currentPath;\n                        if (path.length <= 2) {\n                            return [\n                                [\n                                    path[0],\n                                    path[0],\n                                    path.at(-1),\n                                    path.at(-1)\n                                ]\n                            ];\n                        }\n                        const bezierPoints = [];\n                        let i;\n                        let [x0, y0] = path[0];\n                        for(i = 1; i < path.length - 2; i++){\n                            const [x1, y1] = path[i];\n                            const [x2, y2] = path[i + 1];\n                            const x3 = (x1 + x2) / 2;\n                            const y3 = (y1 + y2) / 2;\n                            const control1 = [\n                                x0 + 2 * (x1 - x0) / 3,\n                                y0 + 2 * (y1 - y0) / 3\n                            ];\n                            const control2 = [\n                                x3 + 2 * (x1 - x3) / 3,\n                                y3 + 2 * (y1 - y3) / 3\n                            ];\n                            bezierPoints.push([\n                                [\n                                    x0,\n                                    y0\n                                ],\n                                control1,\n                                control2,\n                                [\n                                    x3,\n                                    y3\n                                ]\n                            ]);\n                            [x0, y0] = [\n                                x3,\n                                y3\n                            ];\n                        }\n                        const [x1, y1] = path[i];\n                        const [x2, y2] = path[i + 1];\n                        const control1 = [\n                            x0 + 2 * (x1 - x0) / 3,\n                            y0 + 2 * (y1 - y0) / 3\n                        ];\n                        const control2 = [\n                            x2 + 2 * (x1 - x2) / 3,\n                            y2 + 2 * (y1 - y2) / 3\n                        ];\n                        bezierPoints.push([\n                            [\n                                x0,\n                                y0\n                            ],\n                            control1,\n                            control2,\n                            [\n                                x2,\n                                y2\n                            ]\n                        ]);\n                        return bezierPoints;\n                    }\n                    #redraw() {\n                        if (this.isEmpty()) {\n                            this.#updateTransform();\n                            return;\n                        }\n                        this.#setStroke();\n                        const { canvas, ctx } = this;\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        this.#updateTransform();\n                        for (const path of this.bezierPath2D){\n                            ctx.stroke(path);\n                        }\n                    }\n                    commit() {\n                        if (this.#disableEditing) {\n                            return;\n                        }\n                        super.commit();\n                        this.isEditing = false;\n                        this.disableEditMode();\n                        this.setInForeground();\n                        this.#disableEditing = true;\n                        this.div.classList.add(\"disabled\");\n                        this.#fitToContent(true);\n                        this.makeResizable();\n                        this.parent.addInkEditorIfNeeded(true);\n                        this.moveInDOM();\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                    }\n                    focusin(event) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event);\n                        this.enableEditMode();\n                    }\n                    canvasPointerdown(event) {\n                        if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n                            return;\n                        }\n                        this.setInForeground();\n                        event.preventDefault();\n                        if (event.type !== \"mouse\") {\n                            this.div.focus();\n                        }\n                        this.#startDrawing(event.offsetX, event.offsetY);\n                    }\n                    canvasPointermove(event) {\n                        event.preventDefault();\n                        this.#draw(event.offsetX, event.offsetY);\n                    }\n                    canvasPointerup(event) {\n                        event.preventDefault();\n                        this.#endDrawing(event);\n                    }\n                    canvasPointerleave(event) {\n                        this.#endDrawing(event);\n                    }\n                    #endDrawing(event) {\n                        this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        setTimeout(()=>{\n                            this.canvas.removeEventListener(\"contextmenu\", _display_utils.noContextMenu);\n                        }, 10);\n                        this.#stopDrawing(event.offsetX, event.offsetY);\n                        this.addToAnnotationStorage();\n                        this.setInBackground();\n                    }\n                    #createCanvas() {\n                        this.canvas = document.createElement(\"canvas\");\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.className = \"inkEditorCanvas\";\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then((msg)=>this.canvas?.setAttribute(\"aria-label\", msg));\n                        this.div.append(this.canvas);\n                        this.ctx = this.canvas.getContext(\"2d\");\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries)=>{\n                            const rect = entries[0].contentRect;\n                            if (rect.width && rect.height) {\n                                this.setDimensions(rect.width, rect.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    get isResizable() {\n                        return !this.isEmpty() && this.#disableEditing;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        _editor.AnnotationEditor._l10nPromise.get(\"editor_ink2_aria_label\").then((msg)=>this.div?.setAttribute(\"aria-label\", msg));\n                        const [x, y, w, h] = this.#getInitialBBox();\n                        this.setAt(x, y, 0, 0);\n                        this.setDims(w, h);\n                        this.#createCanvas();\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n                            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.setDims(this.width * parentWidth, this.height * parentHeight);\n                            this.#redraw();\n                            this.div.classList.add(\"disabled\");\n                        } else {\n                            this.div.classList.add(\"editing\");\n                            this.enableEditMode();\n                        }\n                        this.#createObserver();\n                        return this.div;\n                    }\n                    #setCanvasDims() {\n                        if (!this.#isCanvasInitialized) {\n                            return;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.canvas.width = Math.ceil(this.width * parentWidth);\n                        this.canvas.height = Math.ceil(this.height * parentHeight);\n                        this.#updateTransform();\n                    }\n                    setDimensions(width, height) {\n                        const roundedWidth = Math.round(width);\n                        const roundedHeight = Math.round(height);\n                        if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n                            return;\n                        }\n                        this.#realWidth = roundedWidth;\n                        this.#realHeight = roundedHeight;\n                        this.canvas.style.visibility = \"hidden\";\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.fixAndSetPosition();\n                        if (this.#disableEditing) {\n                            this.#setScaleFactor(width, height);\n                        }\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.canvas.style.visibility = \"visible\";\n                        this.fixDims();\n                    }\n                    #setScaleFactor(width, height) {\n                        const padding = this.#getPadding();\n                        const scaleFactorW = (width - padding) / this.#baseWidth;\n                        const scaleFactorH = (height - padding) / this.#baseHeight;\n                        this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n                    }\n                    #updateTransform() {\n                        const padding = this.#getPadding() / 2;\n                        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n                    }\n                    static #buildPath2D(bezier) {\n                        const path2D = new Path2D();\n                        for(let i = 0, ii = bezier.length; i < ii; i++){\n                            const [first, control1, control2, second] = bezier[i];\n                            if (i === 0) {\n                                path2D.moveTo(...first);\n                            }\n                            path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n                        }\n                        return path2D;\n                    }\n                    static #toPDFCoordinates(points, rect, rotation) {\n                        const [blX, blY, trX, trY] = rect;\n                        switch(rotation){\n                            case 0:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] += blX;\n                                    points[i + 1] = trY - points[i + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = points[i + 1] + blX;\n                                    points[i + 1] = x + blY;\n                                }\n                                break;\n                            case 180:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] = trX - points[i];\n                                    points[i + 1] += blY;\n                                }\n                                break;\n                            case 270:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = trX - points[i + 1];\n                                    points[i + 1] = trY - x;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points;\n                    }\n                    static #fromPDFCoordinates(points, rect, rotation) {\n                        const [blX, blY, trX, trY] = rect;\n                        switch(rotation){\n                            case 0:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] -= blX;\n                                    points[i + 1] = trY - points[i + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = points[i + 1] - blY;\n                                    points[i + 1] = x - blX;\n                                }\n                                break;\n                            case 180:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    points[i] = trX - points[i];\n                                    points[i + 1] -= blY;\n                                }\n                                break;\n                            case 270:\n                                for(let i = 0, ii = points.length; i < ii; i += 2){\n                                    const x = points[i];\n                                    points[i] = trY - points[i + 1];\n                                    points[i + 1] = trX - x;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points;\n                    }\n                    #serializePaths(s, tx, ty, rect) {\n                        const paths = [];\n                        const padding = this.thickness / 2;\n                        const shiftX = s * tx + padding;\n                        const shiftY = s * ty + padding;\n                        for (const bezier of this.paths){\n                            const buffer = [];\n                            const points = [];\n                            for(let j = 0, jj = bezier.length; j < jj; j++){\n                                const [first, control1, control2, second] = bezier[j];\n                                const p10 = s * first[0] + shiftX;\n                                const p11 = s * first[1] + shiftY;\n                                const p20 = s * control1[0] + shiftX;\n                                const p21 = s * control1[1] + shiftY;\n                                const p30 = s * control2[0] + shiftX;\n                                const p31 = s * control2[1] + shiftY;\n                                const p40 = s * second[0] + shiftX;\n                                const p41 = s * second[1] + shiftY;\n                                if (j === 0) {\n                                    buffer.push(p10, p11);\n                                    points.push(p10, p11);\n                                }\n                                buffer.push(p20, p21, p30, p31, p40, p41);\n                                points.push(p20, p21);\n                                if (j === jj - 1) {\n                                    points.push(p40, p41);\n                                }\n                            }\n                            paths.push({\n                                bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n                                points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n                            });\n                        }\n                        return paths;\n                    }\n                    #getBbox() {\n                        let xMin = Infinity;\n                        let xMax = -Infinity;\n                        let yMin = Infinity;\n                        let yMax = -Infinity;\n                        for (const path of this.paths){\n                            for (const [first, control1, control2, second] of path){\n                                const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n                                xMin = Math.min(xMin, bbox[0]);\n                                yMin = Math.min(yMin, bbox[1]);\n                                xMax = Math.max(xMax, bbox[2]);\n                                yMax = Math.max(yMax, bbox[3]);\n                            }\n                        }\n                        return [\n                            xMin,\n                            yMin,\n                            xMax,\n                            yMax\n                        ];\n                    }\n                    #getPadding() {\n                        return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n                    }\n                    #fitToContent(firstTime = false) {\n                        if (this.isEmpty()) {\n                            return;\n                        }\n                        if (!this.#disableEditing) {\n                            this.#redraw();\n                            return;\n                        }\n                        const bbox = this.#getBbox();\n                        const padding = this.#getPadding();\n                        this.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                        this.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                        const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n                        const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.setAspectRatio(width, height);\n                        const prevTranslationX = this.translationX;\n                        const prevTranslationY = this.translationY;\n                        this.translationX = -bbox[0];\n                        this.translationY = -bbox[1];\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.#realWidth = width;\n                        this.#realHeight = height;\n                        this.setDims(width, height);\n                        const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n                        this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        if (data instanceof _annotation_layer.InkAnnotationElement) {\n                            return null;\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        editor.thickness = data.thickness;\n                        editor.color = _util.Util.makeHexColor(...data.color);\n                        editor.opacity = data.opacity;\n                        const [pageWidth, pageHeight] = editor.pageDimensions;\n                        const width = editor.width * pageWidth;\n                        const height = editor.height * pageHeight;\n                        const scaleFactor = editor.parentScale;\n                        const padding = data.thickness / 2;\n                        editor.#disableEditing = true;\n                        editor.#realWidth = Math.round(width);\n                        editor.#realHeight = Math.round(height);\n                        const { paths, rect, rotation } = data;\n                        for (let { bezier } of paths){\n                            bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n                            const path = [];\n                            editor.paths.push(path);\n                            let p0 = scaleFactor * (bezier[0] - padding);\n                            let p1 = scaleFactor * (bezier[1] - padding);\n                            for(let i = 2, ii = bezier.length; i < ii; i += 6){\n                                const p10 = scaleFactor * (bezier[i] - padding);\n                                const p11 = scaleFactor * (bezier[i + 1] - padding);\n                                const p20 = scaleFactor * (bezier[i + 2] - padding);\n                                const p21 = scaleFactor * (bezier[i + 3] - padding);\n                                const p30 = scaleFactor * (bezier[i + 4] - padding);\n                                const p31 = scaleFactor * (bezier[i + 5] - padding);\n                                path.push([\n                                    [\n                                        p0,\n                                        p1\n                                    ],\n                                    [\n                                        p10,\n                                        p11\n                                    ],\n                                    [\n                                        p20,\n                                        p21\n                                    ],\n                                    [\n                                        p30,\n                                        p31\n                                    ]\n                                ]);\n                                p0 = p30;\n                                p1 = p31;\n                            }\n                            const path2D = this.#buildPath2D(path);\n                            editor.bezierPath2D.push(path2D);\n                        }\n                        const bbox = editor.#getBbox();\n                        editor.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n                        editor.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n                        editor.#setScaleFactor(width, height);\n                        return editor;\n                    }\n                    serialize() {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const rect = this.getRect(0, 0);\n                        const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n                        return {\n                            annotationType: _util.AnnotationEditorType.INK,\n                            color,\n                            thickness: this.thickness,\n                            opacity: this.opacity,\n                            paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n                            pageIndex: this.pageIndex,\n                            rect,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                    }\n                }\n                exports1.InkEditor = InkEditor;\n            /***/ },\n            /* 34 */ /***/ (__unused_webpack_module, exports1, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampEditor = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _editor = __w_pdfjs_require__(4);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _annotation_layer = __w_pdfjs_require__(29);\n                class StampEditor extends _editor.AnnotationEditor {\n                    #bitmap;\n                    #bitmapId;\n                    #bitmapPromise;\n                    #bitmapUrl;\n                    #bitmapFile;\n                    #canvas;\n                    #observer;\n                    #resizeTimeoutId;\n                    #isSvg;\n                    #hasBeenAddedInUndoStack;\n                    static{\n                        this._type = \"stamp\";\n                    }\n                    constructor(params){\n                        super({\n                            ...params,\n                            name: \"stampEditor\"\n                        });\n                        this.#bitmap = null;\n                        this.#bitmapId = null;\n                        this.#bitmapPromise = null;\n                        this.#bitmapUrl = null;\n                        this.#bitmapFile = null;\n                        this.#canvas = null;\n                        this.#observer = null;\n                        this.#resizeTimeoutId = null;\n                        this.#isSvg = false;\n                        this.#hasBeenAddedInUndoStack = false;\n                        this.#bitmapUrl = params.bitmapUrl;\n                        this.#bitmapFile = params.bitmapFile;\n                    }\n                    static initialize(l10n) {\n                        _editor.AnnotationEditor.initialize(l10n);\n                    }\n                    static get supportedTypes() {\n                        const types = [\n                            \"apng\",\n                            \"avif\",\n                            \"bmp\",\n                            \"gif\",\n                            \"jpeg\",\n                            \"png\",\n                            \"svg+xml\",\n                            \"webp\",\n                            \"x-icon\"\n                        ];\n                        return (0, _util.shadow)(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n                    }\n                    static get supportedTypesStr() {\n                        return (0, _util.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n                    }\n                    static isHandlingMimeForPasting(mime) {\n                        return this.supportedTypes.includes(mime);\n                    }\n                    static paste(item, parent) {\n                        parent.pasteEditor(_util.AnnotationEditorType.STAMP, {\n                            bitmapFile: item.getAsFile()\n                        });\n                    }\n                    #getBitmapFetched(data, fromId = false) {\n                        if (!data) {\n                            this.remove();\n                            return;\n                        }\n                        this.#bitmap = data.bitmap;\n                        if (!fromId) {\n                            this.#bitmapId = data.id;\n                            this.#isSvg = data.isSvg;\n                        }\n                        this.#createCanvas();\n                    }\n                    #getBitmapDone() {\n                        this.#bitmapPromise = null;\n                        this._uiManager.enableWaiting(false);\n                        if (this.#canvas) {\n                            this.div.focus();\n                        }\n                    }\n                    #getBitmap() {\n                        if (this.#bitmapId) {\n                            this._uiManager.enableWaiting(true);\n                            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapUrl) {\n                            const url = this.#bitmapUrl;\n                            this.#bitmapUrl = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapFile) {\n                            const file = this.#bitmapFile;\n                            this.#bitmapFile = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        const input = document.createElement(\"input\");\n                        input.type = \"file\";\n                        input.accept = StampEditor.supportedTypesStr;\n                        this.#bitmapPromise = new Promise((resolve)=>{\n                            input.addEventListener(\"change\", async ()=>{\n                                if (!input.files || input.files.length === 0) {\n                                    this.remove();\n                                } else {\n                                    this._uiManager.enableWaiting(true);\n                                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                                    this.#getBitmapFetched(data);\n                                }\n                                resolve();\n                            });\n                            input.addEventListener(\"cancel\", ()=>{\n                                this.remove();\n                                resolve();\n                            });\n                        }).finally(()=>this.#getBitmapDone());\n                        input.click();\n                    }\n                    remove() {\n                        if (this.#bitmapId) {\n                            this.#bitmap = null;\n                            this._uiManager.imageManager.deleteId(this.#bitmapId);\n                            this.#canvas?.remove();\n                            this.#canvas = null;\n                            this.#observer?.disconnect();\n                            this.#observer = null;\n                        }\n                        super.remove();\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            if (this.#bitmapId) {\n                                this.#getBitmap();\n                            }\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (this.#bitmapId) {\n                            this.#getBitmap();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    onceAdded() {\n                        this._isDraggable = true;\n                        this.div.focus();\n                    }\n                    isEmpty() {\n                        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n                    }\n                    get isResizable() {\n                        return true;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX, baseY;\n                        if (this.width) {\n                            baseX = this.x;\n                            baseY = this.y;\n                        }\n                        super.render();\n                        this.div.hidden = true;\n                        if (this.#bitmap) {\n                            this.#createCanvas();\n                        } else {\n                            this.#getBitmap();\n                        }\n                        if (this.width) {\n                            const [parentWidth, parentHeight] = this.parentDimensions;\n                            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n                        }\n                        return this.div;\n                    }\n                    #createCanvas() {\n                        const { div } = this;\n                        let { width, height } = this.#bitmap;\n                        const [pageWidth, pageHeight] = this.pageDimensions;\n                        const MAX_RATIO = 0.75;\n                        if (this.width) {\n                            width = this.width * pageWidth;\n                            height = this.height * pageHeight;\n                        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n                            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n                            width *= factor;\n                            height *= factor;\n                        }\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n                        this._uiManager.enableWaiting(false);\n                        const canvas = this.#canvas = document.createElement(\"canvas\");\n                        div.append(canvas);\n                        div.hidden = false;\n                        this.#drawBitmap(width, height);\n                        this.#createObserver();\n                        if (!this.#hasBeenAddedInUndoStack) {\n                            this.parent.addUndoableEditor(this);\n                            this.#hasBeenAddedInUndoStack = true;\n                        }\n                        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                            source: this,\n                            details: {\n                                type: \"editing\",\n                                subtype: this.editorType,\n                                data: {\n                                    action: \"inserted_image\"\n                                }\n                            }\n                        });\n                        this.addAltTextButton();\n                    }\n                    #setDimensions(width, height) {\n                        const [parentWidth, parentHeight] = this.parentDimensions;\n                        this.width = width / parentWidth;\n                        this.height = height / parentHeight;\n                        this.setDims(width, height);\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        } else {\n                            this.fixAndSetPosition();\n                        }\n                        this._initialOptions = null;\n                        if (this.#resizeTimeoutId !== null) {\n                            clearTimeout(this.#resizeTimeoutId);\n                        }\n                        const TIME_TO_WAIT = 200;\n                        this.#resizeTimeoutId = setTimeout(()=>{\n                            this.#resizeTimeoutId = null;\n                            this.#drawBitmap(width, height);\n                        }, TIME_TO_WAIT);\n                    }\n                    #scaleBitmap(width, height) {\n                        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n                        let newWidth = bitmapWidth;\n                        let newHeight = bitmapHeight;\n                        let bitmap = this.#bitmap;\n                        while(newWidth > 2 * width || newHeight > 2 * height){\n                            const prevWidth = newWidth;\n                            const prevHeight = newHeight;\n                            if (newWidth > 2 * width) {\n                                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n                            }\n                            if (newHeight > 2 * height) {\n                                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n                            }\n                            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n                            const ctx = offscreen.getContext(\"2d\");\n                            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n                            bitmap = offscreen.transferToImageBitmap();\n                        }\n                        return bitmap;\n                    }\n                    #drawBitmap(width, height) {\n                        width = Math.ceil(width);\n                        height = Math.ceil(height);\n                        const canvas = this.#canvas;\n                        if (!canvas || canvas.width === width && canvas.height === height) {\n                            return;\n                        }\n                        canvas.width = width;\n                        canvas.height = height;\n                        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);\n                        const ctx = canvas.getContext(\"2d\");\n                        ctx.filter = this._uiManager.hcmFilter;\n                        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n                    }\n                    #serializeBitmap(toUrl) {\n                        if (toUrl) {\n                            if (this.#isSvg) {\n                                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                                if (url) {\n                                    return url;\n                                }\n                            }\n                            const canvas = document.createElement(\"canvas\");\n                            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n                            const ctx = canvas.getContext(\"2d\");\n                            ctx.drawImage(this.#bitmap, 0, 0);\n                            return canvas.toDataURL();\n                        }\n                        if (this.#isSvg) {\n                            const [pageWidth, pageHeight] = this.pageDimensions;\n                            const width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const offscreen = new OffscreenCanvas(width, height);\n                            const ctx = offscreen.getContext(\"2d\");\n                            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n                            return offscreen.transferToImageBitmap();\n                        }\n                        return structuredClone(this.#bitmap);\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries)=>{\n                            const rect = entries[0].contentRect;\n                            if (rect.width && rect.height) {\n                                this.#setDimensions(rect.width, rect.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    static deserialize(data, parent, uiManager) {\n                        if (data instanceof _annotation_layer.StampAnnotationElement) {\n                            return null;\n                        }\n                        const editor = super.deserialize(data, parent, uiManager);\n                        const { rect, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n                        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n                            editor.#bitmapId = bitmapId;\n                        } else {\n                            editor.#bitmapUrl = bitmapUrl;\n                        }\n                        editor.#isSvg = isSvg;\n                        const [parentWidth, parentHeight] = editor.pageDimensions;\n                        editor.width = (rect[2] - rect[0]) / parentWidth;\n                        editor.height = (rect[3] - rect[1]) / parentHeight;\n                        if (accessibilityData) {\n                            editor.altTextData = accessibilityData;\n                        }\n                        return editor;\n                    }\n                    serialize(isForCopying = false, context = null) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const serialized = {\n                            annotationType: _util.AnnotationEditorType.STAMP,\n                            bitmapId: this.#bitmapId,\n                            pageIndex: this.pageIndex,\n                            rect: this.getRect(0, 0),\n                            rotation: this.rotation,\n                            isSvg: this.#isSvg,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying) {\n                            serialized.bitmapUrl = this.#serializeBitmap(true);\n                            serialized.accessibilityData = this.altTextData;\n                            return serialized;\n                        }\n                        const { decorative, altText } = this.altTextData;\n                        if (!decorative && altText) {\n                            serialized.accessibilityData = {\n                                type: \"Figure\",\n                                alt: altText\n                            };\n                        }\n                        if (context === null) {\n                            return serialized;\n                        }\n                        context.stamps ||= new Map();\n                        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n                        if (!context.stamps.has(this.#bitmapId)) {\n                            context.stamps.set(this.#bitmapId, {\n                                area,\n                                serialized\n                            });\n                            serialized.bitmap = this.#serializeBitmap(false);\n                        } else if (this.#isSvg) {\n                            const prevData = context.stamps.get(this.#bitmapId);\n                            if (area > prevData.area) {\n                                prevData.area = area;\n                                prevData.serialized.bitmap.close();\n                                prevData.serialized.bitmap = this.#serializeBitmap(false);\n                            }\n                        }\n                        return serialized;\n                    }\n                }\n                exports1.StampEditor = StampEditor;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __w_pdfjs_require__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __w_pdfjs_require__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n        (()=>{\n            var exports1 = __nested_webpack_exports__;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            Object.defineProperty(exports1, \"AbortException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AbortException;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_editor_layer.AnnotationEditorLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorParamsType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationEditorParamsType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationEditorType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorUIManager\", {\n                enumerable: true,\n                get: function() {\n                    return _tools.AnnotationEditorUIManager;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_layer.AnnotationLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationMode\", {\n                enumerable: true,\n                get: function() {\n                    return _util.AnnotationMode;\n                }\n            });\n            Object.defineProperty(exports1, \"CMapCompressionType\", {\n                enumerable: true,\n                get: function() {\n                    return _util.CMapCompressionType;\n                }\n            });\n            Object.defineProperty(exports1, \"DOMSVGFactory\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.DOMSVGFactory;\n                }\n            });\n            Object.defineProperty(exports1, \"FeatureTest\", {\n                enumerable: true,\n                get: function() {\n                    return _util.FeatureTest;\n                }\n            });\n            Object.defineProperty(exports1, \"GlobalWorkerOptions\", {\n                enumerable: true,\n                get: function() {\n                    return _worker_options.GlobalWorkerOptions;\n                }\n            });\n            Object.defineProperty(exports1, \"ImageKind\", {\n                enumerable: true,\n                get: function() {\n                    return _util.ImageKind;\n                }\n            });\n            Object.defineProperty(exports1, \"InvalidPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.InvalidPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"MissingPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.MissingPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"OPS\", {\n                enumerable: true,\n                get: function() {\n                    return _util.OPS;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDataRangeTransport\", {\n                enumerable: true,\n                get: function() {\n                    return _api.PDFDataRangeTransport;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDateString\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.PDFDateString;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFWorker\", {\n                enumerable: true,\n                get: function() {\n                    return _api.PDFWorker;\n                }\n            });\n            Object.defineProperty(exports1, \"PasswordResponses\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PasswordResponses;\n                }\n            });\n            Object.defineProperty(exports1, \"PermissionFlag\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PermissionFlag;\n                }\n            });\n            Object.defineProperty(exports1, \"PixelsPerInch\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.PixelsPerInch;\n                }\n            });\n            Object.defineProperty(exports1, \"PromiseCapability\", {\n                enumerable: true,\n                get: function() {\n                    return _util.PromiseCapability;\n                }\n            });\n            Object.defineProperty(exports1, \"RenderingCancelledException\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.RenderingCancelledException;\n                }\n            });\n            Object.defineProperty(exports1, \"SVGGraphics\", {\n                enumerable: true,\n                get: function() {\n                    return _api.SVGGraphics;\n                }\n            });\n            Object.defineProperty(exports1, \"UnexpectedResponseException\", {\n                enumerable: true,\n                get: function() {\n                    return _util.UnexpectedResponseException;\n                }\n            });\n            Object.defineProperty(exports1, \"Util\", {\n                enumerable: true,\n                get: function() {\n                    return _util.Util;\n                }\n            });\n            Object.defineProperty(exports1, \"VerbosityLevel\", {\n                enumerable: true,\n                get: function() {\n                    return _util.VerbosityLevel;\n                }\n            });\n            Object.defineProperty(exports1, \"XfaLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _xfa_layer.XfaLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"build\", {\n                enumerable: true,\n                get: function() {\n                    return _api.build;\n                }\n            });\n            Object.defineProperty(exports1, \"createValidAbsoluteUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _util.createValidAbsoluteUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getDocument\", {\n                enumerable: true,\n                get: function() {\n                    return _api.getDocument;\n                }\n            });\n            Object.defineProperty(exports1, \"getFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getPdfFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getPdfFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getXfaPageViewport\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.getXfaPageViewport;\n                }\n            });\n            Object.defineProperty(exports1, \"isDataScheme\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.isDataScheme;\n                }\n            });\n            Object.defineProperty(exports1, \"isPdfFile\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.isPdfFile;\n                }\n            });\n            Object.defineProperty(exports1, \"loadScript\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.loadScript;\n                }\n            });\n            Object.defineProperty(exports1, \"noContextMenu\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.noContextMenu;\n                }\n            });\n            Object.defineProperty(exports1, \"normalizeUnicode\", {\n                enumerable: true,\n                get: function() {\n                    return _util.normalizeUnicode;\n                }\n            });\n            Object.defineProperty(exports1, \"renderTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer.renderTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"setLayerDimensions\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils.setLayerDimensions;\n                }\n            });\n            Object.defineProperty(exports1, \"shadow\", {\n                enumerable: true,\n                get: function() {\n                    return _util.shadow;\n                }\n            });\n            Object.defineProperty(exports1, \"updateTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer.updateTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"version\", {\n                enumerable: true,\n                get: function() {\n                    return _api.version;\n                }\n            });\n            var _util = __w_pdfjs_require__(1);\n            var _api = __w_pdfjs_require__(2);\n            var _display_utils = __w_pdfjs_require__(6);\n            var _text_layer = __w_pdfjs_require__(26);\n            var _annotation_editor_layer = __w_pdfjs_require__(27);\n            var _tools = __w_pdfjs_require__(5);\n            var _annotation_layer = __w_pdfjs_require__(29);\n            var _worker_options = __w_pdfjs_require__(14);\n            var _xfa_layer = __w_pdfjs_require__(32);\n            const pdfjsVersion = \"3.11.174\";\n            const pdfjsBuild = \"ce8716743\";\n        })();\n        /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=pdf.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUEsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRixLQUFLSSxRQUFRLEdBQUdIO1NBQzdCLEVBS3FEQTtBQUMzRCxHQUFHTSxZQUFZO0lBQ2YsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7O1lBRXJDLEtBQUssR0FDTCxHQUFHLEdBQUksQ0FBQ0MseUJBQXlCUDtnQkFJakNRLE9BQU9DLGNBQWMsQ0FBQ1QsVUFBUyxjQUFlO29CQUM1Q1UsT0FBTztnQkFDVDtnQkFDQVYsU0FBUVcsY0FBYyxHQUFHWCxTQUFRWSxJQUFJLEdBQUdaLFNBQVFhLHFCQUFxQixHQUFHYixTQUFRYywyQkFBMkIsR0FBR2QsU0FBUWUsaUJBQWlCLEdBQUdmLFNBQVFnQixtQkFBbUIsR0FBR2hCLFNBQVFpQixpQkFBaUIsR0FBR2pCLFNBQVFrQixjQUFjLEdBQUdsQixTQUFRbUIsaUJBQWlCLEdBQUduQixTQUFRb0IsaUJBQWlCLEdBQUdwQixTQUFRcUIsbUJBQW1CLEdBQUdyQixTQUFRc0IsR0FBRyxHQUFHdEIsU0FBUXVCLG1CQUFtQixHQUFHdkIsU0FBUXdCLHVCQUF1QixHQUFHeEIsU0FBUXlCLFdBQVcsR0FBR3pCLFNBQVEwQixtQkFBbUIsR0FBRzFCLFNBQVEyQixtQkFBbUIsR0FBRzNCLFNBQVE0QixTQUFTLEdBQUc1QixTQUFRNkIsZUFBZSxHQUFHN0IsU0FBUThCLFdBQVcsR0FBRzlCLFNBQVErQixXQUFXLEdBQUcvQixTQUFRZ0Msb0JBQW9CLEdBQUdoQyxTQUFRaUMsdUJBQXVCLEdBQUdqQyxTQUFRa0MsbUJBQW1CLEdBQUdsQyxT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RTt3QkFDekJvSyxNQUFNLENBQUMsRUFBRSxJQUFJcEssU0FBUyxDQUFDLEVBQUU7b0JBQzNCO29CQUNBLE9BQU9BLFVBQVVzSyxFQUFFLEVBQUVDLEVBQUUsRUFBRTt3QkFDdkIsT0FBTzs0QkFBQ0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7NEJBQUVELEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLEdBQUdELEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFOzRCQUFFRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRTs0QkFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7NEJBQUVELEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLEdBQUdELEVBQUUsQ0FBQyxFQUFFLEdBQUdDLEVBQUUsQ0FBQyxFQUFFLEdBQUdELEVBQUUsQ0FBQyxFQUFFOzRCQUFFQSxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRSxHQUFHQyxFQUFFLENBQUMsRUFBRSxHQUFHRCxFQUFFLENBQUMsRUFBRTt5QkFBQztvQkFDbk47b0JBQ0EsT0FBT0UsZUFBZUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7d0JBQzFCLE1BQU1DLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO3dCQUMzQyxNQUFNRSxLQUFLSCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMs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O0lBQ3BDLE1BQU0sR0FBRztBQUVULElBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi5qcz84OTE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY3N0YXJ0IFRoZSBmb2xsb3dpbmcgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMjMgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbmQgVGhlIGFib3ZlIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICovXG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCIsIFtdLCAoKSA9PiB7IHJldHVybiAocm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKSk7IH0pO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcbn0pKGdsb2JhbFRoaXMsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IChbXG4vKiAwICovLFxuLyogMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IGV4cG9ydHMuVXRpbCA9IGV4cG9ydHMuVW5rbm93bkVycm9yRXhjZXB0aW9uID0gZXhwb3J0cy5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBleHBvcnRzLlRleHRSZW5kZXJpbmdNb2RlID0gZXhwb3J0cy5SZW5kZXJpbmdJbnRlbnRGbGFnID0gZXhwb3J0cy5Qcm9taXNlQ2FwYWJpbGl0eSA9IGV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBleHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IGV4cG9ydHMuUGFnZUFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuT1BTID0gZXhwb3J0cy5NaXNzaW5nUERGRXhjZXB0aW9uID0gZXhwb3J0cy5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IGV4cG9ydHMuTElORV9GQUNUT1IgPSBleHBvcnRzLkxJTkVfREVTQ0VOVF9GQUNUT1IgPSBleHBvcnRzLkludmFsaWRQREZFeGNlcHRpb24gPSBleHBvcnRzLkltYWdlS2luZCA9IGV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gZXhwb3J0cy5Gb3JtYXRFcnJvciA9IGV4cG9ydHMuRmVhdHVyZVRlc3QgPSBleHBvcnRzLkZPTlRfSURFTlRJVFlfTUFUUklYID0gZXhwb3J0cy5Eb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuQ01hcENvbXByZXNzaW9uVHlwZSA9IGV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IGV4cG9ydHMuQkFTRUxJTkVfRkFDVE9SID0gZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvblByZWZpeCA9IGV4cG9ydHMuQW5ub3RhdGlvbk1vZGUgPSBleHBvcnRzLkFubm90YXRpb25GbGFnID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmllbGRGbGFnID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSBleHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBleHBvcnRzLkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSBleHBvcnRzLkFib3J0RXhjZXB0aW9uID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5jcmVhdGVWYWxpZEFic29sdXRlVXJsID0gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbmV4cG9ydHMuZ2V0TW9kaWZpY2F0aW9uRGF0ZSA9IGdldE1vZGlmaWNhdGlvbkRhdGU7XG5leHBvcnRzLmdldFV1aWQgPSBnZXRVdWlkO1xuZXhwb3J0cy5nZXRWZXJib3NpdHlMZXZlbCA9IGdldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5pbmZvID0gaW5mbztcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5leHBvcnRzLmlzQXJyYXlFcXVhbCA9IGlzQXJyYXlFcXVhbDtcbmV4cG9ydHMuaXNOb2RlSlMgPSB2b2lkIDA7XG5leHBvcnRzLm5vcm1hbGl6ZVVuaWNvZGUgPSBub3JtYWxpemVVbmljb2RlO1xuZXhwb3J0cy5vYmplY3RGcm9tTWFwID0gb2JqZWN0RnJvbU1hcDtcbmV4cG9ydHMub2JqZWN0U2l6ZSA9IG9iamVjdFNpemU7XG5leHBvcnRzLnNldFZlcmJvc2l0eUxldmVsID0gc2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLnNoYWRvdyA9IHNoYWRvdztcbmV4cG9ydHMuc3RyaW5nMzIgPSBzdHJpbmczMjtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLnN0cmluZ1RvUERGU3RyaW5nID0gc3RyaW5nVG9QREZTdHJpbmc7XG5leHBvcnRzLnN0cmluZ1RvVVRGOFN0cmluZyA9IHN0cmluZ1RvVVRGOFN0cmluZztcbmV4cG9ydHMudW5yZWFjaGFibGUgPSB1bnJlYWNoYWJsZTtcbmV4cG9ydHMudXRmOFN0cmluZ1RvU3RyaW5nID0gdXRmOFN0cmluZ1RvU3RyaW5nO1xuZXhwb3J0cy53YXJuID0gd2FybjtcbmNvbnN0IGlzTm9kZUpTID0gdHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyArIFwiXCIgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmICFwcm9jZXNzLnZlcnNpb25zLm53ICYmICEocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAmJiBwcm9jZXNzLnR5cGUgJiYgcHJvY2Vzcy50eXBlICE9PSBcImJyb3dzZXJcIik7XG5leHBvcnRzLmlzTm9kZUpTID0gaXNOb2RlSlM7XG5jb25zdCBJREVOVElUWV9NQVRSSVggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5leHBvcnRzLklERU5USVRZX01BVFJJWCA9IElERU5USVRZX01BVFJJWDtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5leHBvcnRzLkZPTlRfSURFTlRJVFlfTUFUUklYID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG5jb25zdCBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IDEwZTY7XG5leHBvcnRzLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEU7XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5leHBvcnRzLkxJTkVfRkFDVE9SID0gTElORV9GQUNUT1I7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmV4cG9ydHMuTElORV9ERVNDRU5UX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1I7XG5jb25zdCBCQVNFTElORV9GQUNUT1IgPSBMSU5FX0RFU0NFTlRfRkFDVE9SIC8gTElORV9GQUNUT1I7XG5leHBvcnRzLkJBU0VMSU5FX0ZBQ1RPUiA9IEJBU0VMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuZXhwb3J0cy5SZW5kZXJpbmdJbnRlbnRGbGFnID0gUmVuZGVyaW5nSW50ZW50RmxhZztcbmNvbnN0IEFubm90YXRpb25Nb2RlID0ge1xuICBESVNBQkxFOiAwLFxuICBFTkFCTEU6IDEsXG4gIEVOQUJMRV9GT1JNUzogMixcbiAgRU5BQkxFX1NUT1JBR0U6IDNcbn07XG5leHBvcnRzLkFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGU7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9lZGl0b3JfXCI7XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JQcmVmaXggPSBBbm5vdGF0aW9uRWRpdG9yUHJlZml4O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyM1xufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTtcbmNvbnN0IFBlcm1pc3Npb25GbGFnID0ge1xuICBQUklOVDogMHgwNCxcbiAgTU9ESUZZX0NPTlRFTlRTOiAweDA4LFxuICBDT1BZOiAweDEwLFxuICBNT0RJRllfQU5OT1RBVElPTlM6IDB4MjAsXG4gIEZJTExfSU5URVJBQ1RJVkVfRk9STVM6IDB4MTAwLFxuICBDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZOiAweDIwMCxcbiAgQVNTRU1CTEU6IDB4NDAwLFxuICBQUklOVF9ISUdIX1FVQUxJVFk6IDB4ODAwXG59O1xuZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IFBlcm1pc3Npb25GbGFnO1xuY29uc3QgVGV4dFJlbmRlcmluZ01vZGUgPSB7XG4gIEZJTEw6IDAsXG4gIFNUUk9LRTogMSxcbiAgRklMTF9TVFJPS0U6IDIsXG4gIElOVklTSUJMRTogMyxcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxuICBGSUxMX1NUUk9LRV9BRERfVE9fUEFUSDogNixcbiAgQUREX1RPX1BBVEg6IDcsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5leHBvcnRzLlRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGU7XG5jb25zdCBJbWFnZUtpbmQgPSB7XG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxuICBSR0JfMjRCUFA6IDIsXG4gIFJHQkFfMzJCUFA6IDNcbn07XG5leHBvcnRzLkltYWdlS2luZCA9IEltYWdlS2luZDtcbmNvbnN0IEFubm90YXRpb25UeXBlID0ge1xuICBURVhUOiAxLFxuICBMSU5LOiAyLFxuICBGUkVFVEVYVDogMyxcbiAgTElORTogNCxcbiAgU1FVQVJFOiA1LFxuICBDSVJDTEU6IDYsXG4gIFBPTFlHT046IDcsXG4gIFBPTFlMSU5FOiA4LFxuICBISUdITElHSFQ6IDksXG4gIFVOREVSTElORTogMTAsXG4gIFNRVUlHR0xZOiAxMSxcbiAgU1RSSUtFT1VUOiAxMixcbiAgU1RBTVA6IDEzLFxuICBDQVJFVDogMTQsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgRklMRUFUVEFDSE1FTlQ6IDE3LFxuICBTT1VORDogMTgsXG4gIE1PVklFOiAxOSxcbiAgV0lER0VUOiAyMCxcbiAgU0NSRUVOOiAyMSxcbiAgUFJJTlRFUk1BUks6IDIyLFxuICBUUkFQTkVUOiAyMyxcbiAgV0FURVJNQVJLOiAyNCxcbiAgVEhSRUVEOiAyNSxcbiAgUkVEQUNUOiAyNlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblR5cGUgPSBBbm5vdGF0aW9uVHlwZTtcbmNvbnN0IEFubm90YXRpb25SZXBseVR5cGUgPSB7XG4gIEdST1VQOiBcIkdyb3VwXCIsXG4gIFJFUExZOiBcIlJcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IEFubm90YXRpb25SZXBseVR5cGU7XG5jb25zdCBBbm5vdGF0aW9uRmxhZyA9IHtcbiAgSU5WSVNJQkxFOiAweDAxLFxuICBISURERU46IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBOT1pPT006IDB4MDgsXG4gIE5PUk9UQVRFOiAweDEwLFxuICBOT1ZJRVc6IDB4MjAsXG4gIFJFQURPTkxZOiAweDQwLFxuICBMT0NLRUQ6IDB4ODAsXG4gIFRPR0dMRU5PVklFVzogMHgxMDAsXG4gIExPQ0tFRENPTlRFTlRTOiAweDIwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBBbm5vdGF0aW9uRmxhZztcbmNvbnN0IEFubm90YXRpb25GaWVsZEZsYWcgPSB7XG4gIFJFQURPTkxZOiAweDAwMDAwMDEsXG4gIFJFUVVJUkVEOiAweDAwMDAwMDIsXG4gIE5PRVhQT1JUOiAweDAwMDAwMDQsXG4gIE1VTFRJTElORTogMHgwMDAxMDAwLFxuICBQQVNTV09SRDogMHgwMDAyMDAwLFxuICBOT1RPR0dMRVRPT0ZGOiAweDAwMDQwMDAsXG4gIFJBRElPOiAweDAwMDgwMDAsXG4gIFBVU0hCVVRUT046IDB4MDAxMDAwMCxcbiAgQ09NQk86IDB4MDAyMDAwMCxcbiAgRURJVDogMHgwMDQwMDAwLFxuICBTT1JUOiAweDAwODAwMDAsXG4gIEZJTEVTRUxFQ1Q6IDB4MDEwMDAwMCxcbiAgTVVMVElTRUxFQ1Q6IDB4MDIwMDAwMCxcbiAgRE9OT1RTUEVMTENIRUNLOiAweDA0MDAwMDAsXG4gIERPTk9UU0NST0xMOiAweDA4MDAwMDAsXG4gIENPTUI6IDB4MTAwMDAwMCxcbiAgUklDSFRFWFQ6IDB4MjAwMDAwMCxcbiAgUkFESU9TSU5VTklTT046IDB4MjAwMDAwMCxcbiAgQ09NTUlUT05TRUxDSEFOR0U6IDB4NDAwMDAwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IEFubm90YXRpb25GaWVsZEZsYWc7XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0gQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZTtcbmNvbnN0IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSB7XG4gIEU6IFwiTW91c2UgRW50ZXJcIixcbiAgWDogXCJNb3VzZSBFeGl0XCIsXG4gIEQ6IFwiTW91c2UgRG93blwiLFxuICBVOiBcIk1vdXNlIFVwXCIsXG4gIEZvOiBcIkZvY3VzXCIsXG4gIEJsOiBcIkJsdXJcIixcbiAgUE86IFwiUGFnZU9wZW5cIixcbiAgUEM6IFwiUGFnZUNsb3NlXCIsXG4gIFBWOiBcIlBhZ2VWaXNpYmxlXCIsXG4gIFBJOiBcIlBhZ2VJbnZpc2libGVcIixcbiAgSzogXCJLZXlzdHJva2VcIixcbiAgRjogXCJGb3JtYXRcIixcbiAgVjogXCJWYWxpZGF0ZVwiLFxuICBDOiBcIkNhbGN1bGF0ZVwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0gQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0ge1xuICBXQzogXCJXaWxsQ2xvc2VcIixcbiAgV1M6IFwiV2lsbFNhdmVcIixcbiAgRFM6IFwiRGlkU2F2ZVwiLFxuICBXUDogXCJXaWxsUHJpbnRcIixcbiAgRFA6IFwiRGlkUHJpbnRcIlxufTtcbmV4cG9ydHMuRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IFBhZ2VBY3Rpb25FdmVudFR5cGUgPSB7XG4gIE86IFwiUGFnZU9wZW5cIixcbiAgQzogXCJQYWdlQ2xvc2VcIlxufTtcbmV4cG9ydHMuUGFnZUFjdGlvbkV2ZW50VHlwZSA9IFBhZ2VBY3Rpb25FdmVudFR5cGU7XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG5jb25zdCBDTWFwQ29tcHJlc3Npb25UeXBlID0ge1xuICBOT05FOiAwLFxuICBCSU5BUlk6IDFcbn07XG5leHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBDTWFwQ29tcHJlc3Npb25UeXBlO1xuY29uc3QgT1BTID0ge1xuICBkZXBlbmRlbmN5OiAxLFxuICBzZXRMaW5lV2lkdGg6IDIsXG4gIHNldExpbmVDYXA6IDMsXG4gIHNldExpbmVKb2luOiA0LFxuICBzZXRNaXRlckxpbWl0OiA1LFxuICBzZXREYXNoOiA2LFxuICBzZXRSZW5kZXJpbmdJbnRlbnQ6IDcsXG4gIHNldEZsYXRuZXNzOiA4LFxuICBzZXRHU3RhdGU6IDksXG4gIHNhdmU6IDEwLFxuICByZXN0b3JlOiAxMSxcbiAgdHJhbnNmb3JtOiAxMixcbiAgbW92ZVRvOiAxMyxcbiAgbGluZVRvOiAxNCxcbiAgY3VydmVUbzogMTUsXG4gIGN1cnZlVG8yOiAxNixcbiAgY3VydmVUbzM6IDE3LFxuICBjbG9zZVBhdGg6IDE4LFxuICByZWN0YW5nbGU6IDE5LFxuICBzdHJva2U6IDIwLFxuICBjbG9zZVN0cm9rZTogMjEsXG4gIGZpbGw6IDIyLFxuICBlb0ZpbGw6IDIzLFxuICBmaWxsU3Ryb2tlOiAyNCxcbiAgZW9GaWxsU3Ryb2tlOiAyNSxcbiAgY2xvc2VGaWxsU3Ryb2tlOiAyNixcbiAgY2xvc2VFT0ZpbGxTdHJva2U6IDI3LFxuICBlbmRQYXRoOiAyOCxcbiAgY2xpcDogMjksXG4gIGVvQ2xpcDogMzAsXG4gIGJlZ2luVGV4dDogMzEsXG4gIGVuZFRleHQ6IDMyLFxuICBzZXRDaGFyU3BhY2luZzogMzMsXG4gIHNldFdvcmRTcGFjaW5nOiAzNCxcbiAgc2V0SFNjYWxlOiAzNSxcbiAgc2V0TGVhZGluZzogMzYsXG4gIHNldEZvbnQ6IDM3LFxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZTogMzgsXG4gIHNldFRleHRSaXNlOiAzOSxcbiAgbW92ZVRleHQ6IDQwLFxuICBzZXRMZWFkaW5nTW92ZVRleHQ6IDQxLFxuICBzZXRUZXh0TWF0cml4OiA0MixcbiAgbmV4dExpbmU6IDQzLFxuICBzaG93VGV4dDogNDQsXG4gIHNob3dTcGFjZWRUZXh0OiA0NSxcbiAgbmV4dExpbmVTaG93VGV4dDogNDYsXG4gIG5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0OiA0NyxcbiAgc2V0Q2hhcldpZHRoOiA0OCxcbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzOiA0OSxcbiAgc2V0U3Ryb2tlQ29sb3JTcGFjZTogNTAsXG4gIHNldEZpbGxDb2xvclNwYWNlOiA1MSxcbiAgc2V0U3Ryb2tlQ29sb3I6IDUyLFxuICBzZXRTdHJva2VDb2xvck46IDUzLFxuICBzZXRGaWxsQ29sb3I6IDU0LFxuICBzZXRGaWxsQ29sb3JOOiA1NSxcbiAgc2V0U3Ryb2tlR3JheTogNTYsXG4gIHNldEZpbGxHcmF5OiA1NyxcbiAgc2V0U3Ryb2tlUkdCQ29sb3I6IDU4LFxuICBzZXRGaWxsUkdCQ29sb3I6IDU5LFxuICBzZXRTdHJva2VDTVlLQ29sb3I6IDYwLFxuICBzZXRGaWxsQ01ZS0NvbG9yOiA2MSxcbiAgc2hhZGluZ0ZpbGw6IDYyLFxuICBiZWdpbklubGluZUltYWdlOiA2MyxcbiAgYmVnaW5JbWFnZURhdGE6IDY0LFxuICBlbmRJbmxpbmVJbWFnZTogNjUsXG4gIHBhaW50WE9iamVjdDogNjYsXG4gIG1hcmtQb2ludDogNjcsXG4gIG1hcmtQb2ludFByb3BzOiA2OCxcbiAgYmVnaW5NYXJrZWRDb250ZW50OiA2OSxcbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6IDcwLFxuICBlbmRNYXJrZWRDb250ZW50OiA3MSxcbiAgYmVnaW5Db21wYXQ6IDcyLFxuICBlbmRDb21wYXQ6IDczLFxuICBwYWludEZvcm1YT2JqZWN0QmVnaW46IDc0LFxuICBwYWludEZvcm1YT2JqZWN0RW5kOiA3NSxcbiAgYmVnaW5Hcm91cDogNzYsXG4gIGVuZEdyb3VwOiA3NyxcbiAgYmVnaW5Bbm5vdGF0aW9uOiA4MCxcbiAgZW5kQW5ub3RhdGlvbjogODEsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxXG59O1xuZXhwb3J0cy5PUFMgPSBPUFM7XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xuZXhwb3J0cy5QYXNzd29yZFJlc3BvbnNlcyA9IFBhc3N3b3JkUmVzcG9uc2VzO1xubGV0IHZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTO1xuZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwobGV2ZWwpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIobGV2ZWwpKSB7XG4gICAgdmVyYm9zaXR5ID0gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5JTkZPUykge1xuICAgIGNvbnNvbGUubG9nKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgfVxufVxuZnVuY3Rpb24gdW5yZWFjaGFibGUobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBfaXNWYWxpZFByb3RvY29sKHVybCkge1xuICBzd2l0Y2ggKHVybD8ucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgYmFzZVVybCA9IG51bGwsIG9wdGlvbnMgPSBudWxsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAob3B0aW9ucy5hZGREZWZhdWx0UHJvdG9jb2wgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgICAgIGNvbnN0IGRvdHMgPSB1cmwubWF0Y2goL1xcLi9nKTtcbiAgICAgICAgaWYgKGRvdHM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50cnlDb252ZXJ0RW5jb2RpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBzdHJpbmdUb1VURjhTdHJpbmcodXJsKTtcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYnNvbHV0ZVVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG4gICAgaWYgKF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGVVcmw7XG4gICAgfVxuICB9IGNhdGNoIHt9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUsIG5vblNlcmlhbGl6YWJsZSA9IGZhbHNlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiAhbm9uU2VyaWFsaXphYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VFeGNlcHRpb24pIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUV4Y2VwdGlvbi5cIik7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gQmFzZUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEJhc2VFeGNlcHRpb247XG59KCk7XG5leHBvcnRzLkJhc2VFeGNlcHRpb24gPSBCYXNlRXhjZXB0aW9uO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmV4cG9ydHMuUGFzc3dvcmRFeGNlcHRpb24gPSBQYXNzd29yZEV4Y2VwdGlvbjtcbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmV4cG9ydHMuVW5rbm93bkVycm9yRXhjZXB0aW9uID0gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0cy5JbnZhbGlkUERGRXhjZXB0aW9uID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcbmNsYXNzIE1pc3NpbmdQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IE1pc3NpbmdQREZFeGNlcHRpb247XG5jbGFzcyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBzdGF0dXMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB9XG59XG5leHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuZXhwb3J0cy5Gb3JtYXRFcnJvciA9IEZvcm1hdEVycm9yO1xuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5leHBvcnRzLkFib3J0RXhjZXB0aW9uID0gQWJvcnRFeGNlcHRpb247XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzdHJpbmczMih2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSA+PiAyNCAmIDB4ZmYsIHZhbHVlID4+IDE2ICYgMHhmZiwgdmFsdWUgPj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XG59XG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvYmplY3RGcm9tTWFwKG1hcCkge1xuICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRmVhdHVyZVRlc3Qge1xuICBzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0xpdHRsZUVuZGlhblwiLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNFdmFsU3VwcG9ydGVkXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgICBpc1dpbjogZmFsc2UsXG4gICAgICAgIGlzTWFjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc1dpbjogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgaXNNYWM6IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmNsdWRlcyhcIk1hY1wiKVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmV4cG9ydHMuRmVhdHVyZVRlc3QgPSBGZWF0dXJlVGVzdDtcbmNvbnN0IGhleE51bWJlcnMgPSBbLi4uQXJyYXkoMjU2KS5rZXlzKCldLm1hcChuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNV07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBjb25zdCB4dCA9IChwWzBdICogbVszXSAtIHBbMV0gKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIGNvbnN0IHl0ID0gKC1wWzBdICogbVsxXSArIHBbMV0gKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuICAgIGNvbnN0IHAxID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgY29uc3QgcDQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG4gICAgY29uc3QgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuICAgIGNvbnN0IGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBiID0gbVswXSAqIHRyYW5zcG9zZVsxXSArIG1bMV0gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydCgoYSArIGQpICoqIDIgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgY29uc3QgdHZhbHVlcyA9IFtdLFxuICAgICAgYm91bmRzID0gW1tdLCBbXV07XG4gICAgbGV0IGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgc3FydGIyYWMgPSBNYXRoLnNxcnQoYjJhYyk7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgIG10O1xuICAgIGNvbnN0IGpsZW4gPSBqO1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgbXQgPSAxIC0gdDtcbiAgICAgIGJvdW5kc1swXVtqXSA9IG10ICogbXQgKiBtdCAqIHgwICsgMyAqIG10ICogbXQgKiB0ICogeDEgKyAzICogbXQgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgICBib3VuZHNbMV1bal0gPSBtdCAqIG10ICogbXQgKiB5MCArIDMgKiBtdCAqIG10ICogdCAqIHkxICsgMyAqIG10ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgIH1cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG4gICAgcmV0dXJuIFtNYXRoLm1pbiguLi5ib3VuZHNbMF0pLCBNYXRoLm1pbiguLi5ib3VuZHNbMV0pLCBNYXRoLm1heCguLi5ib3VuZHNbMF0pLCBNYXRoLm1heCguLi5ib3VuZHNbMV0pXTtcbiAgfVxufVxuZXhwb3J0cy5VdGlsID0gVXRpbDtcbmNvbnN0IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MmQ4LCAweDJjNywgMHgyYzYsIDB4MmQ5LCAweDJkZCwgMHgyZGIsIDB4MmRhLCAweDJkYywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM2EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMWUsIDB4MjAxYywgMHgyMDFkLCAweDIwMTgsIDB4MjAxOSwgMHgyMDFhLCAweDIxMjIsIDB4ZmIwMSwgMHhmYjAyLCAweDE0MSwgMHgxNTIsIDB4MTYwLCAweDE3OCwgMHgxN2QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3ZSwgMCwgMHgyMGFjXTtcbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0cikge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZiZVwiO1xuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEVGXCIgJiYgc3RyWzFdID09PSBcIlxceEJCXCIgJiYgc3RyWzJdID09PSBcIlxceEJGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtOFwiO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc3RyaW5nVG9CeXRlcyhzdHIpO1xuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHdhcm4oYHN0cmluZ1RvUERGU3RyaW5nOiBcIiR7ZXh9XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Py5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycjEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoKSkge1xuICBjb25zdCBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxuY2xhc3MgUHJvbWlzZUNhcGFiaWxpdHkge1xuICAjc2V0dGxlZCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSBkYXRhID0+IHtcbiAgICAgICAgdGhpcy4jc2V0dGxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLiNzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldCBzZXR0bGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXR0bGVkO1xuICB9XG59XG5leHBvcnRzLlByb21pc2VDYXBhYmlsaXR5ID0gUHJvbWlzZUNhcGFiaWxpdHk7XG5sZXQgTm9ybWFsaXplUmVnZXggPSBudWxsO1xubGV0IE5vcm1hbGl6YXRpb25NYXAgPSBudWxsO1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShzdHIpIHtcbiAgaWYgKCFOb3JtYWxpemVSZWdleCkge1xuICAgIE5vcm1hbGl6ZVJlZ2V4ID0gLyhbXFx1MDBhMFxcdTAwYjVcXHUwMzdlXFx1MGViM1xcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMTI2XFx1ZmIwMC1cXHVmYjA0XFx1ZmIwNlxcdWZiMjAtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYTFcXHVmYmE0LVxcdWZiYTlcXHVmYmFlLVxcdWZiYjFcXHVmYmQzLVxcdWZiZGNcXHVmYmRlLVxcdWZiZTdcXHVmYmVhLVxcdWZiZjhcXHVmYmZjLVxcdWZiZmRcXHVmYzAwLVxcdWZjNWRcXHVmYzY0LVxcdWZjZjFcXHVmY2Y1LVxcdWZkM2RcXHVmZDg4XFx1ZmRmNFxcdWZkZmEtXFx1ZmRmYlxcdWZlNzFcXHVmZTc3XFx1ZmU3OVxcdWZlN2JcXHVmZTdkXSspfChcXHVmYjA1KykvZ3U7XG4gICAgTm9ybWFsaXphdGlvbk1hcCA9IG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4ge1xuICAgIHJldHVybiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNyeXB0bz8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmV4cG9ydHMuQW5ub3RhdGlvblByZWZpeCA9IEFubm90YXRpb25QcmVmaXg7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5SZW5kZXJUYXNrID0gZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gZXhwb3J0cy5QREZXb3JrZXIgPSBleHBvcnRzLlBERlBhZ2VQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSBleHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdEZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTVkdHcmFwaGljc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlTdmcuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pKTtcbmV4cG9ydHMuYnVpbGQgPSB2b2lkIDA7XG5leHBvcnRzLmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQ7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfZm9udF9sb2FkZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIF9kaXNwbGF5Tm9kZV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIF9jYW52YXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBfd29ya2VyX29wdGlvbnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBfbWVzc2FnZV9oYW5kbGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG52YXIgX21ldGFkYXRhID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG52YXIgX29wdGlvbmFsX2NvbnRlbnRfY29uZmlnID0gX193X3BkZmpzX3JlcXVpcmVfXygxNyk7XG52YXIgX3RyYW5zcG9ydF9zdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBfZGlzcGxheUZldGNoX3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xudmFyIF9kaXNwbGF5TmV0d29yayA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIF9kaXNwbGF5Tm9kZV9zdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciBfZGlzcGxheVN2ZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjQpO1xudmFyIF94ZmFfdGV4dCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xuY29uc3QgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFID0gNjU1MzY7XG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5jb25zdCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBEZWZhdWx0Q2FudmFzRmFjdG9yeSA9IF91dGlsLmlzTm9kZUpTID8gX2Rpc3BsYXlOb2RlX3V0aWxzLk5vZGVDYW52YXNGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NQ2FudmFzRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBEZWZhdWx0Q2FudmFzRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IF91dGlsLmlzTm9kZUpTID8gX2Rpc3BsYXlOb2RlX3V0aWxzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSBEZWZhdWx0Q01hcFJlYWRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0RmlsdGVyRmFjdG9yeSA9IF91dGlsLmlzTm9kZUpTID8gX2Rpc3BsYXlOb2RlX3V0aWxzLk5vZGVGaWx0ZXJGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NRmlsdGVyRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdEZpbHRlckZhY3RvcnkgPSBEZWZhdWx0RmlsdGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IF91dGlsLmlzTm9kZUpTID8gX2Rpc3BsYXlOb2RlX3V0aWxzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5mdW5jdGlvbiBnZXREb2N1bWVudChzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHNyYyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIGluIGdldERvY3VtZW50LCBuZWVkIHBhcmFtZXRlciBvYmplY3QuXCIpO1xuICB9XG4gIGlmICghc3JjLnVybCAmJiAhc3JjLmRhdGEgJiYgIXNyYy5yYW5nZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIG9iamVjdDogbmVlZCBlaXRoZXIgLmRhdGEsIC5yYW5nZSBvciAudXJsXCIpO1xuICB9XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBjb25zdCB7XG4gICAgZG9jSWRcbiAgfSA9IHRhc2s7XG4gIGNvbnN0IHVybCA9IHNyYy51cmwgPyBnZXRVcmxQcm9wKHNyYy51cmwpIDogbnVsbDtcbiAgY29uc3QgZGF0YSA9IHNyYy5kYXRhID8gZ2V0RGF0YVByb3Aoc3JjLmRhdGEpIDogbnVsbDtcbiAgY29uc3QgaHR0cEhlYWRlcnMgPSBzcmMuaHR0cEhlYWRlcnMgfHwgbnVsbDtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gc3JjLndpdGhDcmVkZW50aWFscyA9PT0gdHJ1ZTtcbiAgY29uc3QgcGFzc3dvcmQgPSBzcmMucGFzc3dvcmQgPz8gbnVsbDtcbiAgY29uc3QgcmFuZ2VUcmFuc3BvcnQgPSBzcmMucmFuZ2UgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgPyBzcmMucmFuZ2UgOiBudWxsO1xuICBjb25zdCByYW5nZUNodW5rU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLnJhbmdlQ2h1bmtTaXplKSAmJiBzcmMucmFuZ2VDaHVua1NpemUgPiAwID8gc3JjLnJhbmdlQ2h1bmtTaXplIDogREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFO1xuICBsZXQgd29ya2VyID0gc3JjLndvcmtlciBpbnN0YW5jZW9mIFBERldvcmtlciA/IHNyYy53b3JrZXIgOiBudWxsO1xuICBjb25zdCB2ZXJib3NpdHkgPSBzcmMudmVyYm9zaXR5O1xuICBjb25zdCBkb2NCYXNlVXJsID0gdHlwZW9mIHNyYy5kb2NCYXNlVXJsID09PSBcInN0cmluZ1wiICYmICEoMCwgX2Rpc3BsYXlfdXRpbHMuaXNEYXRhU2NoZW1lKShzcmMuZG9jQmFzZVVybCkgPyBzcmMuZG9jQmFzZVVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBVcmwgPSB0eXBlb2Ygc3JjLmNNYXBVcmwgPT09IFwic3RyaW5nXCIgPyBzcmMuY01hcFVybCA6IG51bGw7XG4gIGNvbnN0IGNNYXBQYWNrZWQgPSBzcmMuY01hcFBhY2tlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IENNYXBSZWFkZXJGYWN0b3J5ID0gc3JjLkNNYXBSZWFkZXJGYWN0b3J5IHx8IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbiAgY29uc3Qgc3RhbmRhcmRGb250RGF0YVVybCA9IHR5cGVvZiBzcmMuc3RhbmRhcmRGb250RGF0YVVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbDtcbiAgY29uc3QgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBzcmMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICBjb25zdCBpZ25vcmVFcnJvcnMgPSBzcmMuc3RvcEF0RXJyb3JzICE9PSB0cnVlO1xuICBjb25zdCBtYXhJbWFnZVNpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5tYXhJbWFnZVNpemUpICYmIHNyYy5tYXhJbWFnZVNpemUgPiAtMSA/IHNyYy5tYXhJbWFnZVNpemUgOiAtMTtcbiAgY29uc3QgaXNFdmFsU3VwcG9ydGVkID0gc3JjLmlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gIGNvbnN0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID0gdHlwZW9mIHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9PT0gXCJib29sZWFuXCIgPyBzcmMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgOiAhX3V0aWwuaXNOb2RlSlM7XG4gIGNvbnN0IGNhbnZhc01heEFyZWFJbkJ5dGVzID0gTnVtYmVyLmlzSW50ZWdlcihzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMpID8gc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzIDogLTE7XG4gIGNvbnN0IGRpc2FibGVGb250RmFjZSA9IHR5cGVvZiBzcmMuZGlzYWJsZUZvbnRGYWNlID09PSBcImJvb2xlYW5cIiA/IHNyYy5kaXNhYmxlRm9udEZhY2UgOiBfdXRpbC5pc05vZGVKUztcbiAgY29uc3QgZm9udEV4dHJhUHJvcGVydGllcyA9IHNyYy5mb250RXh0cmFQcm9wZXJ0aWVzID09PSB0cnVlO1xuICBjb25zdCBlbmFibGVYZmEgPSBzcmMuZW5hYmxlWGZhID09PSB0cnVlO1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gc3JjLm93bmVyRG9jdW1lbnQgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudDtcbiAgY29uc3QgZGlzYWJsZVJhbmdlID0gc3JjLmRpc2FibGVSYW5nZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZVN0cmVhbSA9IHNyYy5kaXNhYmxlU3RyZWFtID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlQXV0b0ZldGNoID0gc3JjLmRpc2FibGVBdXRvRmV0Y2ggPT09IHRydWU7XG4gIGNvbnN0IHBkZkJ1ZyA9IHNyYy5wZGZCdWcgPT09IHRydWU7XG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlVHJhbnNwb3J0ID8gcmFuZ2VUcmFuc3BvcnQubGVuZ3RoIDogc3JjLmxlbmd0aCA/PyBOYU47XG4gIGNvbnN0IHVzZVN5c3RlbUZvbnRzID0gdHlwZW9mIHNyYy51c2VTeXN0ZW1Gb250cyA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlU3lzdGVtRm9udHMgOiAhX3V0aWwuaXNOb2RlSlMgJiYgIWRpc2FibGVGb250RmFjZTtcbiAgY29uc3QgdXNlV29ya2VyRmV0Y2ggPSB0eXBlb2Ygc3JjLnVzZVdvcmtlckZldGNoID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VXb3JrZXJGZXRjaCA6IENNYXBSZWFkZXJGYWN0b3J5ID09PSBfZGlzcGxheV91dGlscy5ET01DTWFwUmVhZGVyRmFjdG9yeSAmJiBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9PT0gX2Rpc3BsYXlfdXRpbHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmICgwLCBfZGlzcGxheV91dGlscy5pc1ZhbGlkRmV0Y2hVcmwpKGNNYXBVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmICgwLCBfZGlzcGxheV91dGlscy5pc1ZhbGlkRmV0Y2hVcmwpKHN0YW5kYXJkRm9udERhdGFVcmwsIGRvY3VtZW50LmJhc2VVUkkpO1xuICBjb25zdCBjYW52YXNGYWN0b3J5ID0gc3JjLmNhbnZhc0ZhY3RvcnkgfHwgbmV3IERlZmF1bHRDYW52YXNGYWN0b3J5KHtcbiAgICBvd25lckRvY3VtZW50XG4gIH0pO1xuICBjb25zdCBmaWx0ZXJGYWN0b3J5ID0gc3JjLmZpbHRlckZhY3RvcnkgfHwgbmV3IERlZmF1bHRGaWx0ZXJGYWN0b3J5KHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50XG4gIH0pO1xuICBjb25zdCBzdHlsZUVsZW1lbnQgPSBudWxsO1xuICAoMCwgX3V0aWwuc2V0VmVyYm9zaXR5TGV2ZWwpKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5XG4gIH07XG4gIGlmICghdXNlV29ya2VyRmV0Y2gpIHtcbiAgICB0cmFuc3BvcnRGYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5ID0gbmV3IENNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IGNNYXBVcmwsXG4gICAgICBpc0NvbXByZXNzZWQ6IGNNYXBQYWNrZWRcbiAgICB9KTtcbiAgICB0cmFuc3BvcnRGYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gbmV3IFN0YW5kYXJkRm9udERhdGFGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHN0YW5kYXJkRm9udERhdGFVcmxcbiAgICB9KTtcbiAgfVxuICBpZiAoIXdvcmtlcikge1xuICAgIGNvbnN0IHdvcmtlclBhcmFtcyA9IHtcbiAgICAgIHZlcmJvc2l0eSxcbiAgICAgIHBvcnQ6IF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9O1xuICAgIHdvcmtlciA9IHdvcmtlclBhcmFtcy5wb3J0ID8gUERGV29ya2VyLmZyb21Qb3J0KHdvcmtlclBhcmFtcykgOiBuZXcgUERGV29ya2VyKHdvcmtlclBhcmFtcyk7XG4gICAgdGFzay5fd29ya2VyID0gd29ya2VyO1xuICB9XG4gIGNvbnN0IGZldGNoRG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246ICczLjExLjE3NCcsXG4gICAgZGF0YSxcbiAgICBwYXNzd29yZCxcbiAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGxlbmd0aCxcbiAgICBkb2NCYXNlVXJsLFxuICAgIGVuYWJsZVhmYSxcbiAgICBldmFsdWF0b3JPcHRpb25zOiB7XG4gICAgICBtYXhJbWFnZVNpemUsXG4gICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICBpZ25vcmVFcnJvcnMsXG4gICAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCxcbiAgICAgIGNhbnZhc01heEFyZWFJbkJ5dGVzLFxuICAgICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICAgIHVzZVN5c3RlbUZvbnRzLFxuICAgICAgY01hcFVybDogdXNlV29ya2VyRmV0Y2ggPyBjTWFwVXJsIDogbnVsbCxcbiAgICAgIHN0YW5kYXJkRm9udERhdGFVcmw6IHVzZVdvcmtlckZldGNoID8gc3RhbmRhcmRGb250RGF0YVVybCA6IG51bGxcbiAgICB9XG4gIH07XG4gIGNvbnN0IHRyYW5zcG9ydFBhcmFtcyA9IHtcbiAgICBpZ25vcmVFcnJvcnMsXG4gICAgaXNFdmFsU3VwcG9ydGVkLFxuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgIGVuYWJsZVhmYSxcbiAgICBvd25lckRvY3VtZW50LFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcGRmQnVnLFxuICAgIHN0eWxlRWxlbWVudFxuICB9O1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya2VySWRQcm9taXNlID0gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBmZXRjaERvY1BhcmFtcyk7XG4gICAgY29uc3QgbmV0d29ya1N0cmVhbVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgbGV0IG5ldHdvcmtTdHJlYW07XG4gICAgICBpZiAocmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBfdHJhbnNwb3J0X3N0cmVhbS5QREZEYXRhVHJhbnNwb3J0U3RyZWFtKHtcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgaW5pdGlhbERhdGE6IHJhbmdlVHJhbnNwb3J0LmluaXRpYWxEYXRhLFxuICAgICAgICAgIHByb2dyZXNzaXZlRG9uZTogcmFuZ2VUcmFuc3BvcnQucHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiByYW5nZVRyYW5zcG9ydC5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgICB9LCByYW5nZVRyYW5zcG9ydCk7XG4gICAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0gPSBwYXJhbXMgPT4ge1xuICAgICAgICAgIGlmIChfdXRpbC5pc05vZGVKUykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfZGlzcGxheU5vZGVfc3RyZWFtLlBERk5vZGVTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICgwLCBfZGlzcGxheV91dGlscy5pc1ZhbGlkRmV0Y2hVcmwpKHBhcmFtcy51cmwpID8gbmV3IF9kaXNwbGF5RmV0Y2hfc3RyZWFtLlBERkZldGNoU3RyZWFtKHBhcmFtcykgOiBuZXcgX2Rpc3BsYXlOZXR3b3JrLlBERk5ldHdvcmtTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0oe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXR3b3JrU3RyZWFtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3dvcmtlcklkUHJvbWlzZSwgbmV0d29ya1N0cmVhbVByb21pc2VdKS50aGVuKGZ1bmN0aW9uIChbd29ya2VySWQsIG5ldHdvcmtTdHJlYW1dKSB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSk7XG4gICAgICB0YXNrLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiUmVhZHlcIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKHRhc2suX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgcmV0dXJuIHRhc2s7XG59XG5hc3luYyBmdW5jdGlvbiBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIHNvdXJjZSkge1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICB9XG4gIGNvbnN0IHdvcmtlcklkID0gYXdhaXQgd29ya2VyLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY1JlcXVlc3RcIiwgc291cmNlLCBzb3VyY2UuZGF0YSA/IFtzb3VyY2UuZGF0YS5idWZmZXJdIDogbnVsbCk7XG4gIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHdvcmtlcklkO1xufVxuZnVuY3Rpb24gZ2V0VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB2YWwuaHJlZjtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHZhbCwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHZhbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSB8fCAoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikodmFsKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgXCIgKyBcInN0cmluZywgb3IgYXJyYXktbGlrZSBvYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIGRhdGEgcHJvcGVydHkuXCIpO1xufVxuY2xhc3MgUERGRG9jdW1lbnRMb2FkaW5nVGFzayB7XG4gIHN0YXRpYyAjZG9jSWQgPSAwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9jYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICAgIHRoaXMuZG9jSWQgPSBgZCR7UERGRG9jdW1lbnRMb2FkaW5nVGFzay4jZG9jSWQrK31gO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblBhc3N3b3JkID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveSA9IHRydWU7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQ/LmRlc3Ryb3koKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fd29ya2VyLl9wZW5kaW5nRGVzdHJveTtcbiAgICAgIH1cbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLl93b3JrZXIpIHtcbiAgICAgIHRoaXMuX3dvcmtlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5QREZEb2N1bWVudExvYWRpbmdUYXNrID0gUERGRG9jdW1lbnRMb2FkaW5nVGFzaztcbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7fVxufVxuZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEphdmFTY3JpcHRcIiwge1xuICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiYFBERkRvY3VtZW50UHJveHkuZ2V0SmF2YVNjcmlwdGAsIFwiICsgXCJwbGVhc2UgdXNlIGBQREZEb2N1bWVudFByb3h5LmdldEpTQWN0aW9uc2AgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpTQWN0aW9ucygpLnRoZW4oanMgPT4ge1xuICAgICAgICAgIGlmICghanMpIHtcbiAgICAgICAgICAgIHJldHVybiBqcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNBcnIgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4ganMpIHtcbiAgICAgICAgICAgIGpzQXJyLnB1c2goLi4uanNbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ganNBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VJbmRleChyZWYpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYWJlbHMoKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RG9jSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNZXRhZGF0YSgpO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNhdmVEb2N1bWVudCgpO1xuICB9XG4gIGdldERvd25sb2FkSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzIHx8IHRoaXMuaXNQdXJlWGZhKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuZXhwb3J0cy5QREZEb2N1bWVudFByb3h5ID0gUERGRG9jdW1lbnRQcm94eTtcbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gICNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAjcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFnZUluZGV4LCBwYWdlSW5mbywgdHJhbnNwb3J0LCBwZGZCdWcgPSBmYWxzZSkge1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLl9wYWdlSW5mbyA9IHBhZ2VJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl9zdGF0cyA9IHBkZkJ1ZyA/IG5ldyBfZGlzcGxheV91dGlscy5TdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcGFnZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZGV4ICsgMTtcbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucmVmO1xuICB9XG4gIGdldCB1c2VyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udXNlclVuaXQ7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoe1xuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGUsXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IF9kaXNwbGF5X3V0aWxzLlBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXcsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCBpbnRlbnRBcmdzLnJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUpTQWN0aW9ucyh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIGlmICghb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgICB9XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlbnRQcmludCA9ICEhKGludGVudEFyZ3MucmVuZGVyaW5nSW50ZW50ICYgX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGUgPSBlcnJvciA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmICh0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciB8fCBpbnRlbnRQcmludCkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCFpbnRlbnRQcmludCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG4gIGdldE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGxcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKG9wTGlzdFRhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCB0cnVlKTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBsZXQgb3BMaXN0VGFzaztcbiAgICBpZiAoIWludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wTGlzdFRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCA9IG9wZXJhdG9yTGlzdENoYW5nZWQ7XG4gICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzdHJlYW1UZXh0Q29udGVudCh7XG4gICAgaW5jbHVkZU1hcmtlZENvbnRlbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBpbmNsdWRlTWFya2VkQ29udGVudCA9PT0gdHJ1ZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBkaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbih4ZmEgPT4ge1xuICAgICAgICByZXR1cm4gX3hmYV90ZXh0LlhmYVRleHQudGV4dENvbnRlbnQoeGZhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICAgIHB1bXAoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0U3RydWN0VHJlZSh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudFN0YXRlIG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVhc29uOiBuZXcgRXJyb3IoXCJQYWdlIHdhcyBkZXN0cm95ZWQuXCIpLFxuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICBjb25zdCBzdWNjZXNzID0gdGhpcy4jdHJ5Q2xlYW51cChmYWxzZSk7XG4gICAgaWYgKHJlc2V0U3RhdHMgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5fc3RhdHMgJiY9IG5ldyBfZGlzcGxheV91dGlscy5TdGF0VGltZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgI3RyeUNsZWFudXAoZGVsYXllZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlbGF5ZWQpIHtcbiAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICAgIH0sIERFTEFZRURfQ0xFQU5VUF9USU1FT1VUKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gICNhYm9ydERlbGF5ZWRDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpO1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHk/LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgfVxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaztcbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3Quc2VwYXJhdGVBbm5vdHMgPSBvcGVyYXRvckxpc3RDaHVuay5zZXBhcmF0ZUFubm90cztcbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaykge1xuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfSA9IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0T3BlcmF0b3JMaXN0XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXBcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBwdW1wKCk7XG4gIH1cbiAgX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnRTdGF0ZSxcbiAgICByZWFzb24sXG4gICAgZm9yY2UgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbikge1xuICAgICAgICBsZXQgZGVsYXkgPSBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQ7XG4gICAgICAgIGlmIChyZWFzb24uZXh0cmFEZWxheSA+IDAgJiYgcmVhc29uLmV4dHJhRGVsYXkgPCAxMDAwKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5leHBvcnRzLlBERlBhZ2VQcm94eSA9IFBERlBhZ2VQcm94eTtcbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuI2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG4gIHRlcm1pbmF0ZSgpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuZXhwb3J0cy5Mb29wYmFja1BvcnQgPSBMb29wYmFja1BvcnQ7XG5jb25zdCBQREZXb3JrZXJVdGlsID0ge1xuICBpc1dvcmtlckRpc2FibGVkOiBmYWxzZSxcbiAgZmFsbGJhY2tXb3JrZXJTcmM6IG51bGwsXG4gIGZha2VXb3JrZXJJZDogMFxufTtcbmV4cG9ydHMuUERGV29ya2VyVXRpbCA9IFBERldvcmtlclV0aWw7XG57XG4gIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjID0gXCIuL3BkZi53b3JrZXIuanNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBwZGZqc0ZpbGVQYXRoID0gZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQ/LnNyYztcbiAgICBpZiAocGRmanNGaWxlUGF0aCkge1xuICAgICAgUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyA9IHBkZmpzRmlsZVBhdGgucmVwbGFjZSgvKFxcLig/Om1pblxcLik/anMpKFxcPy4qKT8kL2ksIFwiLndvcmtlciQxJDJcIik7XG4gICAgfVxuICB9XG4gIFBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luID0gZnVuY3Rpb24gKGJhc2VVcmwsIG90aGVyVXJsKSB7XG4gICAgbGV0IGJhc2U7XG4gICAgdHJ5IHtcbiAgICAgIGJhc2UgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvdGhlciA9IG5ldyBVUkwob3RoZXJVcmwsIGJhc2UpO1xuICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICB9O1xuICBQREZXb3JrZXJVdGlsLmNyZWF0ZUNETldyYXBwZXIgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGBpbXBvcnRTY3JpcHRzKFwiJHt1cmx9XCIpO2A7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdKSk7XG4gIH07XG59XG5jbGFzcyBQREZXb3JrZXIge1xuICBzdGF0aWMgI3dvcmtlclBvcnRzO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSA9IG51bGwsXG4gICAgcG9ydCA9IG51bGwsXG4gICAgdmVyYm9zaXR5ID0gKDAsIF91dGlsLmdldFZlcmJvc2l0eUxldmVsKSgpXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKFBERldvcmtlci4jd29ya2VyUG9ydHM/Lmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIChQREZXb3JrZXIuI3dvcmtlclBvcnRzIHx8PSBuZXcgV2Vha01hcCgpKS5zZXQocG9ydCwgdGhpcyk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcnQ7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlSGFuZGxlcjtcbiAgfVxuICBfaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpIHtcbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgIH0pO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIGlmICghUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkICYmICFQREZXb3JrZXIuX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgbGV0IHtcbiAgICAgICAgd29ya2VyU3JjXG4gICAgICB9ID0gUERGV29ya2VyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZiwgd29ya2VyU3JjKSkge1xuICAgICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclNyYyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICAgIGNvbnN0IHRlcm1pbmF0ZUVhcmx5ID0gKCkgPT4ge1xuICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uV29ya2VyRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3dlYldvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgICAgICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZW5kVGVzdCgpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVzdE9iaiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAoMCwgX3V0aWwuaW5mbykoXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gIH1cbiAgX3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICBpZiAoIVBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyVXRpbC5mYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGlkICsgXCJfd29ya2VyXCIsIGlkLCBwb3J0KTtcbiAgICAgIFdvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHdvcmtlckhhbmRsZXIsIHBvcnQpO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgIHRoaXMuX3dlYldvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgfVxuICAgIFBERldvcmtlci4jd29ya2VyUG9ydHM/LmRlbGV0ZSh0aGlzLl9wb3J0KTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHM/LmdldChwYXJhbXMucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG4gICAgaWYgKFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmMgIT09IG51bGwpIHtcbiAgICAgIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0IF9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgPSB0aGlzLl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICBpZiAobWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBldmFsKFwicmVxdWlyZVwiKSh0aGlzLndvcmtlclNyYyk7XG4gICAgICAgIHJldHVybiB3b3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBhd2FpdCAoMCwgX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdCkodGhpcy53b3JrZXJTcmMpO1xuICAgICAgcmV0dXJuIHdpbmRvdy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5leHBvcnRzLlBERldvcmtlciA9IFBERldvcmtlcjtcbmNsYXNzIFdvcmtlclRyYW5zcG9ydCB7XG4gICNtZXRob2RQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgI3BhZ2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zLCBmYWN0b3J5KSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBfZm9udF9sb2FkZXIuRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gIH1cbiAgZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUgPSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBfYW5ub3RhdGlvbl9zdG9yYWdlLlNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5ZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5XCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByaW50XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAoYW5ub3RhdGlvbk1vZGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRElTQUJMRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRElTQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEVfU1RPUkFHRTpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfU1RPUkFHRTtcbiAgICAgICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9zdG9yYWdlLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPyBwcmludEFubm90YXRpb25TdG9yYWdlIDogdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBhbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBgJHtyZW5kZXJpbmdJbnRlbnR9XyR7YW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUuaGFzaH1gLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGVcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX25ldHdvcmtTdHJlYW0/LmNhbmNlbEFsbFJlcXVlc3RzKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIldvcmtlciB3YXMgdGVybWluYXRlZC5cIikpO1xuICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgaGVhZGVyc0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGNvbnN0IGZ1bGxSZWFkZXIgPSB0aGlzLl9mdWxsUmVhZGVyO1xuICAgICAgZnVsbFJlYWRlci5oZWFkZXJzUmVhZHkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghZnVsbFJlYWRlci5pc1N0cmVhbWluZ1N1cHBvcnRlZCB8fCAhZnVsbFJlYWRlci5pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcykge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgICAgaXNSYW5nZVN1cHBvcnRlZDogZnVsbFJlYWRlci5pc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGZ1bGxSZWFkZXIuY29udGVudExlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH0sIGhlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICByZXR1cm4gaGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJhbmdlUmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJhbmdlUmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuICAgICAgaWYgKCFyYW5nZVJlYWRlcikge1xuICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBmdW5jdGlvbiAoZXgpIHtcbiAgICAgIGxldCByZWFzb247XG4gICAgICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5JbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiRG9jRXhjZXB0aW9uIC0gZXhwZWN0ZWQgYSB2YWxpZCBFcnJvci5cIik7XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlBhc3N3b3JkUmVxdWVzdFwiLCBleGNlcHRpb24gPT4ge1xuICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICBpZiAobG9hZGluZ1Rhc2sub25QYXNzd29yZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblBhc3N3b3JkKHVwZGF0ZVBhc3N3b3JkLCBleGNlcHRpb24uY29kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QobmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKGV4Y2VwdGlvbi5tZXNzYWdlLCBleGNlcHRpb24uY29kZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBkYXRhID0+IHtcbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sZW5ndGgsXG4gICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlN0YXJ0UmVuZGVyUGFnZVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuY2FjaGVLZXkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiY29tbW9ub2JqXCIsIChbaWQsIHR5cGUsIGV4cG9ydGVkRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBFcnJvciBkdXJpbmcgZm9udCBsb2FkaW5nOiAke2V4cG9ydGVkRXJyb3J9YCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5zcGVjdEZvbnQgPSBwYXJhbXMucGRmQnVnICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZCA/IChmb250LCB1cmwpID0+IGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5mb250QWRkZWQoZm9udCwgdXJsKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBfZm9udF9sb2FkZXIuRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICBpc0V2YWxTdXBwb3J0ZWQ6IHBhcmFtcy5pc0V2YWxTdXBwb3J0ZWQsXG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBpZ25vcmVFcnJvcnM6IHBhcmFtcy5pZ25vcmVFcnJvcnMsXG4gICAgICAgICAgICBpbnNwZWN0Rm9udFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBpZiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGltYWdlRGF0YS5iaXRtYXApIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgICAgICB9ID0gaW1hZ2VEYXRhO1xuICAgICAgICAgICAgICBsZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZW5ndGggPSBpbWFnZURhdGEuZGF0YT8ubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gX3V0aWwuTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUpIHtcbiAgICAgICAgICAgICAgcGFnZVByb3h5Ll9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NQcm9ncmVzc1wiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJ1aWx0SW5DTWFwXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIikpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDTWFwUmVhZGVyRmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgYHVzZVdvcmtlckZldGNoYCBwYXJhbWV0ZXIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hTdGFuZGFyZEZvbnREYXRhXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIikpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgYHVzZVdvcmtlckZldGNoYCBwYXJhbWV0ZXIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJzYXZlRG9jdW1lbnQgY2FsbGVkIHdoaWxlIGBhbm5vdGF0aW9uU3RvcmFnZWAgaXMgZW1wdHksIFwiICsgXCJwbGVhc2UgdXNlIHRoZSBnZXREYXRhLW1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVycykuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI3BhZ2VQcm9taXNlcy5nZXQocGFnZUluZGV4KTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSkudGhlbihwYWdlSW5mbyA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAodHlwZW9mIHJlZiAhPT0gXCJvYmplY3RcIiB8fCByZWYgPT09IG51bGwgfHwgIU51bWJlci5pc0ludGVnZXIocmVmLm51bSkgfHwgcmVmLm51bSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocmVmLmdlbikgfHwgcmVmLmdlbiA8IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VJbmRleFwiLCB7XG4gICAgICBudW06IHJlZi5udW0sXG4gICAgICBnZW46IHJlZi5nZW5cbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRGaWVsZE9iamVjdHNcIik7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkhhc0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgaWRcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYWJlbHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBdHRhY2htZW50c1wiLCBudWxsKTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIiwgbnVsbCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJldHVybiBuZXcgX29wdGlvbmFsX2NvbnRlbnRfY29uZmlnLk9wdGlvbmFsQ29udGVudENvbmZpZyhyZXN1bHRzKTtcbiAgICB9KTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQZXJtaXNzaW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBuYW1lID0gXCJHZXRNZXRhZGF0YVwiLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgX21ldGFkYXRhLk1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gIH1cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9ID0gdGhpcy5fcGFyYW1zO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImxvYWRpbmdQYXJhbXNcIiwge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICBjYXBhYmlsaXR5OiBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKSxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLmNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmo/LmNhcGFiaWxpdHkuc2V0dGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nIG9iamVjdCB0aGF0IGlzbid0IHJlc29sdmVkIHlldCAke29iaklkfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiBvYmo/LmNhcGFiaWxpdHkuc2V0dGxlZCB8fCBmYWxzZTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgZGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgdGhpcy5vbkNvbnRpbnVlID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5leHBvcnRzLlJlbmRlclRhc2sgPSBSZW5kZXJUYXNrO1xuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgc3RhdGljICNjYW52YXNJblVzZSA9IG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYWxsYmFjayxcbiAgICBwYXJhbXMsXG4gICAgb2JqcyxcbiAgICBjb21tb25PYmpzLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgb3BlcmF0b3JMaXN0LFxuICAgIHBhZ2VJbmRleCxcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnksXG4gICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZmFsc2UsXG4gICAgcGRmQnVnID0gZmFsc2UsXG4gICAgcGFnZUNvbG9ycyA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0gPSB0aGlzLnBhcmFtcztcbiAgICB0aGlzLmdmeCA9IG5ldyBfY2FudmFzLkNhbnZhc0dyYXBoaWNzKGNhbnZhc0NvbnRleHQsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgfSwgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLCB0aGlzLnBhZ2VDb2xvcnMpO1xuICAgIHRoaXMuZ2Z4LmJlZ2luRHJhd2luZyh7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9KTtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IDA7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaz8uKCk7XG4gIH1cbiAgY2FuY2VsKGVycm9yID0gbnVsbCwgZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdGhpcy5nZng/LmVuZERyYXdpbmcoKTtcbiAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgIHRoaXMuY2FsbGJhY2soZXJyb3IgfHwgbmV3IF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSkpO1xuICB9XG4gIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHkpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIHx8PSB0aGlzLl9jb250aW51ZUJvdW5kO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSAnMy4xMS4xNzQnO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IGJ1aWxkID0gJ2NlODcxNjc0Myc7XG5leHBvcnRzLmJ1aWxkID0gYnVpbGQ7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TZXJpYWxpemFibGVFbXB0eSA9IGV4cG9ydHMuUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IGV4cG9ydHMuQW5ub3RhdGlvblN0b3JhZ2UgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9tdXJtdXJoYXNoID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXJzOiB1bmRlZmluZWRcbn0pO1xuZXhwb3J0cy5TZXJpYWxpemFibGVFbXB0eSA9IFNlcmlhbGl6YWJsZUVtcHR5O1xuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjbW9kaWZpZWQgPSBmYWxzZTtcbiAgI3N0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub25TZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vblJlc2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID0gbnVsbDtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IgJiYgdHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICB9XG4gIH1cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmhhcyhrZXkpO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplID4gMCA/ICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNzdG9yYWdlKSA6IG51bGw7XG4gIH1cbiAgc2V0QWxsKG9iaikge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZTtcbiAgfVxuICAjc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKCF0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uU2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uU2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25SZXNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblJlc2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHJldHVybiBuZXcgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBTZXJpYWxpemFibGVFbXB0eTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpLFxuICAgICAgaGFzaCA9IG5ldyBfbXVybXVyaGFzaC5NdXJtdXJIYXNoM182NCgpLFxuICAgICAgdHJhbnNmZXJzID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGhhc0JpdG1hcCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLiNzdG9yYWdlKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsIGluc3RhbmNlb2YgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yID8gdmFsLnNlcmlhbGl6ZShmYWxzZSwgY29udGV4dCkgOiB2YWw7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBtYXAuc2V0KGtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIGhhc2gudXBkYXRlKGAke2tleX06JHtKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKX1gKTtcbiAgICAgICAgaGFzQml0bWFwIHx8PSAhIXNlcmlhbGl6ZWQuYml0bWFwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQml0bWFwKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUuYml0bWFwKSB7XG4gICAgICAgICAgdHJhbnNmZXJzLnB1c2godmFsdWUuYml0bWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwLnNpemUgPiAwID8ge1xuICAgICAgbWFwLFxuICAgICAgaGFzaDogaGFzaC5oZXhkaWdlc3QoKSxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IEFubm90YXRpb25TdG9yYWdlO1xuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfSA9IHBhcmVudC5zZXJpYWxpemFibGU7XG4gICAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUobWFwLCB0cmFuc2ZlcnMgPyB7XG4gICAgICB0cmFuc2ZlcjogdHJhbnNmZXJzXG4gICAgfSA6IG51bGwpO1xuICAgIHRoaXMuI3NlcmlhbGl6YWJsZSA9IHtcbiAgICAgIG1hcDogY2xvbmUsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfTtcbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6YWJsZTtcbiAgfVxufVxuZXhwb3J0cy5QcmludEFubm90YXRpb25TdG9yYWdlID0gUHJpbnRBbm5vdGF0aW9uU3RvcmFnZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3IgPSB2b2lkIDA7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY2xhc3MgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbHRUZXh0ID0gXCJcIjtcbiAgI2FsdFRleHREZWNvcmF0aXZlID0gZmFsc2U7XG4gICNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICNrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgI3Jlc2l6ZXJzRGl2ID0gbnVsbDtcbiAgI2JvdW5kRm9jdXNpbiA9IHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpO1xuICAjYm91bmRGb2N1c291dCA9IHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKTtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpc0VkaXRpbmcgPSBmYWxzZTtcbiAgI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICBfaW5pdGlhbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIF9sMTBuUHJvbWlzZSA9IG51bGw7XG4gICNpc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAjekluZGV4ID0gQW5ub3RhdGlvbkVkaXRvci5fekluZGV4Kys7XG4gIHN0YXRpYyBfYm9yZGVyTGluZVdpZHRoID0gLTE7XG4gIHN0YXRpYyBfY29sb3JNYW5hZ2VyID0gbmV3IF90b29scy5Db2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgU01BTExfRURJVE9SX1NJWkUgPSAwO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBBbm5vdGF0aW9uRWRpdG9yLlwiKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICB0aGlzLmlkID0gcGFyYW1ldGVycy5pZDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFyYW1ldGVycy5wYXJlbnQucGFnZUluZGV4O1xuICAgIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMubmFtZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyID0gcGFyYW1ldGVycy51aU1hbmFnZXI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMuaXNDZW50ZXJlZCA9IHBhcmFtZXRlcnMuaXNDZW50ZXJlZDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5wYWdlUm90YXRpb24gPSAoMzYwICsgcm90YXRpb24gLSB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24pICUgMzYwO1xuICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLnBhZ2VUcmFuc2xhdGlvbiA9IFtwYWdlWCwgcGFnZVldO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnggPSBwYXJhbWV0ZXJzLnggLyB3aWR0aDtcbiAgICB0aGlzLnkgPSBwYXJhbWV0ZXJzLnkgLyBoZWlnaHQ7XG4gICAgdGhpcy5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgZWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl90eXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2RlZmF1bHRMaW5lQ29sb3JcIiwgdGhpcy5fY29sb3JNYW5hZ2VyLmdldEhleENvZGUoXCJDYW52YXNUZXh0XCIpKTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgY29uc3QgZmFrZUVkaXRvciA9IG5ldyBGYWtlRWRpdG9yKHtcbiAgICAgIGlkOiBlZGl0b3IucGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgcGFyZW50OiBlZGl0b3IucGFyZW50LFxuICAgICAgdWlNYW5hZ2VyOiBlZGl0b3IuX3VpTWFuYWdlclxuICAgIH0pO1xuICAgIGZha2VFZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGZha2VFZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gICAgZmFrZUVkaXRvci5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZmFrZUVkaXRvcik7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZSB8fD0gbmV3IE1hcChbXCJlZGl0b3JfYWx0X3RleHRfYnV0dG9uX2xhYmVsXCIsIFwiZWRpdG9yX2FsdF90ZXh0X2VkaXRfYnV0dG9uX2xhYmVsXCIsIFwiZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcFwiXS5tYXAoc3RyID0+IFtzdHIsIGwxMG4uZ2V0KHN0cildKSk7XG4gICAgaWYgKG9wdGlvbnM/LnN0cmluZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RyIG9mIG9wdGlvbnMuc3RyaW5ncykge1xuICAgICAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5zZXQoc3RyLCBsMTBuLmdldChzdHIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHt9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBfaXNEcmFnZ2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRHJhZ2dhYmxlO1xuICB9XG4gIHNldCBfaXNEcmFnZ2FibGUodmFsdWUpIHtcbiAgICB0aGlzLiNpc0RyYWdnYWJsZSA9IHZhbHVlO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhZ2dhYmxlXCIsIHZhbHVlKTtcbiAgfVxuICBjZW50ZXIoKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnggLT0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMueSAtPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllcjtcbiAgfVxuICBzZXRJbkJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gMDtcbiAgfVxuICBzZXRJbkZvcmVncm91bmQoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy4jekluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmVudC5wYWdlSW5kZXg7XG4gICAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gcGFyZW50LnBhZ2VEaW1lbnNpb25zO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQ2xpY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Py5pc011bHRpcGxlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgc2V0QXQoeCwgeSwgdHgsIHR5KSB7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih0eCwgdHkpO1xuICAgIHRoaXMueCA9ICh4ICsgdHgpIC8gd2lkdGg7XG4gICAgdGhpcy55ID0gKHkgKyB0eSkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFnZURpbWVuc2lvbnMsIHgsIHkpO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIGRyYWcodHgsIHR5KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCArPSB0eCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMueSArPSB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgKHRoaXMueCA8IDAgfHwgdGhpcy54ID4gMSB8fCB0aGlzLnkgPCAwIHx8IHRoaXMueSA+IDEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5maW5kTmV3UGFyZW50KHRoaXMsIHgsIHkpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy4jZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICAjZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBfYm9yZGVyTGluZVdpZHRoXG4gICAgfSA9IEFubm90YXRpb25FZGl0b3I7XG4gICAgY29uc3QgeCA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCB5ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbLXgsIHldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4LCAteV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgfVxuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlV2lkdGggLSB3aWR0aCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUhlaWdodCAtIGhlaWdodCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlV2lkdGggLSBoZWlnaHQsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KHdpZHRoLCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHggPSBNYXRoLm1pbihwYWdlV2lkdGgsIE1hdGgubWF4KHdpZHRoLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1pbihwYWdlSGVpZ2h0LCBNYXRoLm1heChoZWlnaHQsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgoaGVpZ2h0LCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gd2lkdGgsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMueCA9IHggLz0gcGFnZVdpZHRoO1xuICAgIHRoaXMueSA9IHkgLz0gcGFnZUhlaWdodDtcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuI2dldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgfVxuICBzdGF0aWMgI3JvdGF0ZVBvaW50KHgsIHksIGFuZ2xlKSB7XG4gICAgc3dpdGNoIChhbmdsZSkge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAteF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICBwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIDM2MCAtIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gICNnZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbikge1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCAtcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy0xLCAwLCAwLCAtMV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIC1wYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBhcmVudFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG4gIGdldCBwYXJlbnRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiArIHRoaXMucGFnZVJvdGF0aW9uKSAlIDM2MDtcbiAgfVxuICBnZXQgcGFyZW50RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gcGFnZVdpZHRoICogcGFyZW50U2NhbGU7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gcGFnZUhlaWdodCAqIHBhcmVudFNjYWxlO1xuICAgIHJldHVybiBfdXRpbC5GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkID8gW01hdGgucm91bmQoc2NhbGVkV2lkdGgpLCBNYXRoLnJvdW5kKHNjYWxlZEhlaWdodCldIDogW3NjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHRdO1xuICB9XG4gIHNldERpbXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IGAkeygxMDAgKiB3aWR0aCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogaGVpZ2h0IC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0QnV0dG9uPy5jbGFzc0xpc3QudG9nZ2xlKFwic21hbGxcIiwgd2lkdGggPCBBbm5vdGF0aW9uRWRpdG9yLlNNQUxMX0VESVRPUl9TSVpFIHx8IGhlaWdodCA8IEFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUpO1xuICB9XG4gIGZpeERpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qgd2lkdGhQZXJjZW50ID0gd2lkdGguZW5kc1dpdGgoXCIlXCIpO1xuICAgIGNvbnN0IGhlaWdodFBlcmNlbnQgPSAhdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmIGhlaWdodC5lbmRzV2l0aChcIiVcIik7XG4gICAgaWYgKHdpZHRoUGVyY2VudCAmJiBoZWlnaHRQZXJjZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAoIXdpZHRoUGVyY2VudCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogcGFyc2VGbG9hdCh3aWR0aCkgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgIWhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KGhlaWdodCkgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gICNjcmVhdGVSZXNpemVycygpIHtcbiAgICBpZiAodGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVzaXplcnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyc1wiKTtcbiAgICBjb25zdCBjbGFzc2VzID0gW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21MZWZ0XCJdO1xuICAgIGlmICghdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbykge1xuICAgICAgY2xhc3Nlcy5wdXNoKFwidG9wTWlkZGxlXCIsIFwibWlkZGxlUmlnaHRcIiwgXCJib3R0b21NaWRkbGVcIiwgXCJtaWRkbGVMZWZ0XCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2xhc3Nlcykge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZChkaXYpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJyZXNpemVyXCIsIG5hbWUpO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcmRvd24uYmluZCh0aGlzLCBuYW1lKSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIH1cbiAgICB0aGlzLmRpdi5wcmVwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJkb3duKG5hbWUsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm91bmRSZXNpemVyUG9pbnRlcm1vdmUgPSB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKTtcbiAgICBjb25zdCBzYXZlZERyYWdnYWJsZSA9IHRoaXMuX2lzRHJhZ2dhYmxlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgY29uc3QgcG9pbnRlck1vdmVPcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgYm91bmRSZXNpemVyUG9pbnRlcm1vdmUsIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkUGFyZW50Q3Vyc29yID0gdGhpcy5wYXJlbnQuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICBjb25zdCBzYXZlZEN1cnNvciA9IHRoaXMuZGl2LnN0eWxlLmN1cnNvcjtcbiAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZXZlbnQudGFyZ2V0KS5jdXJzb3I7XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHNhdmVkRHJhZ2dhYmxlO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgYm91bmRSZXNpemVyUG9pbnRlcm1vdmUsIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yID0gc2F2ZWRQYXJlbnRDdXJzb3I7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZEN1cnNvcjtcbiAgICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgICBjb25zdCBuZXdZID0gdGhpcy55O1xuICAgICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICBpZiAobmV3WCA9PT0gc2F2ZWRYICYmIG5ld1kgPT09IHNhdmVkWSAmJiBuZXdXaWR0aCA9PT0gc2F2ZWRXaWR0aCAmJiBuZXdIZWlnaHQgPT09IHNhdmVkSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgICAgdGhpcy54ID0gbmV3WDtcbiAgICAgICAgICB0aGlzLnkgPSBuZXdZO1xuICAgICAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICAgICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpZHRoID0gc2F2ZWRXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IHNhdmVkSGVpZ2h0O1xuICAgICAgICAgIHRoaXMueCA9IHNhdmVkWDtcbiAgICAgICAgICB0aGlzLnkgPSBzYXZlZFk7XG4gICAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHNhdmVkV2lkdGgsIHBhcmVudEhlaWdodCAqIHNhdmVkSGVpZ2h0KTtcbiAgICAgICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcm1vdmUobmFtZSwgZXZlbnQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qgc2F2ZWRYID0gdGhpcy54O1xuICAgIGNvbnN0IHNhdmVkWSA9IHRoaXMueTtcbiAgICBjb25zdCBzYXZlZFdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjb25zdCBzYXZlZEhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pbldpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IG1pbkhlaWdodCA9IEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUgLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgcm91bmQgPSB4ID0+IE1hdGgucm91bmQoeCAqIDEwMDAwKSAvIDEwMDAwO1xuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgodGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgdHJhbnNmID0gKHgsIHkpID0+IFtyb3RhdGlvbk1hdHJpeFswXSAqIHggKyByb3RhdGlvbk1hdHJpeFsyXSAqIHksIHJvdGF0aW9uTWF0cml4WzFdICogeCArIHJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgY29uc3QgaW52Um90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCgzNjAgLSB0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBpbnZUcmFuc2YgPSAoeCwgeSkgPT4gW2ludlJvdGF0aW9uTWF0cml4WzBdICogeCArIGludlJvdGF0aW9uTWF0cml4WzJdICogeSwgaW52Um90YXRpb25NYXRyaXhbMV0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBsZXQgZ2V0UG9pbnQ7XG4gICAgbGV0IGdldE9wcG9zaXRlO1xuICAgIGxldCBpc0RpYWdvbmFsID0gZmFsc2U7XG4gICAgbGV0IGlzSG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInRvcExlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BNaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVSaWdodFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21SaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbU1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21MZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlTGVmdFwiOlxuICAgICAgICBpc0hvcml6b250YWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgaCAvIDJdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaCAvIDJdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcG9pbnQgPSBnZXRQb2ludChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVQb2ludCA9IGdldE9wcG9zaXRlKHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBsZXQgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5vcHBvc2l0ZVBvaW50KTtcbiAgICBjb25zdCBvcHBvc2l0ZVggPSByb3VuZChzYXZlZFggKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdKTtcbiAgICBjb25zdCBvcHBvc2l0ZVkgPSByb3VuZChzYXZlZFkgKyB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdKTtcbiAgICBsZXQgcmF0aW9YID0gMTtcbiAgICBsZXQgcmF0aW9ZID0gMTtcbiAgICBsZXQgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oZXZlbnQubW92ZW1lbnRYLCBldmVudC5tb3ZlbWVudFkpO1xuICAgIFtkZWx0YVgsIGRlbHRhWV0gPSBpbnZUcmFuc2YoZGVsdGFYIC8gcGFyZW50V2lkdGgsIGRlbHRhWSAvIHBhcmVudEhlaWdodCk7XG4gICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgIGNvbnN0IG9sZERpYWcgPSBNYXRoLmh5cG90KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICAgIHJhdGlvWCA9IHJhdGlvWSA9IE1hdGgubWF4KE1hdGgubWluKE1hdGguaHlwb3Qob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYLCBvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpIC8gb2xkRGlhZywgMSAvIHNhdmVkV2lkdGgsIDEgLyBzYXZlZEhlaWdodCksIG1pbldpZHRoIC8gc2F2ZWRXaWR0aCwgbWluSGVpZ2h0IC8gc2F2ZWRIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICByYXRpb1ggPSBNYXRoLm1heChtaW5XaWR0aCwgTWF0aC5taW4oMSwgTWF0aC5hYnMob3Bwb3NpdGVQb2ludFswXSAtIHBvaW50WzBdIC0gZGVsdGFYKSkpIC8gc2F2ZWRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF0aW9ZID0gTWF0aC5tYXgobWluSGVpZ2h0LCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpKSkgLyBzYXZlZEhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbmV3V2lkdGggPSByb3VuZChzYXZlZFdpZHRoICogcmF0aW9YKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSByb3VuZChzYXZlZEhlaWdodCAqIHJhdGlvWSk7XG4gICAgdHJhbnNmT3Bwb3NpdGVQb2ludCA9IHRyYW5zZiguLi5nZXRPcHBvc2l0ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KSk7XG4gICAgY29uc3QgbmV3WCA9IG9wcG9zaXRlWCAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF07XG4gICAgY29uc3QgbmV3WSA9IG9wcG9zaXRlWSAtIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYWx0VGV4dC5jbGFzc05hbWUgPSBcImFsdFRleHRcIjtcbiAgICBjb25zdCBtc2cgPSBhd2FpdCBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfYWx0X3RleHRfYnV0dG9uX2xhYmVsXCIpO1xuICAgIGFsdFRleHQudGV4dENvbnRlbnQgPSBtc2c7XG4gICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZyk7XG4gICAgYWx0VGV4dC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnUpO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGV2ZW50ID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMpO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGFsdFRleHQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVkaXRBbHRUZXh0KHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFsdFRleHRCdXR0b25TdGF0ZSgpO1xuICAgIHRoaXMuZGl2LmFwcGVuZChhbHRUZXh0KTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUpIHtcbiAgICAgIGNvbnN0IFBFUkNFTlQgPSA0MDtcbiAgICAgIEFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUgPSBNYXRoLm1pbigxMjgsIE1hdGgucm91bmQoYWx0VGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAqICgxICsgUEVSQ0VOVCAvIDEwMCkpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI3NldEFsdFRleHRCdXR0b25TdGF0ZSgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNhbHRUZXh0QnV0dG9uO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dERlY29yYXRpdmUpIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiZG9uZVwiKTtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2FsdF90ZXh0X2VkaXRfYnV0dG9uX2xhYmVsXCIpLnRoZW4obXNnID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZyk7XG4gICAgfSk7XG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLiNhbHRUZXh0VG9vbHRpcDtcbiAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICBjb25zdCBpZCA9IHRvb2x0aXAuaWQgPSBgYWx0LXRleHQtdG9vbHRpcC0ke3RoaXMuaWR9YDtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGlkKTtcbiAgICAgIGNvbnN0IERFTEFZX1RPX1NIT1dfVE9PTFRJUCA9IDEwMDtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAuY2xhc3NMaXN0LmFkZChcInNob3dcIik7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICAgICAgICBzdWJ0eXBlOiB0aGlzLmVkaXRvclR5cGUsXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiYWx0X3RleHRfdG9vbHRpcFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgREVMQVlfVE9fU0hPV19UT09MVElQKTtcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChcImRvbmVcIik7XG4gICAgdG9vbHRpcC5pbm5lclRleHQgPSB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSA/IGF3YWl0IEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9hbHRfdGV4dF9kZWNvcmF0aXZlX3Rvb2x0aXBcIikgOiB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghdG9vbHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICBidXR0b24uYXBwZW5kKHRvb2x0aXApO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgYWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFsdFRleHQ6IHRoaXMuI2FsdFRleHQsXG4gICAgICBkZWNvcmF0aXZlOiB0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZVxuICAgIH07XG4gIH1cbiAgc2V0IGFsdFRleHREYXRhKHtcbiAgICBhbHRUZXh0LFxuICAgIGRlY29yYXRpdmVcbiAgfSkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0ID09PSBhbHRUZXh0ICYmIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID09PSBkZWNvcmF0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICAgIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID0gZGVjb3JhdGl2ZTtcbiAgICB0aGlzLiNzZXRBbHRUZXh0QnV0dG9uU3RhdGUoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5uYW1lO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuaWQpO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIDApO1xuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jYm91bmRGb2N1c2luKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jYm91bmRGb2N1c291dCk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICh0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwICE9PSAwKSB7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5tYXhXaWR0aCA9IGAkeygxMDAgKiBwYXJlbnRIZWlnaHQgLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heEhlaWdodCA9IGAkeygxMDAgKiBwYXJlbnRXaWR0aCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgIHRoaXMudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgKDAsIF90b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLmRpdiwgW1wicG9pbnRlcmRvd25cIl0pO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSB0cnVlO1xuICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICB9XG4gICNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9pc0RyYWdnYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGhpcy5fdWlNYW5hZ2VyLmlzU2VsZWN0ZWQodGhpcyk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFVwRHJhZ1Nlc3Npb24oKTtcbiAgICBsZXQgcG9pbnRlck1vdmVPcHRpb25zLCBwb2ludGVyTW92ZUNhbGxiYWNrO1xuICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICBwb2ludGVyTW92ZU9wdGlvbnMgPSB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH07XG4gICAgICBwb2ludGVyTW92ZUNhbGxiYWNrID0gZSA9PiB7XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihlLm1vdmVtZW50WCwgZS5tb3ZlbWVudFkpO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgcG9pbnRlck1vdmVDYWxsYmFjaywgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBwb2ludGVyTW92ZUNhbGxiYWNrLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlzTWFjXG4gICAgICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgIWlzTWFjIHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgJiYgaXNNYWMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC50b2dnbGVTZWxlY3RlZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gIH1cbiAgbW92ZUluRE9NKCkge1xuICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBzaGlmdFggPSB0eCAvIHNjYWxlO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHR5IC8gc2NhbGU7XG4gICAgY29uc3QgeCA9IHRoaXMueCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge31cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gdHJ1ZTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIH1cbiAgaXNJbkVkaXRNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0luRWRpdE1vZGU7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuZGl2Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jYm91bmRGb2N1c291dCk7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXJcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jYm91bmRGb2N1c2luKTtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jYm91bmRGb2N1c291dCk7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge31cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHRCdXR0b24pIHtcbiAgICAgIHRoaXMuI2FsdFRleHRCdXR0b24uaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge31cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIGdldCBpc0VkaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRWRpdGluZztcbiAgfVxuICBzZXQgaXNFZGl0aW5nKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNFZGl0aW5nID0gdmFsdWU7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLiNrZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgc3R5bGUuYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcbiAgICBzdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgfVxuICBzdGF0aWMgZ2V0IE1JTl9TSVpFKCkge1xuICAgIHJldHVybiAxNjtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yID0gQW5ub3RhdGlvbkVkaXRvcjtcbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4XG4gICAgfTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuS2V5Ym9hcmRNYW5hZ2VyID0gZXhwb3J0cy5Db21tYW5kTWFuYWdlciA9IGV4cG9ydHMuQ29sb3JNYW5hZ2VyID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gdm9pZCAwO1xuZXhwb3J0cy5iaW5kRXZlbnRzID0gYmluZEV2ZW50cztcbmV4cG9ydHMub3BhY2l0eVRvSGV4ID0gb3BhY2l0eVRvSGV4O1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5mdW5jdGlvbiBiaW5kRXZlbnRzKG9iaiwgZWxlbWVudCwgbmFtZXMpIHtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIG9ialtuYW1lXS5iaW5kKG9iaikpO1xuICB9XG59XG5mdW5jdGlvbiBvcGFjaXR5VG9IZXgob3BhY2l0eSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1pbigyNTUsIE1hdGgubWF4KDEsIDI1NSAqIG9wYWNpdHkpKSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmNsYXNzIElkTWFuYWdlciB7XG4gICNpZCA9IDA7XG4gIGdldElkKCkge1xuICAgIHJldHVybiBgJHtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gKDAsIF91dGlsLmdldFV1aWQpKCk7XG4gICNpZCA9IDA7XG4gICNjYWNoZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2lzU1ZHRml0dGluZ0NhbnZhcygpIHtcbiAgICBjb25zdCBzdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsPHN2ZyB2aWV3Qm94PVwiMCAwIDEgMVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHN0eWxlPVwiZmlsbDpyZWQ7XCIvPjwvc3ZnPmA7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAzKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gc3ZnO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEuYnVmZmVyKVswXSA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfaXNTVkdGaXR0aW5nQ2FudmFzXCIsIHByb21pc2UpO1xuICB9XG4gIGFzeW5jICNnZXQoa2V5LCByYXdEYXRhKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgfHw9IHtcbiAgICAgICAgYml0bWFwOiBudWxsLFxuICAgICAgICBpZDogYGltYWdlXyR7dGhpcy4jYmFzZUlkfV8ke3RoaXMuI2lkKyt9YCxcbiAgICAgICAgcmVmQ291bnRlcjogMCxcbiAgICAgICAgaXNTdmc6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbGV0IGltYWdlO1xuICAgICAgaWYgKHR5cGVvZiByYXdEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEudXJsID0gcmF3RGF0YTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyYXdEYXRhKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZSA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS50eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICBjb25zdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlID0gSW1hZ2VNYW5hZ2VyLl9pc1NWR0ZpdHRpbmdDYW52YXM7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmJpdG1hcCA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuaXNTdmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBkYXRhLnN2Z1VybCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IChhd2FpdCBtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlKSA/IGAke3VybH0jc3ZnVmlldyhwcmVzZXJ2ZUFzcGVjdFJhdGlvKG5vbmUpKWAgOiB1cmw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IGZpbGVSZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZSk7XG4gICAgICAgIGF3YWl0IGltYWdlUHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuYml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UpO1xuICAgICAgfVxuICAgICAgZGF0YS5yZWZDb3VudGVyID0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIGRhdGEpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGFzeW5jIGdldEZyb21GaWxlKGZpbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0TW9kaWZpZWQsXG4gICAgICBuYW1lLFxuICAgICAgc2l6ZSxcbiAgICAgIHR5cGVcbiAgICB9ID0gZmlsZTtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KGAke2xhc3RNb2RpZmllZH1fJHtuYW1lfV8ke3NpemV9XyR7dHlwZX1gLCBmaWxlKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLiNnZXQodXJsLCB1cmwpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIG11c3RFeGVjLFxuICAgIHR5cGUgPSBOYU4sXG4gICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgIGtlZXBVbmRvID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZSA9IHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLmNtZCgpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWFuZHMgPSBudWxsO1xuICB9XG59XG5leHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gQ29tbWFuZE1hbmFnZXI7XG5jbGFzcyBLZXlib2FyZE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWxsS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncykoKTtcbiAgICBpZiAoIWJ1YmJsZXMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuS2V5Ym9hcmRNYW5hZ2VyID0gS2V5Ym9hcmRNYW5hZ2VyO1xuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q29sb3JWYWx1ZXMpKGNvbG9ycyk7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0UkdCKShjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBDb2xvck1hbmFnZXI7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIHtcbiAgI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICNhbGxFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjYWxsTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2N1cnJlbnRQYWdlSW5kZXggPSAwO1xuICAjZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICNlZGl0b3JUeXBlcyA9IG51bGw7XG4gICNlZGl0b3JzVG9SZXNjYWxlID0gbmV3IFNldCgpO1xuICAjZmlsdGVyRmFjdG9yeSA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbW9kZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gICNwYWdlQ29sb3JzID0gbnVsbDtcbiAgI2JvdW5kQmx1ciA9IHRoaXMuYmx1ci5iaW5kKHRoaXMpO1xuICAjYm91bmRGb2N1cyA9IHRoaXMuZm9jdXMuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ29weSA9IHRoaXMuY29weS5iaW5kKHRoaXMpO1xuICAjYm91bmRDdXQgPSB0aGlzLmN1dC5iaW5kKHRoaXMpO1xuICAjYm91bmRQYXN0ZSA9IHRoaXMucGFzdGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kS2V5ZG93biA9IHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRPbkVkaXRpbmdBY3Rpb24gPSB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpO1xuICAjYm91bmRPblBhZ2VDaGFuZ2luZyA9IHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI2JvdW5kT25TY2FsZUNoYW5naW5nID0gdGhpcy5vblNjYWxlQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nID0gdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI3ByZXZpb3VzU3RhdGVzID0ge1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgaXNFbXB0eTogdHJ1ZSxcbiAgICBoYXNTb21ldGhpbmdUb1VuZG86IGZhbHNlLFxuICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBkb2N1bWVudDtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50ICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiBzZWxmLmhhc1NvbWV0aGluZ1RvQ29udHJvbCgpO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsXSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIHByb3RvLnVuZG9dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG9dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGVdLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgYWx0VGV4dE1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIgPSBhbHRUZXh0TWFuYWdlcjtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy4jYm91bmRPbkVkaXRpbmdBY3Rpb24pO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInBhZ2VjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUGFnZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25TY2FsZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nKTtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuI2ZpbHRlckZhY3RvcnkgPSBwZGZEb2N1bWVudC5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuI3BhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMgPSB7XG4gICAgICByZWFsU2NhbGU6IF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25TY2FsZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUm90YXRpb25DaGFuZ2luZyk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IGhjbUZpbHRlcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IpIHtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZWRpdEFsdFRleHQodGhpcywgZWRpdG9yKTtcbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25Sb3RhdGlvbkNoYW5naW5nKHtcbiAgICBwYWdlc1JvdGF0aW9uXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yb3RhdGlvbiA9IHBhZ2VzUm90YXRpb247XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0VtcHR5KCkgJiYgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgJiYgIXRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZShlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgfVxuICB9XG4gICNhZGRGb2N1c01hbmFnZXIoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEZvY3VzKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRCbHVyKTtcbiAgfVxuICAjcmVtb3ZlRm9jdXNNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRGb2N1cyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kQmx1cik7XG4gIH1cbiAgYmx1cigpIHtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IFtlZGl0b3IsIGFjdGl2ZUVsZW1lbnRdO1xuICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbbGFzdEVkaXRvciwgbGFzdEFjdGl2ZUVsZW1lbnRdID0gdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgIGxhc3RFZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgI2FkZEtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlkb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlkb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLiNib3VuZENvcHkpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy4jYm91bmRDdXQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLiNib3VuZFBhc3RlKTtcbiAgfVxuICAjcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuI2JvdW5kQ29weSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLiNib3VuZEN1dCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuI2JvdW5kUGFzdGUpO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICBjb3B5KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gZWRpdG9yLnNlcmlhbGl6ZSh0cnVlKTtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChzZXJpYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIsIEpTT04uc3RyaW5naWZ5KGVkaXRvcnMpKTtcbiAgfVxuICBjdXQoZXZlbnQpIHtcbiAgICB0aGlzLmNvcHkoZXZlbnQpO1xuICAgIHRoaXMuZGVsZXRlKCk7XG4gIH1cbiAgcGFzdGUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaXBib2FyZERhdGFcbiAgICB9ID0gZXZlbnQ7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNsaXBib2FyZERhdGEuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRWRpdG9yID0gbGF5ZXIuZGVzZXJpYWxpemUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRpdG9ycy5wdXNoKGRlc2VyaWFsaXplZEVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc2VsZWN0RWRpdG9ycyhuZXdFZGl0b3JzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZCxcbiAgICAgICAgdW5kbyxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5nZXRBY3RpdmUoKT8uc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBvbkVkaXRpbmdBY3Rpb24oZGV0YWlscykge1xuICAgIGlmIChbXCJ1bmRvXCIsIFwicmVkb1wiLCBcImRlbGV0ZVwiLCBcInNlbGVjdEFsbFwiXS5pbmNsdWRlcyhkZXRhaWxzLm5hbWUpKSB7XG4gICAgICB0aGlzW2RldGFpbHMubmFtZV0oKTtcbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKGRldGFpbHMpIHtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gT2JqZWN0LmVudHJpZXMoZGV0YWlscykuc29tZSgoW2tleSwgdmFsdWVdKSA9PiB0aGlzLiNwcmV2aW91c1N0YXRlc1trZXldICE9PSB2YWx1ZSk7XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnN0YXRlc2NoYW5nZWRcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGRldGFpbHM6IE9iamVjdC5hc3NpZ24odGhpcy4jcHJldmlvdXNTdGF0ZXMsIGRldGFpbHMpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogdGhpcy4jbW9kZSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSxcbiAgICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRWRpdG9yVHlwZXModHlwZXMpIHtcbiAgICBpZiAodGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yVHlwZXMgPSB0eXBlcztcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgaWYgKG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIHRoaXMuI2Rpc2FibGVBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgdGhpcy4jZW5hYmxlQWxsKCk7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIH1cbiAgICBpZiAoIWVkaXRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIGlmIChtb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURSkge1xuICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JzO1xuICB9XG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cbiAgYWRkRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgfVxuICByZW1vdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLnVuc2VsZWN0KGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZT8ucmVtb3ZlKGVkaXRvci5pZCk7XG4gICAgfVxuICB9XG4gIGFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gICNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChlZGl0b3IucGFnZUluZGV4KTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIucmVkbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5hZGQocGFyYW1zKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9Db250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgfHwgdGhpcy5oYXNTZWxlY3Rpb247XG4gIH1cbiAgI3NlbGVjdEVkaXRvcnMoZWRpdG9ycykge1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNlbGVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci5jb21taXQoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0RWRpdG9ycyh0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKTtcbiAgfVxuICB1bnNlbGVjdEFsbCgpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yKSB7XG4gICAgICB0aGlzLiNhY3RpdmVFZGl0b3IuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgbm9Db21taXQgPSBmYWxzZSkge1xuICAgIGlmICghbm9Db21taXQpIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblswXSArPSB4O1xuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzFdICs9IHk7XG4gICAgY29uc3QgW3RvdGFsWCwgdG90YWxZXSA9IHRoaXMuI3RyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAxMDAwO1xuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdID0gdGhpcy4jdHJhbnNsYXRpb25bMV0gPSAwO1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UodG90YWxYLCB0b3RhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoLXRvdGFsWCwgLXRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh4LCB5KTtcbiAgICB9XG4gIH1cbiAgc2V0VXBEcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLnNldChlZGl0b3IsIHtcbiAgICAgICAgc2F2ZWRYOiBlZGl0b3IueCxcbiAgICAgICAgc2F2ZWRZOiBlZGl0b3IueSxcbiAgICAgICAgc2F2ZWRQYWdlSW5kZXg6IGVkaXRvci5wYWdlSW5kZXgsXG4gICAgICAgIG5ld1g6IDAsXG4gICAgICAgIG5ld1k6IDAsXG4gICAgICAgIG5ld1BhZ2VJbmRleDogLTFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlbmREcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLiNkcmFnZ2luZ0VkaXRvcnM7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgICBsZXQgbXVzdEJlQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW3tcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSwgdmFsdWVdIG9mIG1hcCkge1xuICAgICAgdmFsdWUubmV3WCA9IHg7XG4gICAgICB2YWx1ZS5uZXdZID0geTtcbiAgICAgIHZhbHVlLm5ld1BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgIG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgfHw9IHggIT09IHZhbHVlLnNhdmVkWCB8fCB5ICE9PSB2YWx1ZS5zYXZlZFkgfHwgcGFnZUluZGV4ICE9PSB2YWx1ZS5zYXZlZFBhZ2VJbmRleDtcbiAgICB9XG4gICAgaWYgKCFtdXN0QmVBZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vdmUgPSAoZWRpdG9yLCB4LCB5LCBwYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGVkaXRvci5fc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgIGVkaXRvci54ID0geDtcbiAgICAgICAgICBlZGl0b3IueSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIG5ld1gsXG4gICAgICAgICAgbmV3WSxcbiAgICAgICAgICBuZXdQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIG5ld1gsIG5ld1ksIG5ld1BhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIHNhdmVkWCxcbiAgICAgICAgICBzYXZlZFksXG4gICAgICAgICAgc2F2ZWRQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFBhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLmtleXMoKSkge1xuICAgICAgZWRpdG9yLmRyYWcodHgsIHR5KTtcbiAgICB9XG4gIH1cbiAgcmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXllcihlZGl0b3IucGFnZUluZGV4KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgICAgICBwYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpbWFnZU1hbmFnZXJcIiwgbmV3IEltYWdlTWFuYWdlcigpKTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YXRUaW1lciA9IGV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gZXhwb3J0cy5QaXhlbHNQZXJJbmNoID0gZXhwb3J0cy5QYWdlVmlld3BvcnQgPSBleHBvcnRzLlBERkRhdGVTdHJpbmcgPSBleHBvcnRzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5ET01TVkdGYWN0b3J5ID0gZXhwb3J0cy5ET01GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbmV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG5leHBvcnRzLmdldENvbG9yVmFsdWVzID0gZ2V0Q29sb3JWYWx1ZXM7XG5leHBvcnRzLmdldEN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtO1xuZXhwb3J0cy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSA9IGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlO1xuZXhwb3J0cy5nZXRGaWxlbmFtZUZyb21VcmwgPSBnZXRGaWxlbmFtZUZyb21Vcmw7XG5leHBvcnRzLmdldFBkZkZpbGVuYW1lRnJvbVVybCA9IGdldFBkZkZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuZ2V0UkdCID0gZ2V0UkdCO1xuZXhwb3J0cy5nZXRYZmFQYWdlVmlld3BvcnQgPSBnZXRYZmFQYWdlVmlld3BvcnQ7XG5leHBvcnRzLmlzRGF0YVNjaGVtZSA9IGlzRGF0YVNjaGVtZTtcbmV4cG9ydHMuaXNQZGZGaWxlID0gaXNQZGZGaWxlO1xuZXhwb3J0cy5pc1ZhbGlkRmV0Y2hVcmwgPSBpc1ZhbGlkRmV0Y2hVcmw7XG5leHBvcnRzLmxvYWRTY3JpcHQgPSBsb2FkU2NyaXB0O1xuZXhwb3J0cy5ub0NvbnRleHRNZW51ID0gbm9Db250ZXh0TWVudTtcbmV4cG9ydHMuc2V0TGF5ZXJEaW1lbnNpb25zID0gc2V0TGF5ZXJEaW1lbnNpb25zO1xudmFyIF9iYXNlX2ZhY3RvcnkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmV4cG9ydHMuUGl4ZWxzUGVySW5jaCA9IFBpeGVsc1BlckluY2g7XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlRmlsdGVyRmFjdG9yeSB7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNoY21GaWx0ZXI7XG4gICNoY21LZXk7XG4gICNoY21Vcmw7XG4gICNoY21IaWdobGlnaHRGaWx0ZXI7XG4gICNoY21IaWdobGlnaHRLZXk7XG4gICNoY21IaWdobGlnaHRVcmw7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgaWYgKCFtYXBzKSB7XG4gICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXBzKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGtleTtcbiAgICBpZiAobWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1hcFIgPSBtYXBzWzBdO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBrZXkgPSB0YWJsZVIgPSB0YWJsZUcgPSB0YWJsZUIgPSBidWZmZXIuam9pbihcIixcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBidWZmZXJHID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlclJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICB0YWJsZVIgPSBidWZmZXJSLmpvaW4oXCIsXCIpO1xuICAgICAgdGFibGVHID0gYnVmZmVyRy5qb2luKFwiLFwiKTtcbiAgICAgIHRhYmxlQiA9IGJ1ZmZlckIuam9pbihcIixcIik7XG4gICAgICBrZXkgPSBgJHt0YWJsZVJ9JHt0YWJsZUd9JHt0YWJsZUJ9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fdHJhbnNmZXJfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoIyR7aWR9KWA7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9YDtcbiAgICBpZiAodGhpcy4jaGNtS2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIHRoaXMuI2hjbUtleSA9IGtleTtcbiAgICB0aGlzLiNoY21VcmwgPSBcIm5vbmVcIjtcbiAgICB0aGlzLiNoY21GaWx0ZXI/LnJlbW92ZSgpO1xuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgY29uc3QgZmdSR0IgPSB0aGlzLiNnZXRSR0IoZmdDb2xvcik7XG4gICAgZmdDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmZnUkdCKTtcbiAgICBjb25zdCBiZ1JHQiA9IHRoaXMuI2dldFJHQihiZ0NvbG9yKTtcbiAgICBiZ0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmdSR0IpO1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGlmIChmZ0NvbG9yID09PSBcIiMwMDAwMDBcIiAmJiBiZ0NvbG9yID09PSBcIiNmZmZmZmZcIiB8fCBmZ0NvbG9yID09PSBiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlLCB0YWJsZSwgdGFibGUsIGZpbHRlcik7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChjLCBuKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IGZnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgZW5kID0gYmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHN0YXJ0ICsgaSAvIG4gKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcygwLCA1KSwgZ2V0U3RlcHMoMSwgNSksIGdldFN0ZXBzKDIsIDUpLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2hjbVVybCA9IGB1cmwoIyR7aWR9KWA7XG4gICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn0tJHtuZXdGZ0NvbG9yfS0ke25ld0JnQ29sb3J9YDtcbiAgICBpZiAodGhpcy4jaGNtSGlnaGxpZ2h0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gICAgfVxuICAgIHRoaXMuI2hjbUhpZ2hsaWdodEtleSA9IGtleTtcbiAgICB0aGlzLiNoY21IaWdobGlnaHRVcmwgPSBcIm5vbmVcIjtcbiAgICB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXI/LnJlbW92ZSgpO1xuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbUhpZ2hsaWdodFVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21faGlnaGxpZ2h0X2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2hjbUhpZ2hsaWdodFVybCA9IGB1cmwoIyR7aWR9KWA7XG4gICAgcmV0dXJuIHRoaXMuI2hjbUhpZ2hsaWdodFVybDtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge1xuICAgIGlmIChrZWVwSENNICYmICh0aGlzLiNoY21VcmwgfHwgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jX2RlZnMpIHtcbiAgICAgIHRoaXMuI19kZWZzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI19kZWZzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI19jYWNoZSkge1xuICAgICAgdGhpcy4jX2NhY2hlLmNsZWFyKCk7XG4gICAgICB0aGlzLiNfY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNpZCA9IDA7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjZ2V0UkdCKGNvbG9yKSB7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgIHJldHVybiBnZXRSR0IoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNkZWZzKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIikpO1xuICB9XG59XG5leHBvcnRzLkRPTUZpbHRlckZhY3RvcnkgPSBET01GaWx0ZXJGYWN0b3J5O1xuY2xhc3MgRE9NQ2FudmFzRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cbn1cbmV4cG9ydHMuRE9NQ2FudmFzRmFjdG9yeSA9IERPTUNhbnZhc0ZhY3Rvcnk7XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCBhc1R5cGVkQXJyYXkgPSBmYWxzZSkge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICByZXR1cm4gYXNUeXBlZEFycmF5ID8gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkgOiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICBpZiAoYXNUeXBlZEFycmF5KSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB9XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAoYXNUeXBlZEFycmF5ICYmIHJlcXVlc3QucmVzcG9uc2UpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFzVHlwZWRBcnJheSAmJiByZXF1ZXN0LnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIGRhdGEgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgfTtcbiAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gIH0pO1xufVxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCwgdHJ1ZSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG59XG5leHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBET01TVkdGYWN0b3J5O1xuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiArPSAzNjA7XG4gICAgfVxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldCByYXdEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdCb3hcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogdmlld0JveFsyXSAtIHZpZXdCb3hbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSxcbiAgICAgIHBhZ2VYOiB2aWV3Qm94WzBdLFxuICAgICAgcGFnZVk6IHZpZXdCb3hbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxufVxuZXhwb3J0cy5QYWdlVmlld3BvcnQgPSBQYWdlVmlld3BvcnQ7XG5jbGFzcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gZXh0ZW5kcyBfdXRpbC5CYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHN1cGVyKG1zZywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5leHRyYURlbGF5ID0gZXh0cmFEZWxheTtcbiAgfVxufVxuZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG5mdW5jdGlvbiBpc0RhdGFTY2hlbWUodXJsKSB7XG4gIGNvbnN0IGlpID0gdXJsLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlpICYmIHVybFtpXS50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cbmZ1bmN0aW9uIGlzUGRmRmlsZShmaWxlbmFtZSkge1xuICByZXR1cm4gdHlwZW9mIGZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsLCBvbmx5U3RyaXBQYXRoID0gZmFsc2UpIHtcbiAgaWYgKCFvbmx5U3RyaXBQYXRoKSB7XG4gICAgW3VybF0gPSB1cmwuc3BsaXQoL1sjP10vLCAxKTtcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG59XG5mdW5jdGlvbiBnZXRQZGZGaWxlbmFtZUZyb21VcmwodXJsLCBkZWZhdWx0RmlsZW5hbWUgPSBcImRvY3VtZW50LnBkZlwiKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAoMCwgX3V0aWwud2FybikoJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCByZVVSSSA9IC9eKD86KD86W146XSs6KT9cXC9cXC9bXi9dKyk/KFtePyNdKikoXFw/W14jXSopPygjLiopPyQvO1xuICBjb25zdCByZUZpbGVuYW1lID0gL1teLz8jPV0rXFwucGRmXFxiKD8hLipcXC5wZGZcXGIpL2k7XG4gIGNvbnN0IHNwbGl0VVJJID0gcmVVUkkuZXhlYyh1cmwpO1xuICBsZXQgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMV0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsyXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzNdKTtcbiAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lKSB7XG4gICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSBzdWdnZXN0ZWRGaWxlbmFtZVswXTtcbiAgICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhkZWNvZGVVUklDb21wb25lbnQoc3VnZ2VzdGVkRmlsZW5hbWUpKVswXTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1Z2dlc3RlZEZpbGVuYW1lIHx8IGRlZmF1bHRGaWxlbmFtZTtcbn1cbmNsYXNzIFN0YXRUaW1lciB7XG4gIHN0YXJ0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aW1lcyA9IFtdO1xuICB0aW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMudGltZXMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnRlZFtuYW1lXSxcbiAgICAgIGVuZDogRGF0ZS5ub3coKVxuICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0YXJ0ZWRbbmFtZV07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gW107XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgbG9uZ2VzdCA9IE1hdGgubWF4KG5hbWUubGVuZ3RoLCBsb25nZXN0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIG91dEJ1Zi5wdXNoKGAke25hbWUucGFkRW5kKGxvbmdlc3QpfSAke2VuZCAtIHN0YXJ0fW1zXFxuYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRCdWYuam9pbihcIlwiKTtcbiAgfVxufVxuZXhwb3J0cy5TdGF0VGltZXIgPSBTdGF0VGltZXI7XG5mdW5jdGlvbiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBiYXNlVXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvdG9jb2xcbiAgICB9ID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gcHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBub0NvbnRleHRNZW51KGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdChzcmMsIHJlbW92ZVNjcmlwdEVsZW1lbnQgPSBmYWxzZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKHJlbW92ZVNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShldnQpO1xuICAgIH07XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKGBDYW5ub3QgbG9hZCBzY3JpcHQgYXQ6ICR7c2NyaXB0LnNyY31gKSk7XG4gICAgfTtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZChzY3JpcHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZGV0YWlscykge1xuICBjb25zb2xlLmxvZyhcIkRlcHJlY2F0ZWQgQVBJIHVzYWdlOiBcIiArIGRldGFpbHMpO1xufVxubGV0IHBkZkRhdGVTdHJpbmdSZWdleDtcbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZGZEYXRlU3RyaW5nUmVnZXggfHw9IG5ldyBSZWdFeHAoXCJeRDpcIiArIFwiKFxcXFxkezR9KVwiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoW1p8K3wtXSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIpO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBwZGZEYXRlU3RyaW5nUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IFBERkRhdGVTdHJpbmc7XG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSR0IoY29sb3IpIHtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgY29uc3QgY29sb3JSR0IgPSBwYXJzZUludChjb2xvci5zbGljZSgxKSwgMTYpO1xuICAgIHJldHVybiBbKGNvbG9yUkdCICYgMHhmZjAwMDApID4+IDE2LCAoY29sb3JSR0IgJiAweDAwZmYwMCkgPj4gOCwgY29sb3JSR0IgJiAweDAwMDBmZl07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cbiAgKDAsIF91dGlsLndhcm4pKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmQoc3Bhbik7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBjb2xvcnMua2V5cygpKSB7XG4gICAgc3Bhbi5zdHlsZS5jb2xvciA9IG5hbWU7XG4gICAgY29uc3QgY29tcHV0ZWRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmNvbG9yO1xuICAgIGNvbG9ycy5zZXQobmFtZSwgZ2V0UkdCKGNvbXB1dGVkQ29sb3IpKTtcbiAgfVxuICBzcGFuLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gc2V0TGF5ZXJEaW1lbnNpb25zKGRpdiwgdmlld3BvcnQsIG11c3RGbGlwID0gZmFsc2UsIG11c3RSb3RhdGUgPSB0cnVlKSB7XG4gIGlmICh2aWV3cG9ydCBpbnN0YW5jZW9mIFBhZ2VWaWV3cG9ydCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgY29uc3QgdXNlUm91bmQgPSBfdXRpbC5GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZCgke3d9LCAxcHgpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKCR7aH0sIDFweClgIDogYGNhbGMoJHtofSlgO1xuICAgIGlmICghbXVzdEZsaXAgfHwgdmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgIHN0eWxlLndpZHRoID0gd2lkdGhTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHRTdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gaGVpZ2h0U3RyO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gd2lkdGhTdHI7XG4gICAgfVxuICB9XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCB2aWV3cG9ydC5yb3RhdGlvbik7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuQmFzZVNWR0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNsYXNzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VGaWx0ZXJGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUZpbHRlckZhY3RvcnkuXCIpO1xuICAgIH1cbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge31cbn1cbmV4cG9ydHMuQmFzZUZpbHRlckZhY3RvcnkgPSBCYXNlRmlsdGVyRmFjdG9yeTtcbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDYW52YXNGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUNhbnZhc0ZhY3RvcnkuXCIpO1xuICAgIH1cbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgICB9O1xuICB9XG4gIHJlc2V0KGNhbnZhc0FuZENvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGRlc3Ryb3koY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyA9IG51bGw7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gQmFzZUNhbnZhc0ZhY3Rvcnk7XG5jbGFzcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGwsXG4gICAgaXNDb21wcmVzc2VkID0gdHJ1ZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDTWFwUmVhZGVyRmFjdG9yeS5cIik7XG4gICAgfVxuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBDTWFwIFwiYmFzZVVybFwiIHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZCwgZW5zdXJlIHRoYXQgJyArICd0aGUgXCJjTWFwVXJsXCIgYW5kIFwiY01hcFBhY2tlZFwiIEFQSSBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIGNvbnN0IGNvbXByZXNzaW9uVHlwZSA9IHRoaXMuaXNDb21wcmVzc2VkID8gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZS5CSU5BUlkgOiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLk5PTkU7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgJHt0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIn1DTWFwIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSBCYXNlQ01hcFJlYWRlckZhY3Rvcnk7XG5jbGFzcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGxcbiAgfSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YW5kYXJkIGZvbnQgXCJiYXNlVXJsXCIgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCAnICsgJ3RoZSBcInN0YW5kYXJkRm9udERhdGFVcmxcIiBBUEkgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgZm9udCBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaERhdGFgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVNWR0ZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlU1ZHRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBza2lwRGltZW5zaW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGRpbWVuc2lvbnNcIik7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX2NyZWF0ZVNWRyhcInN2ZzpzdmdcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XG4gICAgaWYgKCFza2lwRGltZW5zaW9ucykge1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGAke3dpZHRofXB4YCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke2hlaWdodH1weGApO1xuICAgIH1cbiAgICBzdmcuc2V0QXR0cmlidXRlKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gIGNyZWF0ZUVsZW1lbnQodHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZWxlbWVudCB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlU1ZHKHR5cGUpO1xuICB9XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZVNWR0ZhY3RvcnkgPSBCYXNlU1ZHRmFjdG9yeTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk11cm11ckhhc2gzXzY0ID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuY2xhc3MgTXVybXVySGFzaDNfNjQge1xuICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgdGhpcy5oMSA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gICAgdGhpcy5oMiA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gIH1cbiAgdXBkYXRlKGlucHV0KSB7XG4gICAgbGV0IGRhdGEsIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZikge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgPj4+IDg7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGRhdGEgZm9ybWF0IGluIE11cm11ckhhc2gzXzY0X3VwZGF0ZS4gXCIgKyBcIklucHV0IG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5leHBvcnRzLk11cm11ckhhc2gzXzY0ID0gTXVybXVySGFzaDNfNjQ7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Gb250TG9hZGVyID0gZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoaW5mbykge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5kaXNhYmxlRm9udEZhY2UsIFwibG9hZFN5c3RlbUZvbnQgc2hvdWxkbid0IGJlIGNhbGxlZCB3aGVuIGBkaXNhYmxlRm9udEZhY2VgIGlzIHNldC5cIik7XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsb2FkZWROYW1lLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gaW5mbztcbiAgICAgIGNvbnN0IGZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKGxvYWRlZE5hbWUsIHNyYywgc3R5bGUpO1xuICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmb250RmFjZS5sb2FkKCk7XG4gICAgICAgIHRoaXMuI3N5c3RlbUZvbnRzLmFkZChsb2FkZWROYW1lKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYENhbm5vdCBsb2FkIHN5c3RlbSBmb250OiAke2luZm8uYmFzZUZvbnROYW1lfSwgaW5zdGFsbGluZyBpdCBjb3VsZCBoZWxwIHRvIGltcHJvdmUgUERGIHJlbmRlcmluZy5gKTtcbiAgICAgICAgdGhpcy5yZW1vdmVOYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJOb3QgaW1wbGVtZW50ZWQ6IGxvYWRTeXN0ZW1Gb250IHdpdGhvdXQgdGhlIEZvbnQgTG9hZGluZyBBUEkuXCIpO1xuICB9XG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUgJiYgIWZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG4gICAgaWYgKGZvbnQuc3lzdGVtRm9udEluZm8pIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZFN5c3RlbUZvbnQoZm9udC5zeXN0ZW1Gb250SW5mbyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG5hdGl2ZUZvbnRGYWNlLmxvYWRlZDtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKHJlc29sdmUpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBoYXNGb250cyA9ICEhdGhpcy5fZG9jdW1lbnQ/LmZvbnRzO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWRcIiwgaGFzRm9udHMpO1xuICB9XG4gIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgaWYgKF91dGlsLmlzTm9kZUpTKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTW96aWxsYVxcLzUuMC4qP3J2OlxcZCsuKj8gR2Vja28vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsIHN1cHBvcnRlZCk7XG4gIH1cbiAgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfbG9hZFRlc3RGb250XCIsIHRlc3RGb250KTtcbiAgfVxuICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQoZm9udCwgcmVxdWVzdCkge1xuICAgIGZ1bmN0aW9uIGludDMyKGRhdGEsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpY2VTdHJpbmcocywgb2Zmc2V0LCByZW1vdmUsIGluc2VydCkge1xuICAgICAgY29uc3QgY2h1bmsxID0gcy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGNodW5rMiA9IHMuc3Vic3RyaW5nKG9mZnNldCArIHJlbW92ZSk7XG4gICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgIH1cbiAgICBsZXQgaSwgaWk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgbGV0IGNhbGxlZCA9IDA7XG4gICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICgrK2NhbGxlZCA+IDMwKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIkxvYWQgdGVzdCBmb250IG5ldmVyIGxvYWRlZC5cIik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgIGlmIChpbWFnZURhdGEuZGF0YVszXSA+IDApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgbGV0IGRhdGEgPSB0aGlzLl9sb2FkVGVzdEZvbnQ7XG4gICAgY29uc3QgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgY29uc3QgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgIGNvbnN0IFhYWFhfVkFMVUUgPSAweDU4NTg1ODU4O1xuICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICB9XG4gICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgfVxuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCwgNCwgKDAsIF91dGlsLnN0cmluZzMyKShjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xuY2xhc3MgRm9udEZhY2VPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGVkRGF0YSwge1xuICAgIGlzRXZhbFN1cHBvcnRlZCA9IHRydWUsXG4gICAgZGlzYWJsZUZvbnRGYWNlID0gZmFsc2UsXG4gICAgaWdub3JlRXJyb3JzID0gZmFsc2UsXG4gICAgaW5zcGVjdEZvbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNvbXBpbGVkR2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNsYXRlZERhdGEpIHtcbiAgICAgIHRoaXNbaV0gPSB0cmFuc2xhdGVkRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5pc0V2YWxTdXBwb3J0ZWQgPSBpc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzID09PSB0cnVlO1xuICAgIHRoaXMuX2luc3BlY3RGb250ID0gaW5zcGVjdEZvbnQ7XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9ICgwLCBfdXRpbC5ieXRlc1RvU3RyaW5nKSh0aGlzLmRhdGEpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoIXRoaXMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0V2YWxTdXBwb3J0ZWQgJiYgX3V0aWwuRmVhdHVyZVRlc3QuaXNFdmFsU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBqc0J1ZiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50IG9mIGNtZHMpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGN1cnJlbnQuYXJncyAhPT0gdW5kZWZpbmVkID8gY3VycmVudC5hcmdzLmpvaW4oXCIsXCIpIDogXCJcIjtcbiAgICAgICAganNCdWYucHVzaChcImMuXCIsIGN1cnJlbnQuY21kLCBcIihcIiwgYXJncywgXCIpO1xcblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqc0J1Zi5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgY21kcykge1xuICAgICAgICBpZiAoY3VycmVudC5jbWQgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgIGN1cnJlbnQuYXJncyA9IFtzaXplLCAtc2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgY1tjdXJyZW50LmNtZF0uYXBwbHkoYywgY3VycmVudC5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5leHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gRm9udEZhY2VPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbnZhciBfYmFzZV9mYWN0b3J5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG47XG47XG5jb25zdCBmZXRjaERhdGEgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgZnMucmVhZEZpbGUodXJsLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5jbGFzcyBOb2RlRmlsdGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUZpbHRlckZhY3Rvcnkge31cbmV4cG9ydHMuTm9kZUZpbHRlckZhY3RvcnkgPSBOb2RlRmlsdGVyRmFjdG9yeTtcbmNsYXNzIE5vZGVDYW52YXNGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IENhbnZhcyA9IHJlcXVpcmUoXCJjYW52YXNcIik7XG4gICAgcmV0dXJuIENhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBOb2RlQ2FudmFzRmFjdG9yeTtcbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsKS50aGVuKGRhdGEgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY01hcERhdGE6IGRhdGEsXG4gICAgICAgIGNvbXByZXNzaW9uVHlwZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSBOb2RlQ01hcFJlYWRlckZhY3Rvcnk7XG5jbGFzcyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5leHBvcnRzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9wYXR0ZXJuX2hlbHBlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIF9pbWFnZV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xuY29uc3QgTUlOX0ZPTlRfU0laRSA9IDE2O1xuY29uc3QgTUFYX0ZPTlRfU0laRSA9IDEwMDtcbmNvbnN0IE1BWF9HUk9VUF9TSVpFID0gNDA5NjtcbmNvbnN0IEVYRUNVVElPTl9USU1FID0gMTU7XG5jb25zdCBFWEVDVVRJT05fU1RFUFMgPSAxMDtcbmNvbnN0IE1BWF9TSVpFX1RPX0NPTVBJTEUgPSAxMDAwO1xuY29uc3QgRlVMTF9DSFVOS19IRUlHSFQgPSAxNjtcbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuICBjdHguX19vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXN0b3JlID0gY3R4LnJlc3RvcmU7XG4gIGN0eC5fX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGUgPSBjdHgudHJhbnNsYXRlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSA9IGN0eC5yZXNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxDbGlwID0gY3R4LmNsaXA7XG4gIGN0eC5fX29yaWdpbmFsTW92ZVRvID0gY3R4Lm1vdmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxMaW5lVG8gPSBjdHgubGluZVRvO1xuICBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG8gPSBjdHguYmV6aWVyQ3VydmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxSZWN0ID0gY3R4LnJlY3Q7XG4gIGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcbiAgY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGggPSBjdHguYmVnaW5QYXRoO1xuICBjdHguX3JlbW92ZU1pcnJvcmluZyA9ICgpID0+IHtcbiAgICBjdHguc2F2ZSA9IGN0eC5fX29yaWdpbmFsU2F2ZTtcbiAgICBjdHgucmVzdG9yZSA9IGN0eC5fX29yaWdpbmFsUmVzdG9yZTtcbiAgICBjdHgucm90YXRlID0gY3R4Ll9fb3JpZ2luYWxSb3RhdGU7XG4gICAgY3R4LnNjYWxlID0gY3R4Ll9fb3JpZ2luYWxTY2FsZTtcbiAgICBjdHgudHJhbnNsYXRlID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGU7XG4gICAgY3R4LnRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtO1xuICAgIGN0eC5jbGlwID0gY3R4Ll9fb3JpZ2luYWxDbGlwO1xuICAgIGN0eC5tb3ZlVG8gPSBjdHguX19vcmlnaW5hbE1vdmVUbztcbiAgICBjdHgubGluZVRvID0gY3R4Ll9fb3JpZ2luYWxMaW5lVG87XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG87XG4gICAgY3R4LnJlY3QgPSBjdHguX19vcmlnaW5hbFJlY3Q7XG4gICAgY3R4LmNsb3NlUGF0aCA9IGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoO1xuICAgIGN0eC5iZWdpblBhdGggPSBjdHguX19vcmlnaW5hbEJlZ2luUGF0aDtcbiAgICBkZWxldGUgY3R4Ll9yZW1vdmVNaXJyb3Jpbmc7XG4gIH07XG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gY3R4U2F2ZSgpIHtcbiAgICBkZXN0Q3R4LnNhdmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTYXZlKCk7XG4gIH07XG4gIGN0eC5yZXN0b3JlID0gZnVuY3Rpb24gY3R4UmVzdG9yZSgpIHtcbiAgICBkZXN0Q3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG4gIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiBjdHhUcmFuc2xhdGUoeCwgeSkge1xuICAgIGRlc3RDdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zbGF0ZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gY3R4U2NhbGUoeCwgeSkge1xuICAgIGRlc3RDdHguc2NhbGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2NhbGUoeCwgeSk7XG4gIH07XG4gIGN0eC50cmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsU2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhSZXNldFRyYW5zZm9ybSgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIGN0eFJvdGF0ZShhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uIGN0eFJvdGF0ZShydWxlKSB7XG4gICAgZGVzdEN0eC5jbGlwKHJ1bGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsaXAocnVsZSk7XG4gIH07XG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1vdmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgZGVzdEN0eC5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gIH07XG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgY3R4LmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmVnaW5QYXRoKCk7XG4gIH07XG59XG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFggKiBhICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WSAqIGQgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WCArIGRlc3RXKSAqIGEgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WSArIGRlc3RIKSAqIGQgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKE1hdGguc2lnbihhKSwgMCwgMCwgTWF0aC5zaWduKGQpLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgcldpZHRoLCBySGVpZ2h0KTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtyV2lkdGgsIHJIZWlnaHRdO1xuICB9XG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cbiAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKTtcbiAgY29uc3Qgc2NhbGVYID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgY29uc3Qgc2NhbGVZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgcmV0dXJuIFtzY2FsZVggKiBkZXN0Vywgc2NhbGVZICogZGVzdEhdO1xufVxuZnVuY3Rpb24gY29tcGlsZVR5cGUzR2x5cGgoaW1nRGF0YSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBpbWdEYXRhO1xuICBpZiAod2lkdGggPiBNQVhfU0laRV9UT19DT01QSUxFIHx8IGhlaWdodCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBQT0lOVF9UT19QUk9DRVNTX0xJTUlUID0gMTAwMDtcbiAgY29uc3QgUE9JTlRfVFlQRVMgPSBuZXcgVWludDhBcnJheShbMCwgMiwgNCwgMCwgMSwgMCwgNSwgNCwgOCwgMTAsIDAsIDgsIDAsIDIsIDEsIDBdKTtcbiAgY29uc3Qgd2lkdGgxID0gd2lkdGggKyAxO1xuICBsZXQgcG9pbnRzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgxICogKGhlaWdodCArIDEpKTtcbiAgbGV0IGksIGosIGowO1xuICBjb25zdCBsaW5lU2l6ZSA9IHdpZHRoICsgNyAmIH43O1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxpbmVTaXplICogaGVpZ2h0KSxcbiAgICBwb3MgPSAwO1xuICBmb3IgKGNvbnN0IGVsZW0gb2YgaW1nRGF0YS5kYXRhKSB7XG4gICAgbGV0IG1hc2sgPSAxMjg7XG4gICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICBkYXRhW3BvcysrXSA9IGVsZW0gJiBtYXNrID8gMCA6IDI1NTtcbiAgICAgIG1hc2sgPj49IDE7XG4gICAgfVxuICB9XG4gIGxldCBjb3VudCA9IDA7XG4gIHBvcyA9IDA7XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbMF0gPSAxO1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbal0gPSBkYXRhW3Bvc10gPyAyIDogMTtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbal0gPSAyO1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChpID0gMTsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgcG9zID0gaSAqIGxpbmVTaXplO1xuICAgIGowID0gaSAqIHdpZHRoMTtcbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owXSA9IGRhdGFbcG9zXSA/IDEgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgbGV0IHN1bSA9IChkYXRhW3Bvc10gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gPyA4IDogMCk7XG4gICAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIHN1bSA9IChzdW0gPj4gMikgKyAoZGF0YVtwb3MgKyAxXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplICsgMV0gPyA4IDogMCk7XG4gICAgICBpZiAoUE9JTlRfVFlQRVNbc3VtXSkge1xuICAgICAgICBwb2ludHNbajAgKyBqXSA9IFBPSU5UX1RZUEVTW3N1bV07XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICB9XG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gMiA6IDQ7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcG9zID0gbGluZVNpemUgKiAoaGVpZ2h0IC0gMSk7XG4gIGowID0gaSAqIHdpZHRoMTtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMF0gPSA4O1xuICAgICsrY291bnQ7XG4gIH1cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDQgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMCArIGpdID0gNDtcbiAgICArK2NvdW50O1xuICB9XG4gIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdGVwcyA9IG5ldyBJbnQzMkFycmF5KFswLCB3aWR0aDEsIC0xLCAwLCAtd2lkdGgxLCAwLCAwLCAwLCAxXSk7XG4gIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gIGZvciAoaSA9IDA7IGNvdW50ICYmIGkgPD0gaGVpZ2h0OyBpKyspIHtcbiAgICBsZXQgcCA9IGkgKiB3aWR0aDE7XG4gICAgY29uc3QgZW5kID0gcCArIHdpZHRoO1xuICAgIHdoaWxlIChwIDwgZW5kICYmICFwb2ludHNbcF0pIHtcbiAgICAgIHArKztcbiAgICB9XG4gICAgaWYgKHAgPT09IGVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhdGgubW92ZVRvKHAgJSB3aWR0aDEsIGkpO1xuICAgIGNvbnN0IHAwID0gcDtcbiAgICBsZXQgdHlwZSA9IHBvaW50c1twXTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBzdGVwID0gc3RlcHNbdHlwZV07XG4gICAgICBkbyB7XG4gICAgICAgIHAgKz0gc3RlcDtcbiAgICAgIH0gd2hpbGUgKCFwb2ludHNbcF0pO1xuICAgICAgY29uc3QgcHAgPSBwb2ludHNbcF07XG4gICAgICBpZiAocHAgIT09IDUgJiYgcHAgIT09IDEwKSB7XG4gICAgICAgIHR5cGUgPSBwcDtcbiAgICAgICAgcG9pbnRzW3BdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBwcCAmIDB4MzMgKiB0eXBlID4+IDQ7XG4gICAgICAgIHBvaW50c1twXSAmPSB0eXBlID4+IDIgfCB0eXBlIDw8IDI7XG4gICAgICB9XG4gICAgICBwYXRoLmxpbmVUbyhwICUgd2lkdGgxLCBwIC8gd2lkdGgxIHwgMCk7XG4gICAgICBpZiAoIXBvaW50c1twXSkge1xuICAgICAgICAtLWNvdW50O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHAwICE9PSBwKTtcbiAgICAtLWk7XG4gIH1cbiAgZGF0YSA9IG51bGw7XG4gIHBvaW50cyA9IG51bGw7XG4gIGNvbnN0IGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gKGMpIHtcbiAgICBjLnNhdmUoKTtcbiAgICBjLnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGMudHJhbnNsYXRlKDAsIC1oZWlnaHQpO1xuICAgIGMuZmlsbChwYXRoKTtcbiAgICBjLmJlZ2luUGF0aCgpO1xuICAgIGMucmVzdG9yZSgpO1xuICB9O1xuICByZXR1cm4gZHJhd091dGxpbmU7XG59XG5jbGFzcyBDYW52YXNFeHRyYVN0YXRlIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuYWxwaGFJc1NoYXBlID0gZmFsc2U7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuICB1cGRhdGVQYXRoTWluTWF4KHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIFt4LCB5XSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgeCk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCB5KTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHgpO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgeSk7XG4gIH1cbiAgdXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIHJlY3QpIHtcbiAgICBjb25zdCBwMSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCBwMiA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0ocmVjdC5zbGljZSgyKSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHAxWzBdLCBwMlswXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBwMVsxXSwgcDJbMV0pO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcDFbMF0sIHAyWzBdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHAxWzFdLCBwMlsxXSk7XG4gIH1cbiAgdXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBfdXRpbC5VdGlsLnNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIG1pbk1heFswXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBtaW5NYXhbMV0pO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgbWluTWF4WzJdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIG1pbk1heFszXSk7XG4gIH1cbiAgdXBkYXRlQ3VydmVQYXRoTWluTWF4KHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBib3ggPSBfdXRpbC5VdGlsLmJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgaWYgKG1pbk1heCkge1xuICAgICAgbWluTWF4WzBdID0gTWF0aC5taW4obWluTWF4WzBdLCBib3hbMF0sIGJveFsyXSk7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1heChtaW5NYXhbMV0sIGJveFswXSwgYm94WzJdKTtcbiAgICAgIG1pbk1heFsyXSA9IE1hdGgubWluKG1pbk1heFsyXSwgYm94WzFdLCBib3hbM10pO1xuICAgICAgbWluTWF4WzNdID0gTWF0aC5tYXgobWluTWF4WzNdLCBib3hbMV0sIGJveFszXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIGJveCk7XG4gIH1cbiAgZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICBjb25zdCBib3ggPSBbdGhpcy5taW5YLCB0aGlzLm1pblksIHRoaXMubWF4WCwgdGhpcy5tYXhZXTtcbiAgICBpZiAocGF0aFR5cGUgPT09IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTdHJva2UgYm91bmRpbmcgYm94IG11c3QgaW5jbHVkZSB0cmFuc2Zvcm0uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSk7XG4gICAgICBjb25zdCB4U3Ryb2tlUGFkID0gc2NhbGVbMF0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBjb25zdCB5U3Ryb2tlUGFkID0gc2NhbGVbMV0gKiB0aGlzLmxpbmVXaWR0aCAvIDI7XG4gICAgICBib3hbMF0gLT0geFN0cm9rZVBhZDtcbiAgICAgIGJveFsxXSAtPSB5U3Ryb2tlUGFkO1xuICAgICAgYm94WzJdICs9IHhTdHJva2VQYWQ7XG4gICAgICBib3hbM10gKz0geVN0cm9rZVBhZDtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbiAgfVxuICB1cGRhdGVDbGlwRnJvbVBhdGgoKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goaW50ZXJzZWN0IHx8IFswLCAwLCAwLCAwXSk7XG4gIH1cbiAgaXNFbXB0eUNsaXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3ggPSBib3g7XG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXhYID0gMDtcbiAgICB0aGlzLm1heFkgPSAwO1xuICB9XG4gIGdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwLFxuICAgIGRlc3RQb3M7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBsZXQgaSwgaiwgdGhpc0NodW5rSGVpZ2h0LCBlbGVtc0luVGhpc0NodW5rO1xuICBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICBjb25zdCBzcmNEaWZmID0gc3JjTGVuZ3RoIC0gc3JjUG9zO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgY29uc3Qga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICBsZXQgbWFzayA9IDA7XG4gICAgICAgIGxldCBzcmNCeXRlID0gMDtcbiAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEyOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDMyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxNiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoZGVzdFBvcyA8IGRlc3QzMkRhdGFMZW5ndGgpIHtcbiAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQkFfMzJCUFApIHtcbiAgICBqID0gMDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaHVua3M7IGkrKykge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgc3JjUG9zICs9IGVsZW1zSW5UaGlzQ2h1bms7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIH1cbiAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBwYXJ0aWFsQ2h1bmtIZWlnaHQgKiA0O1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gKDAsIF9pbWFnZV91dGlscy5jb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSkoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tCYWNrZHJvcChieXRlcywgcjAsIGcwLCBiMCkge1xuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBhbHBoYSA9IGJ5dGVzW2ldO1xuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgYnl0ZXNbaSAtIDNdID0gcjA7XG4gICAgICBieXRlc1tpIC0gMl0gPSBnMDtcbiAgICAgIGJ5dGVzW2kgLSAxXSA9IGIwO1xuICAgIH0gZWxzZSBpZiAoYWxwaGEgPCAyNTUpIHtcbiAgICAgIGNvbnN0IGFscGhhXyA9IDI1NSAtIGFscGhhO1xuICAgICAgYnl0ZXNbaSAtIDNdID0gYnl0ZXNbaSAtIDNdICogYWxwaGEgKyByMCAqIGFscGhhXyA+PiA4O1xuICAgICAgYnl0ZXNbaSAtIDJdID0gYnl0ZXNbaSAtIDJdICogYWxwaGEgKyBnMCAqIGFscGhhXyA+PiA4O1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYnl0ZXNbaSAtIDFdICogYWxwaGEgKyBiMCAqIGFscGhhXyA+PiA4O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrQWxwaGEobWFza0RhdGEsIGxheWVyRGF0YSwgdHJhbnNmZXJNYXApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWFza0RhdGEubGVuZ3RoO1xuICBjb25zdCBzY2FsZSA9IDEgLyAyNTU7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBhbHBoYSA9IHRyYW5zZmVyTWFwID8gdHJhbnNmZXJNYXBbbWFza0RhdGFbaV1dIDogbWFza0RhdGFbaV07XG4gICAgbGF5ZXJEYXRhW2ldID0gbGF5ZXJEYXRhW2ldICogYWxwaGEgKiBzY2FsZSB8IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0x1bWlub3NpdHkobWFza0RhdGEsIGxheWVyRGF0YSwgdHJhbnNmZXJNYXApIHtcbiAgY29uc3QgbGVuZ3RoID0gbWFza0RhdGEubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMzsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgY29uc3QgeSA9IG1hc2tEYXRhW2kgLSAzXSAqIDc3ICsgbWFza0RhdGFbaSAtIDJdICogMTUyICsgbWFza0RhdGFbaSAtIDFdICogMjg7XG4gICAgbGF5ZXJEYXRhW2ldID0gdHJhbnNmZXJNYXAgPyBsYXllckRhdGFbaV0gKiB0cmFuc2Zlck1hcFt5ID4+IDhdID4+IDggOiBsYXllckRhdGFbaV0gKiB5ID4+IDE2O1xuICB9XG59XG5mdW5jdGlvbiBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCB3aWR0aCwgaGVpZ2h0LCBzdWJ0eXBlLCBiYWNrZHJvcCwgdHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBtYXNrT2Zmc2V0WCwgbWFza09mZnNldFkpIHtcbiAgY29uc3QgaGFzQmFja2Ryb3AgPSAhIWJhY2tkcm9wO1xuICBjb25zdCByMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMF0gOiAwO1xuICBjb25zdCBnMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMV0gOiAwO1xuICBjb25zdCBiMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMl0gOiAwO1xuICBjb25zdCBjb21wb3NlRm4gPSBzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIiA/IGNvbXBvc2VTTWFza0x1bWlub3NpdHkgOiBjb21wb3NlU01hc2tBbHBoYTtcbiAgY29uc3QgUElYRUxTX1RPX1BST0NFU1MgPSAxMDQ4NTc2O1xuICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihoZWlnaHQsIE1hdGguY2VpbChQSVhFTFNfVE9fUFJPQ0VTUyAvIHdpZHRoKSk7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93ICs9IGNodW5rU2l6ZSkge1xuICAgIGNvbnN0IGNodW5rSGVpZ2h0ID0gTWF0aC5taW4oY2h1bmtTaXplLCBoZWlnaHQgLSByb3cpO1xuICAgIGNvbnN0IG1hc2tEYXRhID0gbWFza0N0eC5nZXRJbWFnZURhdGEobGF5ZXJPZmZzZXRYIC0gbWFza09mZnNldFgsIHJvdyArIChsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WSksIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgY29uc3QgbGF5ZXJEYXRhID0gbGF5ZXJDdHguZ2V0SW1hZ2VEYXRhKGxheWVyT2Zmc2V0WCwgcm93ICsgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgY2h1bmtIZWlnaHQpO1xuICAgIGlmIChoYXNCYWNrZHJvcCkge1xuICAgICAgY29tcG9zZVNNYXNrQmFja2Ryb3AobWFza0RhdGEuZGF0YSwgcjAsIGcwLCBiMCk7XG4gICAgfVxuICAgIGNvbXBvc2VGbihtYXNrRGF0YS5kYXRhLCBsYXllckRhdGEuZGF0YSwgdHJhbnNmZXJNYXApO1xuICAgIGxheWVyQ3R4LnB1dEltYWdlRGF0YShsYXllckRhdGEsIGxheWVyT2Zmc2V0WCwgcm93ICsgbGF5ZXJPZmZzZXRZKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICBjb25zdCBsYXllck9mZnNldFggPSBsYXllckJveFswXTtcbiAgY29uc3QgbGF5ZXJPZmZzZXRZID0gbGF5ZXJCb3hbMV07XG4gIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgY29uc3QgbGF5ZXJIZWlnaHQgPSBsYXllckJveFszXSAtIGxheWVyT2Zmc2V0WTtcbiAgaWYgKGxheWVyV2lkdGggPT09IDAgfHwgbGF5ZXJIZWlnaHQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICBjdHguc2F2ZSgpO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICBjdHguZHJhd0ltYWdlKGxheWVyQ3R4LmNhbnZhcywgMCwgMCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBjb25zdCBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgc2NhbGVbMF0gPSBNYXRoLmZyb3VuZChzY2FsZVswXSk7XG4gIHNjYWxlWzFdID0gTWF0aC5mcm91bmQoc2NhbGVbMV0pO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICBpZiAoaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgfSBlbHNlIGlmIChzY2FsZVswXSA8PSBhY3R1YWxTY2FsZSB8fCBzY2FsZVsxXSA8PSBhY3R1YWxTY2FsZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuY2xhc3MgQ2FudmFzR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIGZpbHRlckZhY3RvcnksIHtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgbWFya2VkQ29udGVudFN0YWNrID0gbnVsbFxuICB9LCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldE9iamVjdChkYXRhLCBmYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi4oMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jb21wb3NpdGVDdHgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVYID0gdHJhbnNmb3JtWzBdO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVkgPSB0cmFuc2Zvcm1bMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jb21wb3NpdGVDdHg7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy50cmFuc3BhcmVudENhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZygpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2FudmFzIG9mIGNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5jbGVhcigpO1xuICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgfVxuICAjZHJhd0ZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5wYWdlQ29sb3JzKSB7XG4gICAgICBjb25zdCBoY21GaWx0ZXJJZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy5wYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMucGFnZUNvbG9ycy5iYWNrZ3JvdW5kKTtcbiAgICAgIGlmIChoY21GaWx0ZXJJZCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRGaWx0ZXIgPSB0aGlzLmN0eC5maWx0ZXI7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IGhjbUZpbHRlcklkO1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5jdHguY2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gc2F2ZWRGaWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zY2FsZUltYWdlKGltZywgaW52ZXJzZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKGltZykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZztcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGxldCBjYWNoZSwgY2FjaGVLZXksIHNjYWxlZCwgbWFza0NhbnZhcztcbiAgICBpZiAoKGltZy5iaXRtYXAgfHwgaW1nLmRhdGEpICYmIGltZy5jb3VudCA+IDEpIHtcbiAgICAgIGNvbnN0IG1haW5LZXkgPSBpbWcuYml0bWFwIHx8IGltZy5kYXRhLmJ1ZmZlcjtcbiAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoaXNQYXR0ZXJuRmlsbCA/IGN1cnJlbnRUcmFuc2Zvcm0gOiBbY3VycmVudFRyYW5zZm9ybS5zbGljZSgwLCA0KSwgZmlsbENvbG9yXSk7XG4gICAgICBjYWNoZSA9IHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuZ2V0KG1haW5LZXkpO1xuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5zZXQobWFpbktleSwgY2FjaGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkSW1hZ2UgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlZEltYWdlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMF0sIGN1cnJlbnRUcmFuc2Zvcm1bMl0pICsgY3VycmVudFRyYW5zZm9ybVs0XSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMV0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pICsgY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBjb3JkMSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGNvcmQyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIG1hc2tUb0NhbnZhcyk7XG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbY29yZDFbMF0sIGNvcmQxWzFdLCBjb3JkMlswXSwgY29yZDJbMV1dKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChyZWN0WzJdIC0gcmVjdFswXSkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQocmVjdFszXSAtIHJlY3RbMV0pIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5taW4oY29yZDFbMF0sIGNvcmQyWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5taW4oY29yZDFbMV0sIGNvcmQyWzFdKTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGZpbGxDdHgpLCBpbWcuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhmaWxsQ3R4LCBzY2FsZWQsIDAsIDAsIHNjYWxlZC53aWR0aCwgc2NhbGVkLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmlsbEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgIGNvbnN0IGludmVyc2UgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJNXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTTWFza1wiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4uKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuc3VzcGVuZGVkQ3R4KSk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCBjdHgpO1xuICAgIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICBjb21wb3NlU01hc2soc3VzcGVuZGVkQ3R4LCBzbWFzaywgdGhpcy5jdHgsIGRpcnR5Qm94KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnNhdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5zdGF0ZVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuICByZXN0b3JlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID09PSAwICYmIHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnN0YXRlU3RhY2sucG9wKCk7XG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLnN1c3BlbmRlZEN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgdGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncywgbWluTWF4KSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgeCA9IGN1cnJlbnQueCxcbiAgICAgIHkgPSBjdXJyZW50Lnk7XG4gICAgbGV0IHN0YXJ0WCwgc3RhcnRZO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGE7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlQ29sb3IgPT09IFwib2JqZWN0XCIgJiYgc3Ryb2tlQ29sb3I/LmdldFBhdHRlcm4pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gIH1cbiAgZmlsbChjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKTtcbiAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiBpbnRlcnNlY3QgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwoXCJldmVub2RkXCIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbCgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5maWxsKGZhbHNlKTtcbiAgICB0aGlzLnN0cm9rZShmYWxzZSk7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBlbmRQYXRoKCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBjbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gIH1cbiAgYmVnaW5UZXh0KCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0aC50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwYXRoLngsIHBhdGgueSk7XG4gICAgICBwYXRoLmFkZFRvUGF0aChjdHgsIHBhdGguZm9udFNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQoZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIkludmFsaWQgZm9udCBtYXRyaXggZm9yIGZvbnQgXCIgKyBmb250UmVmTmFtZSk7XG4gICAgfVxuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBmb250T2JqLnN5c3RlbUZvbnRJbmZvPy5jc3MgfHwgYFwiJHtuYW1lfVwiLCAke2ZvbnRPYmouZmFsbGJhY2tOYW1lfWA7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGxldCBicm93c2VyRm9udFNpemUgPSBzaXplO1xuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2l0YWxpY30gJHtib2xkfSAke2Jyb3dzZXJGb250U2l6ZX1weCAke3R5cGVmYWNlfWA7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUobW9kZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIH1cbiAgc2V0VGV4dFJpc2UocmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKCkge1xuICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICB9XG4gIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBjb25zdCBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgY29uc3QgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGxldCBhZGRUb1BhdGg7XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBhZGRUb1BhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkVG9QYXRoKGN0eCwgZm9udFNpemUpO1xuICAgICAgaWYgKHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FkZFRvUGF0aFNldCkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHMgfHw9IFtdO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBhZGRUb1BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250U3VicGl4ZWxBQUVuYWJsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDogY3R4XG4gICAgfSA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgMTAsIDEwKTtcbiAgICBjdHguc2NhbGUoMS41LCAxKTtcbiAgICBjdHguZmlsbFRleHQoXCJJXCIsIDAsIDEwKTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxMCwgMTApLmRhdGE7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2ldID4gMCAmJiBkYXRhW2ldIDwgMjU1KSB7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93VHlwZTNUZXh0KGdseXBocyk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgIGNvbnN0IHNpbXBsZUZpbGxUZXh0ID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVyblRyYW5zZm9ybTtcbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyZW50LmZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCk7XG4gICAgICBwYXR0ZXJuVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxUZXh0KGNoYXJzLmpvaW4oXCJcIiksIDAsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmb250LnJlbWVhc3VyZSAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIoYWNjZW50LmZvbnRDaGFyLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAocmVzdG9yZU5lZWRlZCkge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gZm9udC52ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBjdXJyZW50LmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5JTlZJU0lCTEU7XG4gICAgbGV0IGksIGdseXBoLCB3aWR0aCwgc3BhY2luZ0xlbmd0aDtcbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55KTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKHNwYWNpbmdMZW5ndGgsIDApO1xuICAgICAgICBjdXJyZW50LnggKz0gc3BhY2luZ0xlbmd0aCAqIHRleHRIU2NhbGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gZm9udC5jaGFyUHJvY09wZXJhdG9yTGlzdFtnbHlwaC5vcGVyYXRvckxpc3RJZF07XG4gICAgICBpZiAoIW9wZXJhdG9yTGlzdCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IGdseXBoO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbZ2x5cGgud2lkdGgsIDBdLCBmb250TWF0cml4KTtcbiAgICAgIHdpZHRoID0gdHJhbnNmb3JtZWRbMF0gKiBmb250U2l6ZSArIHNwYWNpbmc7XG4gICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICB9XG4gIHNldENoYXJXaWR0aCh4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKHhXaWR0aCwgeVdpZHRoLCBsbHgsIGxseSwgdXJ4LCB1cnkpIHtcbiAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgdGhpcy5jdHguY2xpcCgpO1xuICAgIHRoaXMuZW5kUGF0aCgpO1xuICB9XG4gIGdldENvbG9yTl9QYXR0ZXJuKElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgY29sb3IgPSBJUlsxXTtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IGN0eCA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgX3BhdHRlcm5faGVscGVyLlRpbGluZ1BhdHRlcm4oSVIsIGNvbG9yLCB0aGlzLmN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4oSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgfVxuICBzZXRGaWxsQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgfVxuICBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgY29uc3QgY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNvbG9yO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgY29uc3QgY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgX2dldFBhdHRlcm4ob2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gKDAsIF9wYXR0ZXJuX2hlbHBlci5nZXRTaGFkaW5nUGF0dGVybikodGhpcy5nZXRPYmplY3Qob2JqSWQpKTtcbiAgICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuc2V0KG9iaklkLCBwYXR0ZXJuKTtcbiAgICB9XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNoYWRpbmdGaWxsKG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKG9iaklkKTtcbiAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybi5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuU0hBRElORyk7XG4gICAgY29uc3QgaW52ID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIGludik7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCgtMWUxMCwgLTFlMTAsIDJlMTAsIDJlMTApO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW5saW5lSW1hZ2VcIik7XG4gIH1cbiAgYmVnaW5JbWFnZURhdGEoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbkltYWdlRGF0YVwiKTtcbiAgfVxuICBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRyaXgpICYmIG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgIHRoaXMuY3R4LnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpLCBiYm94KTtcbiAgICAgIHRoaXMuY2xpcCgpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG4gIGJlZ2luR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Q3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgKDAsIF91dGlsLmluZm8pKFwiVE9ETzogU3VwcG9ydCBub24taXNvbGF0ZWQgZ3JvdXBzLlwiKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmtub2Nrb3V0KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3VycmVudEN0eCk7XG4gICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgY3VycmVudEN0eC50cmFuc2Zvcm0oLi4uZ3JvdXAubWF0cml4KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cbiAgICBsZXQgYm91bmRzID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3VycmVudEN0eCkpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBfdXRpbC5VdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBsZXQgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgbGV0IGRyYXduSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1szXSkgLSBvZmZzZXRZLCAxKTtcbiAgICBsZXQgc2NhbGVYID0gMSxcbiAgICAgIHNjYWxlWSA9IDE7XG4gICAgaWYgKGRyYXduV2lkdGggPiBNQVhfR1JPVVBfU0laRSkge1xuICAgICAgc2NhbGVYID0gZHJhd25XaWR0aCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgZHJhd25XaWR0aCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgIH1cbiAgICBpZiAoZHJhd25IZWlnaHQgPiBNQVhfR1JPVVBfU0laRSkge1xuICAgICAgc2NhbGVZID0gZHJhd25IZWlnaHQgLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgIGRyYXduSGVpZ2h0ID0gTUFYX0dST1VQX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHN1YnR5cGU6IGdyb3VwLnNtYXNrLnN1YnR5cGUsXG4gICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgdHJhbnNmZXJNYXA6IGdyb3VwLnNtYXNrLnRyYW5zZmVyTWFwIHx8IG51bGwsXG4gICAgICAgIHN0YXJ0VHJhbnNmb3JtSW52ZXJzZTogbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN1cnJlbnRDdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgIHRoaXMuY3R4ID0gZ3JvdXBDdHg7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgY29uc3QgY3VycmVudE10eCA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihpZCwgcmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgsIGhhc093bkNhbnZhcykge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWN0KSAmJiByZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCkpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmlld3BvcnRTY2FsZVxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiB0aGlzLm91dHB1dFNjYWxlWCAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogdGhpcy5vdXRwdXRTY2FsZVkgKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZShjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcC5zZXQoaWQsIGNhbnZhcyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eCA9IHRoaXMuY3R4O1xuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgMCwgMCwgLXNjYWxlWSwgMCwgaGVpZ2h0ICogc2NhbGVZKTtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLmFubm90YXRpb25DYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgfVxuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcbiAgICBpZiAoZ2x5cGgpIHtcbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkID0gY29tcGlsZVR5cGUzR2x5cGgoaW1nKTtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5jb21waWxlZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZChjdHgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG4gICAgY29uc3QgbWFza0NhbnZhcyA9IG1hc2suY2FudmFzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIG1hc2sub2Zmc2V0WCwgbWFzay5vZmZzZXRZKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdChpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgMCwgMCk7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0cmFucyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCB0cmFucyk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB4LCB5KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cChpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybVxuICAgICAgfSA9IGltYWdlO1xuICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGltZyA9IHRoaXMuZ2V0T2JqZWN0KGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBtYXAucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogW3NjYWxlWCwgMCwgMCwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsdGVyXG4gICAgICB9ID0gY3R4O1xuICAgICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBtYXApIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgaW1nVG9QYWludCwgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBtYXJrUG9pbnQodGFnKSB7fVxuICBtYXJrUG9pbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHt9XG4gIGJlZ2luTWFya2VkQ29udGVudCh0YWcpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAodGFnID09PSBcIk9DXCIpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KCkge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBiZWdpbkNvbXBhdCgpIHt9XG4gIGVuZENvbXBhdCgpIHt9XG4gIGNvbnN1bWVQYXRoKGNsaXBCb3gpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdGhpcy5jdXJyZW50LmlzRW1wdHlDbGlwKCk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVDbGlwRnJvbVBhdGgoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KHRoaXMuY3VycmVudC5jbGlwQm94KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gIH1cbiAgZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgpIHtcbiAgICAgIGNvbnN0IG0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2Uoc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsaW5lV2lkdGhcbiAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmV4cG9ydHMuQ2FudmFzR3JhcGhpY3MgPSBDYW52YXNHcmFwaGljcztcbmZvciAoY29uc3Qgb3AgaW4gX3V0aWwuT1BTKSB7XG4gIGlmIChDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbX3V0aWwuT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuVGlsaW5nUGF0dGVybiA9IGV4cG9ydHMuUGF0aFR5cGUgPSB2b2lkIDA7XG5leHBvcnRzLmdldFNoYWRpbmdQYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm47XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmV4cG9ydHMuUGF0aFR5cGUgPSBQYXRoVHlwZTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU2hhZGluZ1BhdHRlcm4pIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlU2hhZGluZ1BhdHRlcm4uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRQYXR0ZXJuKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYGdldFBhdHRlcm5gIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdHlwZSA9IElSWzFdO1xuICAgIHRoaXMuX2Jib3ggPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvclN0b3BzID0gSVJbM107XG4gICAgdGhpcy5fcDAgPSBJUls0XTtcbiAgICB0aGlzLl9wMSA9IElSWzVdO1xuICAgIHRoaXMuX3IwID0gSVJbNl07XG4gICAgdGhpcy5fcjEgPSBJUls3XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUdyYWRpZW50KGN0eCkge1xuICAgIGxldCBncmFkO1xuICAgIGlmICh0aGlzLl90eXBlID09PSBcImF4aWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gXCJyYWRpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3IwLCB0aGlzLl9wMVswXSwgdGhpcy5fcDFbMV0sIHRoaXMuX3IxKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb2xvclN0b3Agb2YgdGhpcy5fY29sb3JTdG9wcykge1xuICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wWzBdLCBjb2xvclN0b3BbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhZDtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UgfHwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLkZJTEwpIHtcbiAgICAgIGNvbnN0IG93bmVyQkJveCA9IG93bmVyLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0oaW52ZXJzZSwgWzEsIDAsIDAsIDEsIG93bmVyQkJveFswXSwgb3duZXJCQm94WzFdXSk7XG4gICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgYXBwbHlCb3VuZGluZ0JveCh0bXBDdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KHRtcEN0eCk7XG4gICAgICB0bXBDdHguZmlsbCgpO1xuICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgY29uc3QgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChpbnZlcnNlKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHAxLCBwMiwgcDMsIGMxLCBjMiwgYzMpIHtcbiAgY29uc3QgY29vcmRzID0gY29udGV4dC5jb29yZHMsXG4gICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgbGV0IHRtcDtcbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICB0bXAgPSBwMjtcbiAgICBwMiA9IHAzO1xuICAgIHAzID0gdG1wO1xuICAgIHRtcCA9IGMyO1xuICAgIGMyID0gYzM7XG4gICAgYzMgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgaWYgKHkxID49IHkzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGMxciA9IGNvbG9yc1tjMV0sXG4gICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gIGNvbnN0IGMzciA9IGNvbG9yc1tjM10sXG4gICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gIGNvbnN0IG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gIGxldCB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgbGV0IHhiLCBjYnIsIGNiZywgY2JiO1xuICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICBpZiAoeSA8IHkyKSB7XG4gICAgICBjb25zdCBrID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICBjYXIgPSBjMXIgLSAoYzFyIC0gYzJyKSAqIGs7XG4gICAgICBjYWcgPSBjMWcgLSAoYzFnIC0gYzJnKSAqIGs7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGs7XG4gICAgICBjYWcgPSBjMmcgLSAoYzJnIC0gYzNnKSAqIGs7XG4gICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGxldCBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyaWFuZ2xlc1wiOlxuICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cbmNsYXNzIE1lc2hTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb29yZHMgPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvcnMgPSBJUlszXTtcbiAgICB0aGlzLl9maWd1cmVzID0gSVJbNF07XG4gICAgdGhpcy5fYm91bmRzID0gSVJbNV07XG4gICAgdGhpcy5fYmJveCA9IElSWzddO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSBJUls4XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZU1lc2hDYW52YXMoY29tYmluZWRTY2FsZSwgYmFja2dyb3VuZENvbG9yLCBjYWNoZWRDYW52YXNlcykge1xuICAgIGNvbnN0IEVYUEVDVEVEX1NDQUxFID0gMS4xO1xuICAgIGNvbnN0IE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1sxXSk7XG4gICAgY29uc3QgYm91bmRzV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzJdKSAtIG9mZnNldFg7XG4gICAgY29uc3QgYm91bmRzSGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1szXSkgLSBvZmZzZXRZO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZWRTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNIZWlnaHQgKiBjb21iaW5lZFNjYWxlWzFdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3Qgc2NhbGVYID0gYm91bmRzV2lkdGggLyB3aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvb3JkczogdGhpcy5fY29vcmRzLFxuICAgICAgY29sb3JzOiB0aGlzLl9jb2xvcnMsXG4gICAgICBvZmZzZXRYOiAtb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgc2NhbGVYOiAxIC8gc2NhbGVYLFxuICAgICAgc2NhbGVZOiAxIC8gc2NhbGVZXG4gICAgfTtcbiAgICBjb25zdCBwYWRkZWRXaWR0aCA9IHdpZHRoICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBjYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtZXNoXCIsIHBhZGRlZFdpZHRoLCBwYWRkZWRIZWlnaHQsIGZhbHNlKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBkYXRhID0gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiYWNrZ3JvdW5kQ29sb3JbMF07XG4gICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICBieXRlc1tpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlndXJlIG9mIHRoaXMuX2ZpZ3VyZXMpIHtcbiAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICBsZXQgc2NhbGU7XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY29uc3QgbWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICAgICAgc2NhbGUgPSBbc2NhbGVbMF0gKiBtYXRyaXhTY2FsZVswXSwgc2NhbGVbMV0gKiBtYXRyaXhTY2FsZVsxXV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY29sb3IsIGN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdIHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB0aGlzLmJib3ggPSBJUls0XTtcbiAgICB0aGlzLnhzdGVwID0gSVJbNV07XG4gICAgdGhpcy55c3RlcCA9IElSWzZdO1xuICAgIHRoaXMucGFpbnRUeXBlID0gSVJbN107XG4gICAgdGhpcy50aWxpbmdUeXBlID0gSVJbOF07XG4gICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGJhc2VUcmFuc2Zvcm07XG4gIH1cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcikge1xuICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IHRoaXMub3BlcmF0b3JMaXN0O1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmJib3g7XG4gICAgY29uc3QgeHN0ZXAgPSB0aGlzLnhzdGVwO1xuICAgIGNvbnN0IHlzdGVwID0gdGhpcy55c3RlcDtcbiAgICBjb25zdCBwYWludFR5cGUgPSB0aGlzLnBhaW50VHlwZTtcbiAgICBjb25zdCB0aWxpbmdUeXBlID0gdGhpcy50aWxpbmdUeXBlO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICAoMCwgX3V0aWwuaW5mbykoXCJUaWxpbmdUeXBlOiBcIiArIHRpbGluZ1R5cGUpO1xuICAgIGNvbnN0IHgwID0gYmJveFswXSxcbiAgICAgIHkwID0gYmJveFsxXSxcbiAgICAgIHgxID0gYmJveFsyXSxcbiAgICAgIHkxID0gYmJveFszXTtcbiAgICBjb25zdCBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgIGNvbnN0IGN1ck1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGUgPSBbbWF0cml4U2NhbGVbMF0gKiBjdXJNYXRyaXhTY2FsZVswXSwgbWF0cml4U2NhbGVbMV0gKiBjdXJNYXRyaXhTY2FsZVsxXV07XG4gICAgY29uc3QgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHhzdGVwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVbMF0pO1xuICAgIGNvbnN0IGRpbXkgPSB0aGlzLmdldFNpemVBbmRTY2FsZSh5c3RlcCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVsxXSk7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSwgdHJ1ZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4KTtcbiAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICB0aGlzLnNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcik7XG4gICAgbGV0IGFkanVzdGVkWDAgPSB4MDtcbiAgICBsZXQgYWRqdXN0ZWRZMCA9IHkwO1xuICAgIGxldCBhZGp1c3RlZFgxID0geDE7XG4gICAgbGV0IGFkanVzdGVkWTEgPSB5MTtcbiAgICBpZiAoeDAgPCAwKSB7XG4gICAgICBhZGp1c3RlZFgwID0gMDtcbiAgICAgIGFkanVzdGVkWDEgKz0gTWF0aC5hYnMoeDApO1xuICAgIH1cbiAgICBpZiAoeTAgPCAwKSB7XG4gICAgICBhZGp1c3RlZFkwID0gMDtcbiAgICAgIGFkanVzdGVkWTEgKz0gTWF0aC5hYnMoeTApO1xuICAgIH1cbiAgICB0bXBDdHgudHJhbnNsYXRlKC0oZGlteC5zY2FsZSAqIGFkanVzdGVkWDApLCAtKGRpbXkuc2NhbGUgKiBhZGp1c3RlZFkwKSk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgYWRqdXN0ZWRYMCwgYWRqdXN0ZWRZMCwgYWRqdXN0ZWRYMSwgYWRqdXN0ZWRZMSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpO1xuICAgIGdyYXBoaWNzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICBncmFwaGljcy5lbmREcmF3aW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IGFkanVzdGVkWDAsXG4gICAgICBvZmZzZXRZOiBhZGp1c3RlZFkwXG4gICAgfTtcbiAgfVxuICBnZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgc3RlcCA9IE1hdGguYWJzKHN0ZXApO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heChUaWxpbmdQYXR0ZXJuLk1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICBsZXQgc2l6ZSA9IE1hdGguY2VpbChzdGVwICogc2NhbGUpO1xuICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgIHNpemUgPSBtYXhTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBjbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICBncmFwaGljcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGdyYXBoaWNzLmN0eCksIFt4MCwgeTAsIHgxLCB5MV0pO1xuICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gIH1cbiAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgX3V0aWwuRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5leHBvcnRzLlRpbGluZ1BhdHRlcm4gPSBUaWxpbmdQYXR0ZXJuO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkE7XG5leHBvcnRzLmNvbnZlcnRUb1JHQkEgPSBjb252ZXJ0VG9SR0JBO1xuZXhwb3J0cy5ncmF5VG9SR0JBID0gZ3JheVRvUkdCQTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5mdW5jdGlvbiBjb252ZXJ0VG9SR0JBKHBhcmFtcykge1xuICBzd2l0Y2ggKHBhcmFtcy5raW5kKSB7XG4gICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICByZXR1cm4gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEocGFyYW1zKTtcbiAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICByZXR1cm4gY29udmVydFJHQlRvUkdCQShwYXJhbXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG5vbkJsYWNrQ29sb3IgPSAweGZmZmZmZmZmLFxuICBpbnZlcnNlRGVjb2RlID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgYmxhY2sgPSBfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4zMiA9IHNyYy5sZW5ndGggPj4gMjtcbiAgY29uc3Qgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlciwgc3JjUG9zLCBsZW4zMik7XG4gIGlmIChfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA+Pj4gMjQgfCBzMiA8PCA4IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPj4+IDE2IHwgczMgPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA+Pj4gOCB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmMubGVuZ3RoOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyYy5sZW5ndGg7IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gPDwgMjQgfCBzcmNbaiArIDFdIDw8IDE2IHwgc3JjW2ogKyAyXSA8PCA4IHwgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gZ3JheVRvUkdCQShzcmMsIGRlc3QpIHtcbiAgaWYgKF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxIHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxMDAgfCAweDAwMDAwMGZmO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkdsb2JhbFdvcmtlck9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBHbG9iYWxXb3JrZXJPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IEdsb2JhbFdvcmtlck9wdGlvbnM7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnQgPSBudWxsO1xuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSBcIlwiO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNvbnN0IENhbGxiYWNrS2luZCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgREFUQTogMSxcbiAgRVJST1I6IDJcbn07XG5jb25zdCBTdHJlYW1LaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcbmZ1bmN0aW9uIHdyYXBSZWFzb24ocmVhc29uKSB7XG4gIGlmICghKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiByZWFzb24gPT09IFwib2JqZWN0XCIgJiYgcmVhc29uICE9PSBudWxsKSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKHJlYXNvbi5uYW1lKSB7XG4gICAgY2FzZSBcIkFib3J0RXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5jb2RlKTtcbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnN0YXR1cyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5kZXRhaWxzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSB0aGlzLnNvdXJjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgICBjb25zdCBjYXBhYmlsaXR5ID0gdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICAgIGNvbnN0IGNiU291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZTtcbiAgICAgICAgY29uc3QgY2JUYXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zdHJlYW1JZCkge1xuICAgICAgICB0aGlzLiNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgICB9O1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSk7XG4gIH1cbiAgb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJHthY3Rpb25OYW1lfVwiYCk7XG4gICAgfVxuICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgfVxuICBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGFcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICB9XG4gIHNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgIGNhbGxiYWNrSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZW5kV2l0aFN0cmVhbShhY3Rpb25OYW1lLCBkYXRhLCBxdWV1ZWluZ1N0cmF0ZWd5LCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IHRoaXMuc3RyZWFtSWQrKyxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gdGhpcy50YXJnZXROYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgIHN0YXJ0Q2FsbDogc3RhcnRDYXBhYmlsaXR5LFxuICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgIGNhbmNlbENhbGw6IG51bGwsXG4gICAgICAgICAgaXNDbG9zZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3QgcHVsbENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTEwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWxsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiY2FuY2VsIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG4gICNjcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG4gICAgICAgIGlmIChsYXN0RGVzaXJlZFNpemUgPiAwICYmIHRoaXMuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FTlFVRVVFLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSwgc3RyZWFtU2luaykpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25QdWxsPy4oKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVOUVVFVUU6XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHN0cmVhbUNvbnRyb2xsZXIsIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHN0cmVhbUNvbnRyb2xsZXIsIFwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1TaW5rLm9uQ2FuY2VsPy4od3JhcFJlYXNvbihkYXRhLnJlYXNvbikpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY29tT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxufVxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21ldGFkYXRhTWFwO1xuICAjZGF0YTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcnNlZERhdGEsXG4gICAgcmF3RGF0YVxuICB9KSB7XG4gICAgdGhpcy4jbWV0YWRhdGFNYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNtZXRhZGF0YU1hcCk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuaGFzKG5hbWUpO1xuICB9XG59XG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuT3B0aW9uYWxDb250ZW50Q29uZmlnID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbXVybXVyaGFzaCA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjdmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGludGVudCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gIH1cbiAgX3NldFZpc2libGUoaW50ZXJuYWwsIHZpc2libGUpIHtcbiAgICBpZiAoaW50ZXJuYWwgIT09IElOVEVSTkFMKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiSW50ZXJuYWwgbWV0aG9kIGBfc2V0VmlzaWJsZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jdmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbn1cbmNsYXNzIE9wdGlvbmFsQ29udGVudENvbmZpZyB7XG4gICNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgI2dyb3VwcyA9IG5ldyBNYXAoKTtcbiAgI2luaXRpYWxIYXNoID0gbnVsbDtcbiAgI29yZGVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAoZ3JvdXAubmFtZSwgZ3JvdXAuaW50ZW50KSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLiNncm91cHMudmFsdWVzKCkpIHtcbiAgICAgICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvbiBvZiBkYXRhLm9uKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9uKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2ZmIG9mIGRhdGEub2ZmKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9mZikuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbEhhc2ggPSB0aGlzLmdldEhhc2goKTtcbiAgfVxuICAjZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdG9yID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgbGV0IHN0YXRlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNncm91cHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtZW50KS52aXNpYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7Z3JvdXAuaWR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoZ3JvdXAuaWQpLnZpc2libGU7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIk9DTURcIikge1xuICAgICAgaWYgKGdyb3VwLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZ3JvdXAuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLnBvbGljeSB8fCBncm91cC5wb2xpY3kgPT09IFwiQW55T25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAoMCwgX3V0aWwud2FybikoYFVua25vd24gZ3JvdXAgdHlwZSAke2dyb3VwLnR5cGV9LmApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldFZpc2liaWxpdHkoaWQsIHZpc2libGUgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZ3JvdXBzLmdldChpZCkuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSk7XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuc2l6ZSA+IDAgPyAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy4jZ3JvdXBzKSA6IG51bGw7XG4gIH1cbiAgZ2V0R3JvdXAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRHZXRIYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaDtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IG5ldyBfbXVybXVyaGFzaC5NdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbn1cbmV4cG9ydHMuT3B0aW9uYWxDb250ZW50Q29uZmlnID0gT3B0aW9uYWxDb250ZW50Q29uZmlnO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0gPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbGVuZ3RoLFxuICAgIGluaXRpYWxEYXRhLFxuICAgIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLFxuICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCxcbiAgICBkaXNhYmxlUmFuZ2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlU3RyZWFtID0gZmFsc2VcbiAgfSwgcGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoZm91bmQsIFwiX29uUmVjZWl2ZURhdGEgLSBubyBgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyYCBpbnN0YW5jZSBmb3VuZC5cIik7XG4gICAgfVxuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzWzBdPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX29uUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG4gIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cbn1cbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IFBERkRhdGFUcmFuc3BvcnRTdHJlYW07XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfZGlzcGxheV91dGlscy5pc1BkZkZpbGUpKGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKSA/IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIDogbnVsbDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBxdWV1ZWRDaHVua3MgfHwgW107XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3F1ZXVlZENodW5rcykge1xuICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5faGVhZGVyc1JlYWR5ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXM7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5fY29udGVudExlbmd0aDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0c0NhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdHNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGRmV0Y2hTdHJlYW0gPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG47XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGh0dHBIZWFkZXJzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBodHRwSGVhZGVyc1twcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBoZWFkZXJzLmFwcGVuZChwcm9wZXJ0eSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAoMCwgX3V0aWwud2FybikoYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBzb3VyY2UuaHR0cEhlYWRlcnMgfHwge307XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZGZXRjaFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5QREZGZXRjaFN0cmVhbSA9IFBERkZldGNoU3RyZWFtO1xuY2xhc3MgUERGRmV0Y2hTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLl9zdHJlYW0uaHR0cEhlYWRlcnMpO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnModGhpcy5faGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmICghKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiB0aGlzLl9zdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiU3RyZWFtaW5nIGlzIGRpc2FibGVkLlwiKSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2godGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5faGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnModGhpcy5faGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmICghKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IgPSBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yO1xuZXhwb3J0cy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcjtcbmV4cG9ydHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMgPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcztcbmV4cG9ydHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cyA9IHZhbGlkYXRlUmVzcG9uc2VTdGF0dXM7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9jb250ZW50X2Rpc3Bvc2l0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICBnZXRSZXNwb25zZUhlYWRlcixcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1MZW5ndGhcIiksIDEwKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5zdWdnZXN0ZWRMZW5ndGggPSBsZW5ndGg7XG4gIGlmIChsZW5ndGggPD0gMiAqIHJhbmdlQ2h1bmtTaXplKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChnZXRSZXNwb25zZUhlYWRlcihcIkFjY2VwdC1SYW5nZXNcIikgIT09IFwiYnl0ZXNcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgY29uc3QgY29udGVudEVuY29kaW5nID0gZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIoZ2V0UmVzcG9uc2VIZWFkZXIpIHtcbiAgY29uc3QgY29udGVudERpc3Bvc2l0aW9uID0gZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gKDAsIF9jb250ZW50X2Rpc3Bvc2l0aW9uLmdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgICBpZiAoZmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmICgoMCwgX2Rpc3BsYXlfdXRpbHMuaXNQZGZGaWxlKShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdXJsKSB7XG4gIGlmIChzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkge1xuICAgIHJldHVybiBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbignTWlzc2luZyBQREYgXCInICsgdXJsICsgJ1wiLicpO1xuICB9XG4gIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoJHtzdGF0dXN9KSB3aGlsZSByZXRyaWV2aW5nIFBERiBcIiR7dXJsfVwiLmAsIHN0YXR1cyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSAyMDAgfHwgc3RhdHVzID09PSAyMDY7XG59XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgbGV0IG5lZWRzRW5jb2RpbmdGaXh1cCA9IHRydWU7XG4gIGxldCB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKlwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSB1bmVzY2FwZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmM1OTg3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyBcIlxcXFxzKj1cXFxccypcIiArIFwiKFwiICsgJ1teXCI7XFxcXHNdW147XFxcXHNdKicgKyBcInxcIiArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFxcIj8pK1wiPycgKyBcIilcIiwgZmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBpZiAoIS9eW1xceDAwLVxceEZGXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKSh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgICAgIGlmIChuIGluIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG4gICAgICBpZiAocXVvdCkge1xuICAgICAgICBwYXJ0ID0gdW5lc2NhcGUocGFydCk7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2VBbGwoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgY29uc3QgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxhbmd2YWx1ZS5yZXBsYWNlKC9eW14nXSonLywgXCJcIik7XG4gICAgcmV0dXJuIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2VBbGwoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoXCJfXCIsIFwiIFwiKTtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbCgvPShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24gKG1hdGNoLCBoZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXgsIDE2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbjtcbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGFyZ3MgPSB7fSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBhcmdzLmh0dHBIZWFkZXJzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLmN1cnJYaHJJZCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgYmVnaW4sXG4gICAgICBlbmRcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGFyZ3NbcHJvcF0gPSBsaXN0ZW5lcnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYXJncyk7XG4gIH1cbiAgcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChsaXN0ZW5lcnMpO1xuICB9XG4gIHJlcXVlc3QoYXJncykge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGNvbnN0IHhocklkID0gdGhpcy5jdXJyWGhySWQrKztcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXSA9IHtcbiAgICAgIHhoclxuICAgIH07XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHRoaXMuaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YXJncy5iZWdpbn0tJHthcmdzLmVuZCAtIDF9YCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBPS19SRVNQT05TRTtcbiAgICB9XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBpZiAoYXJncy5vbkVycm9yKSB7XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMsIHhocklkKTtcbiAgICB4aHIub25wcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMsIHhocklkKTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lID0gYXJncy5vbkRvbmU7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvciA9IGFyZ3Mub25FcnJvcjtcbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHJldHVybiB4aHJJZDtcbiAgfVxuICBvblByb2dyZXNzKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3M/LihldnQpO1xuICB9XG4gIG9uU3RhdGVDaGFuZ2UoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA+PSAyICYmIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgZGVsZXRlIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIH1cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEoeGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeGhyU3RhdHVzID0geGhyLnN0YXR1cyB8fCBPS19SRVNQT05TRTtcbiAgICBjb25zdCBva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ID0geGhyU3RhdHVzID09PSBPS19SRVNQT05TRSAmJiBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIGlmICghb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCAmJiB4aHJTdGF0dXMgIT09IHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UudXJsLCB7XG4gICAgICBodHRwSGVhZGVyczogc291cmNlLmh0dHBIZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBzb3VyY2Uud2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCB0aGlzLl9zb3VyY2UpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgYmVnaW4sIGVuZCk7XG4gICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERk5ldHdvcmtTdHJlYW0gPSBQREZOZXR3b3JrU3RyZWFtO1xuY2xhc3MgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgc291cmNlKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fdXJsID0gc291cmNlLnVybDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0RnVsbChhcmdzKTtcbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIGZ1bGxSZXF1ZXN0WGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcbiAgICBpZiAodGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgfVxuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPSAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldnQubGVuZ3RoQ29tcHV0YWJsZSA/IGV2dC50b3RhbCA6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NhY2hlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IG1hbmFnZXIudXJsO1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGFyZ3MpO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMub25DbG9zZWQgPSBudWxsO1xuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTdHJlYW1pbmdTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbjtcbmNvbnN0IGZpbGVVcmlSZWdleCA9IC9eZmlsZTpcXC9cXC9cXC9bYS16QS1aXTpcXC8vO1xuZnVuY3Rpb24gcGFyc2VVcmwoc291cmNlVXJsKSB7XG4gIGNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG4gIGNvbnN0IHBhcnNlZFVybCA9IHVybC5wYXJzZShzb3VyY2VVcmwpO1xuICBpZiAocGFyc2VkVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIgfHwgcGFyc2VkVXJsLmhvc3QpIHtcbiAgICByZXR1cm4gcGFyc2VkVXJsO1xuICB9XG4gIGlmICgvXlthLXpdOlsvXFxcXF0vaS50ZXN0KHNvdXJjZVVybCkpIHtcbiAgICByZXR1cm4gdXJsLnBhcnNlKGBmaWxlOi8vLyR7c291cmNlVXJsfWApO1xuICB9XG4gIGlmICghcGFyc2VkVXJsLmhvc3QpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSBcImZpbGU6XCI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFVybDtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHBhcnNlVXJsKHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaXNIdHRwID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgICB0aGlzLmlzRnNVcmwgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBzb3VyY2UuaHR0cEhlYWRlcnMgfHwge307XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOb2RlU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcy5pc0ZzVXJsID8gbmV3IFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIodGhpcykgOiBuZXcgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5pc0ZzVXJsID8gbmV3IFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpIDogbmV3IFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5QREZOb2RlU3RyZWFtID0gUERGTm9kZVN0cmVhbTtcbmNsYXNzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2Vycm9yKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcInN0cmVhbWluZyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdE9wdGlvbnMocGFyc2VkVXJsLCBoZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHBhcnNlZFVybC5wcm90b2NvbCxcbiAgICBhdXRoOiBwYXJzZWRVcmwuYXV0aCxcbiAgICBob3N0OiBwYXJzZWRVcmwuaG9zdG5hbWUsXG4gICAgcG9ydDogcGFyc2VkVXJsLnBvcnQsXG4gICAgcGF0aDogcGFyc2VkVXJsLnBhdGgsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnNcbiAgfTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdHJlYW0uaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgICBjb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgc3RyZWFtLmh0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgc3RyZWFtLmh0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICB0aGlzLl9odHRwSGVhZGVycyA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc3RyZWFtLmh0dHBIZWFkZXJzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHN0cmVhbS5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2h0dHBIZWFkZXJzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLl9odHRwSGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZCAtIDF9YDtcbiAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgICBjb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VybC5wYXRoKTtcbiAgICBpZiAoZmlsZVVyaVJlZ2V4LnRlc3QodGhpcy5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuICAgIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGZzLmxzdGF0KHBhdGgsIChlcnJvciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3BhdGh9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCkpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciBleHRlbmRzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgc3RhcnQsIGVuZCkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5fdXJsLnBhdGgpO1xuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogZW5kIC0gMVxuICAgIH0pKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlNWR0dyYXBoaWNzID0gdm9pZCAwO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG47XG5jb25zdCBTVkdfREVGQVVMVFMgPSB7XG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIixcbiAgZmlsbENvbG9yOiBcIiMwMDAwMDBcIlxufTtcbmNvbnN0IFhNTF9OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCI7XG5jb25zdCBYTElOS19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuY29uc3QgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbmNvbnN0IGNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIChkYXRhLCBjb250ZW50VHlwZSA9IFwiXCIsIGZvcmNlRGF0YVNjaGVtYSA9IGZhbHNlKSB7XG4gIGlmIChVUkwuY3JlYXRlT2JqZWN0VVJMICYmIHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmICFmb3JjZURhdGFTY2hlbWEpIHtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgfSkpO1xuICB9XG4gIGNvbnN0IGRpZ2l0cyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgbGV0IGJ1ZmZlciA9IGBkYXRhOiR7Y29udGVudFR5cGV9O2Jhc2U2NCxgO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBkYXRhLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICBjb25zdCBiMSA9IGRhdGFbaV0gJiAweGZmO1xuICAgIGNvbnN0IGIyID0gZGF0YVtpICsgMV0gJiAweGZmO1xuICAgIGNvbnN0IGIzID0gZGF0YVtpICsgMl0gJiAweGZmO1xuICAgIGNvbnN0IGQxID0gYjEgPj4gMixcbiAgICAgIGQyID0gKGIxICYgMykgPDwgNCB8IGIyID4+IDQ7XG4gICAgY29uc3QgZDMgPSBpICsgMSA8IGlpID8gKGIyICYgMHhmKSA8PCAyIHwgYjMgPj4gNiA6IDY0O1xuICAgIGNvbnN0IGQ0ID0gaSArIDIgPCBpaSA/IGIzICYgMHgzZiA6IDY0O1xuICAgIGJ1ZmZlciArPSBkaWdpdHNbZDFdICsgZGlnaXRzW2QyXSArIGRpZ2l0c1tkM10gKyBkaWdpdHNbZDRdO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuY29uc3QgY29udmVydEltZ0RhdGFUb1BuZyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgUE5HX0hFQURFUiA9IG5ldyBVaW50OEFycmF5KFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXSk7XG4gIGNvbnN0IENIVU5LX1dSQVBQRVJfU0laRSA9IDEyO1xuICBjb25zdCBjcmNUYWJsZSA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBsZXQgYyA9IGk7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCA4OyBoKyspIHtcbiAgICAgIGMgPSBjICYgMSA/IDB4ZWRiODgzMjAgXiBjID4+IDEgJiAweDdmZmZmZmZmIDogYyA+PiAxICYgMHg3ZmZmZmZmZjtcbiAgICB9XG4gICAgY3JjVGFibGVbaV0gPSBjO1xuICB9XG4gIGZ1bmN0aW9uIGNyYzMyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgY3JjID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSAoY3JjIF4gZGF0YVtpXSkgJiAweGZmO1xuICAgICAgY29uc3QgYiA9IGNyY1RhYmxlW2FdO1xuICAgICAgY3JjID0gY3JjID4+PiA4IF4gYjtcbiAgICB9XG4gICAgcmV0dXJuIGNyYyBeIC0xO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlUG5nQ2h1bmsodHlwZSwgYm9keSwgZGF0YSwgb2Zmc2V0KSB7XG4gICAgbGV0IHAgPSBvZmZzZXQ7XG4gICAgY29uc3QgbGVuID0gYm9keS5sZW5ndGg7XG4gICAgZGF0YVtwXSA9IGxlbiA+PiAyNCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMV0gPSBsZW4gPj4gMTYgJiAweGZmO1xuICAgIGRhdGFbcCArIDJdID0gbGVuID4+IDggJiAweGZmO1xuICAgIGRhdGFbcCArIDNdID0gbGVuICYgMHhmZjtcbiAgICBwICs9IDQ7XG4gICAgZGF0YVtwXSA9IHR5cGUuY2hhckNvZGVBdCgwKSAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMV0gPSB0eXBlLmNoYXJDb2RlQXQoMSkgJiAweGZmO1xuICAgIGRhdGFbcCArIDJdID0gdHlwZS5jaGFyQ29kZUF0KDIpICYgMHhmZjtcbiAgICBkYXRhW3AgKyAzXSA9IHR5cGUuY2hhckNvZGVBdCgzKSAmIDB4ZmY7XG4gICAgcCArPSA0O1xuICAgIGRhdGEuc2V0KGJvZHksIHApO1xuICAgIHAgKz0gYm9keS5sZW5ndGg7XG4gICAgY29uc3QgY3JjID0gY3JjMzIoZGF0YSwgb2Zmc2V0ICsgNCwgcCk7XG4gICAgZGF0YVtwXSA9IGNyYyA+PiAyNCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMV0gPSBjcmMgPj4gMTYgJiAweGZmO1xuICAgIGRhdGFbcCArIDJdID0gY3JjID4+IDggJiAweGZmO1xuICAgIGRhdGFbcCArIDNdID0gY3JjICYgMHhmZjtcbiAgfVxuICBmdW5jdGlvbiBhZGxlcjMyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgYSA9IDE7XG4gICAgbGV0IGIgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBhID0gKGEgKyAoZGF0YVtpXSAmIDB4ZmYpKSAlIDY1NTIxO1xuICAgICAgYiA9IChiICsgYSkgJSA2NTUyMTtcbiAgICB9XG4gICAgcmV0dXJuIGIgPDwgMTYgfCBhO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmxhdGVTeW5jKGxpdGVyYWxzKSB7XG4gICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSA+PSA4ID8gbGl0ZXJhbHMgOiBCdWZmZXIuZnJvbShsaXRlcmFscyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSByZXF1aXJlKFwiemxpYlwiKS5kZWZsYXRlU3luYyhpbnB1dCwge1xuICAgICAgICBsZXZlbDogOVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gb3V0cHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IG91dHB1dCA6IG5ldyBVaW50OEFycmF5KG91dHB1dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiTm90IGNvbXByZXNzaW5nIFBORyBiZWNhdXNlIHpsaWIuZGVmbGF0ZVN5bmMgaXMgdW5hdmFpbGFibGU6IFwiICsgZSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscyk7XG4gIH1cbiAgZnVuY3Rpb24gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpIHtcbiAgICBsZXQgbGVuID0gbGl0ZXJhbHMubGVuZ3RoO1xuICAgIGNvbnN0IG1heEJsb2NrTGVuZ3RoID0gMHhmZmZmO1xuICAgIGNvbnN0IGRlZmxhdGVCbG9ja3MgPSBNYXRoLmNlaWwobGVuIC8gbWF4QmxvY2tMZW5ndGgpO1xuICAgIGNvbnN0IGlkYXQgPSBuZXcgVWludDhBcnJheSgyICsgbGVuICsgZGVmbGF0ZUJsb2NrcyAqIDUgKyA0KTtcbiAgICBsZXQgcGkgPSAwO1xuICAgIGlkYXRbcGkrK10gPSAweDc4O1xuICAgIGlkYXRbcGkrK10gPSAweDljO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIHdoaWxlIChsZW4gPiBtYXhCbG9ja0xlbmd0aCkge1xuICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICBpZGF0W3BpKytdID0gMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcywgcG9zICsgbWF4QmxvY2tMZW5ndGgpLCBwaSk7XG4gICAgICBwaSArPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgIHBvcyArPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgIGxlbiAtPSBtYXhCbG9ja0xlbmd0aDtcbiAgICB9XG4gICAgaWRhdFtwaSsrXSA9IDB4MDE7XG4gICAgaWRhdFtwaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gfmxlbiAmIDB4ZmZmZiAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9ICh+bGVuICYgMHhmZmZmKSA+PiA4ICYgMHhmZjtcbiAgICBpZGF0LnNldChsaXRlcmFscy5zdWJhcnJheShwb3MpLCBwaSk7XG4gICAgcGkgKz0gbGl0ZXJhbHMubGVuZ3RoIC0gcG9zO1xuICAgIGNvbnN0IGFkbGVyID0gYWRsZXIzMihsaXRlcmFscywgMCwgbGl0ZXJhbHMubGVuZ3RoKTtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gMjQgJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAxNiAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDggJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciAmIDB4ZmY7XG4gICAgcmV0dXJuIGlkYXQ7XG4gIH1cbiAgZnVuY3Rpb24gZW5jb2RlKGltZ0RhdGEsIGtpbmQsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGxldCBiaXREZXB0aCwgY29sb3JUeXBlLCBsaW5lU2l6ZTtcbiAgICBjb25zdCBieXRlcyA9IGltZ0RhdGEuZGF0YTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgICBjb2xvclR5cGUgPSAwO1xuICAgICAgICBiaXREZXB0aCA9IDE7XG4gICAgICAgIGxpbmVTaXplID0gd2lkdGggKyA3ID4+IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgICBjb2xvclR5cGUgPSAyO1xuICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgIGxpbmVTaXplID0gd2lkdGggKiAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQkFfMzJCUFA6XG4gICAgICAgIGNvbG9yVHlwZSA9IDY7XG4gICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXRcIik7XG4gICAgfVxuICAgIGNvbnN0IGxpdGVyYWxzID0gbmV3IFVpbnQ4QXJyYXkoKDEgKyBsaW5lU2l6ZSkgKiBoZWlnaHQpO1xuICAgIGxldCBvZmZzZXRMaXRlcmFscyA9IDAsXG4gICAgICBvZmZzZXRCeXRlcyA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gPSAwO1xuICAgICAgbGl0ZXJhbHMuc2V0KGJ5dGVzLnN1YmFycmF5KG9mZnNldEJ5dGVzLCBvZmZzZXRCeXRlcyArIGxpbmVTaXplKSwgb2Zmc2V0TGl0ZXJhbHMpO1xuICAgICAgb2Zmc2V0Qnl0ZXMgKz0gbGluZVNpemU7XG4gICAgICBvZmZzZXRMaXRlcmFscyArPSBsaW5lU2l6ZTtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCAmJiBpc01hc2spIHtcbiAgICAgIG9mZnNldExpdGVyYWxzID0gMDtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgb2Zmc2V0TGl0ZXJhbHMrKztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gXj0gMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpaGRyID0gbmV3IFVpbnQ4QXJyYXkoW3dpZHRoID4+IDI0ICYgMHhmZiwgd2lkdGggPj4gMTYgJiAweGZmLCB3aWR0aCA+PiA4ICYgMHhmZiwgd2lkdGggJiAweGZmLCBoZWlnaHQgPj4gMjQgJiAweGZmLCBoZWlnaHQgPj4gMTYgJiAweGZmLCBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIGJpdERlcHRoLCBjb2xvclR5cGUsIDB4MDAsIDB4MDAsIDB4MDBdKTtcbiAgICBjb25zdCBpZGF0ID0gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpO1xuICAgIGNvbnN0IHBuZ0xlbmd0aCA9IFBOR19IRUFERVIubGVuZ3RoICsgQ0hVTktfV1JBUFBFUl9TSVpFICogMyArIGloZHIubGVuZ3RoICsgaWRhdC5sZW5ndGg7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHBuZ0xlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZGF0YS5zZXQoUE5HX0hFQURFUiwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gUE5HX0hFQURFUi5sZW5ndGg7XG4gICAgd3JpdGVQbmdDaHVuayhcIklIRFJcIiwgaWhkciwgZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gQ0hVTktfV1JBUFBFUl9TSVpFICsgaWhkci5sZW5ndGg7XG4gICAgd3JpdGVQbmdDaHVuayhcIklEQVRBXCIsIGlkYXQsIGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGlkYXQubGVuZ3RoO1xuICAgIHdyaXRlUG5nQ2h1bmsoXCJJRU5EXCIsIG5ldyBVaW50OEFycmF5KDApLCBkYXRhLCBvZmZzZXQpO1xuICAgIHJldHVybiBjcmVhdGVPYmplY3RVUkwoZGF0YSwgXCJpbWFnZS9wbmdcIiwgZm9yY2VEYXRhU2NoZW1hKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgIGNvbnN0IGtpbmQgPSBpbWdEYXRhLmtpbmQgPT09IHVuZGVmaW5lZCA/IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCA6IGltZ0RhdGEua2luZDtcbiAgICByZXR1cm4gZW5jb2RlKGltZ0RhdGEsIGtpbmQsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKTtcbiAgfTtcbn0oKTtcbmNsYXNzIFNWR0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0O1xuICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgIHRoaXMudGV4dFJlbmRlcmluZ01vZGUgPSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFNWR19ERUZBVUxUUy5maWxsQ29sb3I7XG4gICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5saW5lSm9pbiA9IFwiXCI7XG4gICAgdGhpcy5saW5lQ2FwID0gXCJcIjtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSAwO1xuICAgIHRoaXMuZGFzaEFycmF5ID0gW107XG4gICAgdGhpcy5kYXNoUGhhc2UgPSAwO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgdGhpcy5hY3RpdmVDbGlwVXJsID0gbnVsbDtcbiAgICB0aGlzLmNsaXBHcm91cCA9IG51bGw7XG4gICAgdGhpcy5tYXNrSWQgPSBcIlwiO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5mdW5jdGlvbiBvcExpc3RUb1RyZWUob3BMaXN0KSB7XG4gIGxldCBvcFRyZWUgPSBbXTtcbiAgY29uc3QgdG1wID0gW107XG4gIGZvciAoY29uc3Qgb3BMaXN0RWxlbWVudCBvZiBvcExpc3QpIHtcbiAgICBpZiAob3BMaXN0RWxlbWVudC5mbiA9PT0gXCJzYXZlXCIpIHtcbiAgICAgIG9wVHJlZS5wdXNoKHtcbiAgICAgICAgZm5JZDogOTIsXG4gICAgICAgIGZuOiBcImdyb3VwXCIsXG4gICAgICAgIGl0ZW1zOiBbXVxuICAgICAgfSk7XG4gICAgICB0bXAucHVzaChvcFRyZWUpO1xuICAgICAgb3BUcmVlID0gb3BUcmVlLmF0KC0xKS5pdGVtcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAob3BMaXN0RWxlbWVudC5mbiA9PT0gXCJyZXN0b3JlXCIpIHtcbiAgICAgIG9wVHJlZSA9IHRtcC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BUcmVlLnB1c2gob3BMaXN0RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcFRyZWU7XG59XG5mdW5jdGlvbiBwZih2YWx1ZSkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBjb25zdCBzID0gdmFsdWUudG9GaXhlZCgxMCk7XG4gIGxldCBpID0gcy5sZW5ndGggLSAxO1xuICBpZiAoc1tpXSAhPT0gXCIwXCIpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuICBkbyB7XG4gICAgaS0tO1xuICB9IHdoaWxlIChzW2ldID09PSBcIjBcIik7XG4gIHJldHVybiBzLnN1YnN0cmluZygwLCBzW2ldID09PSBcIi5cIiA/IGkgOiBpICsgMSk7XG59XG5mdW5jdGlvbiBwbShtKSB7XG4gIGlmIChtWzRdID09PSAwICYmIG1bNV0gPT09IDApIHtcbiAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICBpZiAobVswXSA9PT0gMSAmJiBtWzNdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBzY2FsZSgke3BmKG1bMF0pfSAke3BmKG1bM10pfSlgO1xuICAgIH1cbiAgICBpZiAobVswXSA9PT0gbVszXSAmJiBtWzFdID09PSAtbVsyXSkge1xuICAgICAgY29uc3QgYSA9IE1hdGguYWNvcyhtWzBdKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gYHJvdGF0ZSgke3BmKGEpfSlgO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtWzBdID09PSAxICYmIG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCAmJiBtWzNdID09PSAxKSB7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtwZihtWzRdKX0gJHtwZihtWzVdKX0pYDtcbiAgfVxuICByZXR1cm4gYG1hdHJpeCgke3BmKG1bMF0pfSAke3BmKG1bMV0pfSAke3BmKG1bMl0pfSAke3BmKG1bM10pfSAke3BmKG1bNF0pfSBgICsgYCR7cGYobVs1XSl9KWA7XG59XG5sZXQgY2xpcENvdW50ID0gMDtcbmxldCBtYXNrQ291bnQgPSAwO1xubGV0IHNoYWRpbmdDb3VudCA9IDA7XG5jbGFzcyBTVkdHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNvbW1vbk9ianMsIG9ianMsIGZvcmNlRGF0YVNjaGVtYSA9IGZhbHNlKSB7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiVGhlIFNWRyBiYWNrLWVuZCBpcyBubyBsb25nZXIgbWFpbnRhaW5lZCBhbmQgKm1heSogYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpO1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBTVkdFeHRyYVN0YXRlKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZXh0cmFTdGFjayA9IFtdO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmVtYmVkRm9udHMgPSBmYWxzZTtcbiAgICB0aGlzLmVtYmVkZGVkRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY3NzU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuZm9yY2VEYXRhU2NoZW1hID0gISFmb3JjZURhdGFTY2hlbWE7XG4gICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wIGluIF91dGlsLk9QUykge1xuICAgICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmdbX3V0aWwuT1BTW29wXV0gPSBvcDtcbiAgICB9XG4gIH1cbiAgZ2V0T2JqZWN0KGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBzYXZlKCkge1xuICAgIHRoaXMudHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuZXh0cmFTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gIH1cbiAgcmVzdG9yZSgpIHtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5leHRyYVN0YWNrLnBvcCgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMudGdycCA9IG51bGw7XG4gIH1cbiAgZ3JvdXAoaXRlbXMpIHtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICB0aGlzLmV4ZWN1dGVPcFRyZWUoaXRlbXMpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIGxvYWREZXBlbmRlbmNpZXMob3BlcmF0b3JMaXN0KSB7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoZm5BcnJheVtpXSAhPT0gX3V0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG9iaiBvZiBhcmdzQXJyYXlbaV0pIHtcbiAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBvYmouc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzIDogdGhpcy5vYmpzO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgb2Jqc1Bvb2wuZ2V0KG9iaiwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnJlbnQuZGVwZW5kZW5jaWVzLnB1c2gocHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmN1cnJlbnQuZGVwZW5kZW5jaWVzKTtcbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtTWF0cml4LCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgIHRoaXMudGdycCA9IG51bGw7XG4gIH1cbiAgZ2V0U1ZHKG9wZXJhdG9yTGlzdCwgdmlld3BvcnQpIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuX2luaXRpYWxpemUodmlld3BvcnQpO1xuICAgIHJldHVybiB0aGlzLmxvYWREZXBlbmRlbmNpZXMob3BlcmF0b3JMaXN0KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy5leGVjdXRlT3BUcmVlKHRoaXMuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcbiAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSB7XG4gICAgY29uc3Qgb3BlcmF0b3JJZE1hcHBpbmcgPSB0aGlzLl9vcGVyYXRvcklkTWFwcGluZztcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBjb25zdCBvcExpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgb3BMaXN0LnB1c2goe1xuICAgICAgICBmbklkLFxuICAgICAgICBmbjogb3BlcmF0b3JJZE1hcHBpbmdbZm5JZF0sXG4gICAgICAgIGFyZ3M6IGFyZ3NBcnJheVtpXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcExpc3RUb1RyZWUob3BMaXN0KTtcbiAgfVxuICBleGVjdXRlT3BUcmVlKG9wVHJlZSkge1xuICAgIGZvciAoY29uc3Qgb3BUcmVlRWxlbWVudCBvZiBvcFRyZWUpIHtcbiAgICAgIGNvbnN0IGZuID0gb3BUcmVlRWxlbWVudC5mbjtcbiAgICAgIGNvbnN0IGZuSWQgPSBvcFRyZWVFbGVtZW50LmZuSWQ7XG4gICAgICBjb25zdCBhcmdzID0gb3BUcmVlRWxlbWVudC5hcmdzO1xuICAgICAgc3dpdGNoIChmbklkIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5iZWdpblRleHQ6XG4gICAgICAgICAgdGhpcy5iZWdpblRleHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZGVwZW5kZW5jeTpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZzpcbiAgICAgICAgICB0aGlzLnNldExlYWRpbmcoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmdNb3ZlVGV4dDpcbiAgICAgICAgICB0aGlzLnNldExlYWRpbmdNb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Rm9udDpcbiAgICAgICAgICB0aGlzLnNldEZvbnQoYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNob3dUZXh0OlxuICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNob3dTcGFjZWRUZXh0OlxuICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVuZFRleHQ6XG4gICAgICAgICAgdGhpcy5lbmRUZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUZXh0OlxuICAgICAgICAgIHRoaXMubW92ZVRleHQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldENoYXJTcGFjaW5nOlxuICAgICAgICAgIHRoaXMuc2V0Q2hhclNwYWNpbmcoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFdvcmRTcGFjaW5nOlxuICAgICAgICAgIHRoaXMuc2V0V29yZFNwYWNpbmcoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEhTY2FsZTpcbiAgICAgICAgICB0aGlzLnNldEhTY2FsZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dE1hdHJpeDpcbiAgICAgICAgICB0aGlzLnNldFRleHRNYXRyaXgoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRSaXNlOlxuICAgICAgICAgIHRoaXMuc2V0VGV4dFJpc2UoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRSZW5kZXJpbmdNb2RlOlxuICAgICAgICAgIHRoaXMuc2V0VGV4dFJlbmRlcmluZ01vZGUoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVXaWR0aDpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZUpvaW46XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbihhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZUNhcDpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldE1pdGVyTGltaXQ6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsUkdCQ29sb3I6XG4gICAgICAgICAgdGhpcy5zZXRGaWxsUkdCQ29sb3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFN0cm9rZVJHQkNvbG9yOlxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlUkdCQ29sb3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFN0cm9rZUNvbG9yTjpcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZUNvbG9yTihhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmlsbENvbG9yTjpcbiAgICAgICAgICB0aGlzLnNldEZpbGxDb2xvck4oYXJncyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNoYWRpbmdGaWxsOlxuICAgICAgICAgIHRoaXMuc2hhZGluZ0ZpbGwoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldERhc2g6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRSZW5kZXJpbmdJbnRlbnQ6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZsYXRuZXNzOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3MoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEdTdGF0ZTpcbiAgICAgICAgICB0aGlzLnNldEdTdGF0ZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZmlsbDpcbiAgICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9GaWxsOlxuICAgICAgICAgIHRoaXMuZW9GaWxsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnN0cm9rZTpcbiAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsU3Ryb2tlOlxuICAgICAgICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xpcDpcbiAgICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0NsaXA6XG4gICAgICAgICAgdGhpcy5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOlxuICAgICAgICAgIHRoaXMucGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW1hZ2VYT2JqZWN0OlxuICAgICAgICAgIHRoaXMucGFpbnRJbWFnZVhPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OlxuICAgICAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdDpcbiAgICAgICAgICB0aGlzLnBhaW50SW1hZ2VNYXNrWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRGb3JtWE9iamVjdEJlZ2luOlxuICAgICAgICAgIHRoaXMucGFpbnRGb3JtWE9iamVjdEJlZ2luKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0RW5kOlxuICAgICAgICAgIHRoaXMucGFpbnRGb3JtWE9iamVjdEVuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VTdHJva2U6XG4gICAgICAgICAgdGhpcy5jbG9zZVN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5jbG9zZUZpbGxTdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VFT0ZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5jbG9zZUVPRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5uZXh0TGluZTpcbiAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnRyYW5zZm9ybTpcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY29uc3RydWN0UGF0aDpcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdFBhdGgoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVuZFBhdGg6XG4gICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgdGhpcy5ncm91cChvcFRyZWVFbGVtZW50Lml0ZW1zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYFVuaW1wbGVtZW50ZWQgb3BlcmF0b3IgJHtmbn1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcod29yZFNwYWNpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSB3b3JkU3BhY2luZztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhjaGFyU3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IGNoYXJTcGFjaW5nO1xuICB9XG4gIG5leHRMaW5lKCkge1xuICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICB9XG4gIHNldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC50ZXh0TWF0cml4ID0gY3VycmVudC5saW5lTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudC5hcHBlbmQoY3VycmVudC50c3Bhbik7XG4gIH1cbiAgYmVnaW5UZXh0KCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gICAgY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGN1cnJlbnQubGluZU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgY3VycmVudC50eHRncnAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICB9XG4gIG1vdmVUZXh0KHgsIHkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggKz0geDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZICs9IHk7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gIH1cbiAgc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgIGxldCB4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgaWYgKGdseXBoID09PSBudWxsKSB7XG4gICAgICAgIHggKz0gZm9udERpcmVjdGlvbiAqIHdvcmRTcGFjaW5nO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBsZXQgdng7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgdnggPSBnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41O1xuICAgICAgICB2eCA9IC12eCAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgc2NhbGVkWCA9IHZ4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlZFggPSB4IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkge1xuICAgICAgICBjdXJyZW50Lnhjb29yZHMucHVzaChjdXJyZW50LnggKyBzY2FsZWRYKTtcbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgY3VycmVudC55Y29vcmRzLnB1c2goLWN1cnJlbnQueSArIHNjYWxlZFkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudHNwYW4udGV4dENvbnRlbnQgKz0gY2hhcmFjdGVyO1xuICAgICAgfSBlbHNlIHt9XG4gICAgICBjb25zdCBjaGFyV2lkdGggPSB2ZXJ0aWNhbCA/IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbiA6IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgIH1cbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBjdXJyZW50Lnhjb29yZHMubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBjdXJyZW50Lnljb29yZHMubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICBjdXJyZW50LnkgLT0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgaWYgKGN1cnJlbnQuZm9udFN0eWxlICE9PSBTVkdfREVGQVVMVFMuZm9udFN0eWxlKSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zdHlsZVwiLCBjdXJyZW50LmZvbnRTdHlsZSk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmZvbnRXZWlnaHQgIT09IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0KSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC13ZWlnaHRcIiwgY3VycmVudC5mb250V2VpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICBpZiAoY3VycmVudC5maWxsQ29sb3IgIT09IFNWR19ERUZBVUxUUy5maWxsQ29sb3IpIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgY3VycmVudC5maWxsQ29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIGN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIKSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgfVxuICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgY29uc3QgbGluZVdpZHRoU2NhbGUgPSAxIC8gKGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlIHx8IDEpO1xuICAgICAgdGhpcy5fc2V0U3Ryb2tlQXR0cmlidXRlcyhjdXJyZW50LnRzcGFuLCBsaW5lV2lkdGhTY2FsZSk7XG4gICAgfVxuICAgIGxldCB0ZXh0TWF0cml4ID0gY3VycmVudC50ZXh0TWF0cml4O1xuICAgIGlmIChjdXJyZW50LnRleHRSaXNlICE9PSAwKSB7XG4gICAgICB0ZXh0TWF0cml4ID0gdGV4dE1hdHJpeC5zbGljZSgpO1xuICAgICAgdGV4dE1hdHJpeFs1XSArPSBjdXJyZW50LnRleHRSaXNlO1xuICAgIH1cbiAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgYCR7cG0odGV4dE1hdHJpeCl9IHNjYWxlKCR7cGYodGV4dEhTY2FsZSl9LCAtMSlgKTtcbiAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMoWE1MX05TLCBcInhtbDpzcGFjZVwiLCBcInByZXNlcnZlXCIpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudC5hcHBlbmQoY3VycmVudC50c3Bhbik7XG4gICAgY3VycmVudC50eHRncnAuYXBwZW5kKGN1cnJlbnQudHh0RWxlbWVudCk7XG4gICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoY3VycmVudC50eHRFbGVtZW50KTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgfVxuICBhZGRGb250U3R5bGUoZm9udE9iaikge1xuICAgIGlmICghZm9udE9iai5kYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRGb250U3R5bGU6IE5vIGZvbnQgZGF0YSBhdmFpbGFibGUsIFwiICsgJ2Vuc3VyZSB0aGF0IHRoZSBcImZvbnRFeHRyYVByb3BlcnRpZXNcIiBBUEkgcGFyYW1ldGVyIGlzIHNldC4nKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNzc1N0eWxlKSB7XG4gICAgICB0aGlzLmNzc1N0eWxlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6c3R5bGVcIik7XG4gICAgICB0aGlzLmNzc1N0eWxlLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuICAgICAgdGhpcy5kZWZzLmFwcGVuZCh0aGlzLmNzc1N0eWxlKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gY3JlYXRlT2JqZWN0VVJMKGZvbnRPYmouZGF0YSwgZm9udE9iai5taW1ldHlwZSwgdGhpcy5mb3JjZURhdGFTY2hlbWEpO1xuICAgIHRoaXMuY3NzU3R5bGUudGV4dENvbnRlbnQgKz0gYEBmb250LWZhY2UgeyBmb250LWZhbWlseTogXCIke2ZvbnRPYmoubG9hZGVkTmFtZX1cIjtgICsgYCBzcmM6IHVybCgke3VybH0pOyB9XFxuYDtcbiAgfVxuICBzZXRGb250KGRldGFpbHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGRldGFpbHNbMF0pO1xuICAgIGxldCBzaXplID0gZGV0YWlsc1sxXTtcbiAgICBjdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIGlmICh0aGlzLmVtYmVkRm9udHMgJiYgIWZvbnRPYmoubWlzc2luZ0ZpbGUgJiYgIXRoaXMuZW1iZWRkZWRGb250c1tmb250T2JqLmxvYWRlZE5hbWVdKSB7XG4gICAgICB0aGlzLmFkZEZvbnRTdHlsZShmb250T2JqKTtcbiAgICAgIHRoaXMuZW1iZWRkZWRGb250c1tmb250T2JqLmxvYWRlZE5hbWVdID0gZm9udE9iajtcbiAgICB9XG4gICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBjdXJyZW50LmZvbnRGYW1pbHkgPSBmb250T2JqLmxvYWRlZE5hbWU7XG4gICAgY3VycmVudC5mb250V2VpZ2h0ID0gYm9sZDtcbiAgICBjdXJyZW50LmZvbnRTdHlsZSA9IGl0YWxpYztcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICB9XG4gIGVuZFRleHQoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcgJiYgY3VycmVudC50eHRFbGVtZW50Py5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIGN1cnJlbnQuZWxlbWVudCA9IGN1cnJlbnQudHh0RWxlbWVudDtcbiAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldExpbmVKb2luKHN0eWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3VycmVudC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0U3Ryb2tlQWxwaGEoc3Ryb2tlQWxwaGEpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdHJva2VBbHBoYTtcbiAgfVxuICBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gIH1cbiAgc2V0RmlsbEFscGhhKGZpbGxBbHBoYSkge1xuICAgIHRoaXMuY3VycmVudC5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgdGhpcy5jdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgdGhpcy5jdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICB9XG4gIHNldFN0cm9rZUNvbG9yTihhcmdzKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oYXJncykge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gIH1cbiAgc2hhZGluZ0ZpbGwoYXJncykge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQ7XG4gICAgY29uc3QgaW52ID0gX3V0aWwuVXRpbC5pbnZlcnNlVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIGludik7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeDApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgeDEgLSB4MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB5MSAtIHkwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncykpO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCB0aGlzLmN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQocmVjdCk7XG4gIH1cbiAgX21ha2VDb2xvck5fUGF0dGVybihhcmdzKSB7XG4gICAgaWYgKGFyZ3NbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVRpbGluZ1BhdHRlcm4oYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncyk7XG4gIH1cbiAgX21ha2VUaWxpbmdQYXR0ZXJuKGFyZ3MpIHtcbiAgICBjb25zdCBjb2xvciA9IGFyZ3NbMV07XG4gICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gYXJnc1syXTtcbiAgICBjb25zdCBtYXRyaXggPSBhcmdzWzNdIHx8IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gYXJnc1s0XTtcbiAgICBjb25zdCB4c3RlcCA9IGFyZ3NbNV07XG4gICAgY29uc3QgeXN0ZXAgPSBhcmdzWzZdO1xuICAgIGNvbnN0IHBhaW50VHlwZSA9IGFyZ3NbN107XG4gICAgY29uc3QgdGlsaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcbiAgICBjb25zdCBbdHgwLCB0eTAsIHR4MSwgdHkxXSA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbLi4uX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDAsIHkwXSwgbWF0cml4KSwgLi4uX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDEsIHkxXSwgbWF0cml4KV0pO1xuICAgIGNvbnN0IFt4c2NhbGUsIHlzY2FsZV0gPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG1hdHJpeCk7XG4gICAgY29uc3QgdHhzdGVwID0geHN0ZXAgKiB4c2NhbGU7XG4gICAgY29uc3QgdHlzdGVwID0geXN0ZXAgKiB5c2NhbGU7XG4gICAgY29uc3QgdGlsaW5nID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cGF0dGVyblwiKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCB0aWxpbmdJZCk7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgdHhzdGVwKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgdHlzdGVwKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGAke3R4MH1gKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGAke3R5MH1gKTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2ZztcbiAgICBjb25zdCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybU1hdHJpeDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHR4MSAtIHR4MCwgdHkxIC0gdHkwKTtcbiAgICB0aGlzLnN2ZyA9IGJib3g7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXg7XG4gICAgaWYgKHBhaW50VHlwZSA9PT0gMikge1xuICAgICAgY29uc3QgY3NzQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvcik7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRlT3BUcmVlKHRoaXMuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcbiAgICB0aGlzLnN2ZyA9IHN2ZztcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeDtcbiAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gZmlsbENvbG9yO1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yO1xuICAgIHRpbGluZy5hcHBlbmQoYmJveC5jaGlsZE5vZGVzWzBdKTtcbiAgICB0aGlzLmRlZnMuYXBwZW5kKHRpbGluZyk7XG4gICAgcmV0dXJuIGB1cmwoIyR7dGlsaW5nSWR9KWA7XG4gIH1cbiAgX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBhcmdzID0gdGhpcy5vYmpzLmdldChhcmdzKTtcbiAgICB9XG4gICAgc3dpdGNoIChhcmdzWzBdKSB7XG4gICAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgICAgY29uc3Qgc2hhZGluZ0lkID0gYHNoYWRpbmcke3NoYWRpbmdDb3VudCsrfWA7XG4gICAgICAgIGNvbnN0IGNvbG9yU3RvcHMgPSBhcmdzWzNdO1xuICAgICAgICBsZXQgZ3JhZGllbnQ7XG4gICAgICAgIHN3aXRjaCAoYXJnc1sxXSkge1xuICAgICAgICAgIGNhc2UgXCJheGlhbFwiOlxuICAgICAgICAgICAgY29uc3QgcG9pbnQwID0gYXJnc1s0XTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50MSA9IGFyZ3NbNV07XG4gICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVhckdyYWRpZW50XCIpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBzaGFkaW5nSWQpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIngxXCIsIHBvaW50MFswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInkxXCIsIHBvaW50MFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIngyXCIsIHBvaW50MVswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInkyXCIsIHBvaW50MVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmFkaWFsXCI6XG4gICAgICAgICAgICBjb25zdCBmb2NhbFBvaW50ID0gYXJnc1s0XTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZVBvaW50ID0gYXJnc1s1XTtcbiAgICAgICAgICAgIGNvbnN0IGZvY2FsUmFkaXVzID0gYXJnc1s2XTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IGFyZ3NbN107XG4gICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJhZGlhbEdyYWRpZW50XCIpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBzaGFkaW5nSWQpO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN4XCIsIGNpcmNsZVBvaW50WzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgY2lyY2xlUG9pbnRbMV0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZ4XCIsIGZvY2FsUG9pbnRbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeVwiLCBmb2NhbFBvaW50WzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnJcIiwgZm9jYWxSYWRpdXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBSYWRpYWxBeGlhbCB0eXBlOiAke2FyZ3NbMV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjb2xvclN0b3Agb2YgY29sb3JTdG9wcykge1xuICAgICAgICAgIGNvbnN0IHN0b3AgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdG9wXCIpO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJvZmZzZXRcIiwgY29sb3JTdG9wWzBdKTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3RvcC1jb2xvclwiLCBjb2xvclN0b3BbMV0pO1xuICAgICAgICAgIGdyYWRpZW50LmFwcGVuZChzdG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZnMuYXBwZW5kKGdyYWRpZW50KTtcbiAgICAgICAgcmV0dXJuIGB1cmwoIyR7c2hhZGluZ0lkfSlgO1xuICAgICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBwYXR0ZXJuIE1lc2hcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke2FyZ3NbMF19YCk7XG4gICAgfVxuICB9XG4gIHNldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQuZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICAgIHRoaXMuY3VycmVudC5kYXNoUGhhc2UgPSBkYXNoUGhhc2U7XG4gIH1cbiAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgZCA9IFtdO1xuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3dpdGNoIChvcCB8IDApIHtcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGQucHVzaChcIk1cIiwgcGYoeCksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5KSwgXCJMXCIsIHBmKHh3KSwgcGYoeWgpLCBcIkxcIiwgcGYoeCksIHBmKHloKSwgXCJaXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGQucHVzaChcIk1cIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubGluZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBkLnB1c2goXCJMXCIsIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKGFyZ3NbaiArIDJdKSwgcGYoYXJnc1tqICsgM10pLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZih4KSwgcGYoeSksIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKGFyZ3NbaiArIDJdKSwgcGYoYXJnc1tqICsgM10pKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKHgpLCBwZih5KSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBkLnB1c2goXCJaXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBkID0gZC5qb2luKFwiIFwiKTtcbiAgICBpZiAoY3VycmVudC5wYXRoICYmIG9wcy5sZW5ndGggPiAwICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLnJlY3RhbmdsZSAmJiBvcHNbMF0gIT09IF91dGlsLk9QUy5tb3ZlVG8pIHtcbiAgICAgIGQgPSBjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpICsgZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cGF0aFwiKTtcbiAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKGN1cnJlbnQucGF0aCk7XG4gICAgfVxuICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgZCk7XG4gICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC5wYXRoO1xuICAgIGN1cnJlbnQuc2V0Q3VycmVudFBvaW50KHgsIHkpO1xuICB9XG4gIGVuZFBhdGgoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnBhdGggPSBudWxsO1xuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsaXBJZCA9IGBjbGlwcGF0aCR7Y2xpcENvdW50Kyt9YDtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmNsaXBQYXRoXCIpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgY2xpcElkKTtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuICAgIGNvbnN0IGNsaXBFbGVtZW50ID0gY3VycmVudC5lbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gXCJldmVub2RkXCIpIHtcbiAgICAgIGNsaXBFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICBjbGlwUGF0aC5hcHBlbmQoY2xpcEVsZW1lbnQpO1xuICAgIHRoaXMuZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGlmIChjdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgIGN1cnJlbnQuY2xpcEdyb3VwID0gbnVsbDtcbiAgICAgIGZvciAoY29uc3QgcHJldiBvZiB0aGlzLmV4dHJhU3RhY2spIHtcbiAgICAgICAgcHJldi5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXBhdGhcIiwgY3VycmVudC5hY3RpdmVDbGlwVXJsKTtcbiAgICB9XG4gICAgY3VycmVudC5hY3RpdmVDbGlwVXJsID0gYHVybCgjJHtjbGlwSWR9KWA7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBjbGlwKHR5cGUpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gdHlwZTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC5wYXRoKSB7XG4gICAgICBjb25zdCBkID0gYCR7Y3VycmVudC5wYXRoLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiKX1aYDtcbiAgICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgZCk7XG4gICAgfVxuICB9XG4gIHNldExlYWRpbmcobGVhZGluZykge1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0VGV4dFJpc2UodGV4dFJpc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSB0ZXh0UmlzZTtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZSh0ZXh0UmVuZGVyaW5nTW9kZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlO1xuICB9XG4gIHNldEhTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VBbHBoYSh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuc2V0RmlsbEFscGhhKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYFVuaW1wbGVtZW50ZWQgZ3JhcGhpYyBzdGF0ZSBvcGVyYXRvciAke2tleX1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmlsbCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgY3VycmVudC5maWxsQ29sb3IpO1xuICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIGN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzdHJva2UoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC5lbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQuZWxlbWVudCk7XG4gICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBfc2V0U3Ryb2tlQXR0cmlidXRlcyhlbGVtZW50LCBsaW5lV2lkdGhTY2FsZSA9IDEpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCBkYXNoQXJyYXkgPSBjdXJyZW50LmRhc2hBcnJheTtcbiAgICBpZiAobGluZVdpZHRoU2NhbGUgIT09IDEgJiYgZGFzaEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGRhc2hBcnJheSA9IGRhc2hBcnJheS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsaW5lV2lkdGhTY2FsZSAqIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2VcIiwgY3VycmVudC5zdHJva2VDb2xvcik7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1vcGFjaXR5XCIsIGN1cnJlbnQuc3Ryb2tlQWxwaGEpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCBwZihjdXJyZW50Lm1pdGVyTGltaXQpKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWxpbmVjYXBcIiwgY3VycmVudC5saW5lQ2FwKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWxpbmVqb2luXCIsIGN1cnJlbnQubGluZUpvaW4pO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utd2lkdGhcIiwgcGYobGluZVdpZHRoU2NhbGUgKiBjdXJyZW50LmxpbmVXaWR0aCkgKyBcInB4XCIpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaGFycmF5XCIsIGRhc2hBcnJheS5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgcGYobGluZVdpZHRoU2NhbGUgKiBjdXJyZW50LmRhc2hQaGFzZSkgKyBcInB4XCIpO1xuICB9XG4gIGVvRmlsbCgpIHtcbiAgICB0aGlzLmN1cnJlbnQuZWxlbWVudD8uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgICB0aGlzLmZpbGwoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jdXJyZW50LmVsZW1lbnQ/LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZVN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmVvRmlsbFN0cm9rZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBcIjFweFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIFwiMXB4XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuY3VycmVudC5maWxsQ29sb3IpO1xuICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKHJlY3QpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgRGVwZW5kZW50IGltYWdlIHdpdGggb2JqZWN0IElEICR7b2JqSWR9IGlzIG5vdCByZWFkeSB5ZXRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhLCBtYXNrKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGltZ1NyYyA9IGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgdGhpcy5mb3JjZURhdGFTY2hlbWEsICEhbWFzayk7XG4gICAgY29uc3QgY2xpcHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgIGNvbnN0IGltZ0VsID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6aW1hZ2VcIik7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIFwieGxpbms6aHJlZlwiLCBpbWdTcmMpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1oZWlnaHQpKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSArIFwicHhcIik7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSArIFwicHhcIik7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgYHNjYWxlKCR7cGYoMSAvIHdpZHRoKX0gJHtwZigtMSAvIGhlaWdodCl9KWApO1xuICAgIGlmIChtYXNrKSB7XG4gICAgICBtYXNrLmFwcGVuZChpbWdFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKGltZ0VsKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KGltZykge1xuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcInBhaW50SW1hZ2VNYXNrWE9iamVjdDogSW1hZ2VCaXRtYXAgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQsIFwiICsgXCJlbnN1cmUgdGhhdCB0aGUgYGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkYCBBUEkgcGFyYW1ldGVyIGlzIGRpc2FibGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgZmlsbENvbG9yID0gY3VycmVudC5maWxsQ29sb3I7XG4gICAgY3VycmVudC5tYXNrSWQgPSBgbWFzayR7bWFza0NvdW50Kyt9YDtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bWFza1wiKTtcbiAgICBtYXNrLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgY3VycmVudC5tYXNrSWQpO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBmaWxsQ29sb3IpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJtYXNrXCIsIGB1cmwoIyR7Y3VycmVudC5tYXNrSWR9KWApO1xuICAgIHRoaXMuZGVmcy5hcHBlbmQobWFzayk7XG4gICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQocmVjdCk7XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhLCBtYXNrKTtcbiAgfVxuICBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgIGNvbnN0IGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBiYm94WzBdKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBiYm94WzFdKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHt9XG4gIF9pbml0aWFsaXplKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZpbml0aW9ucyk7XG4gICAgdGhpcy5kZWZzID0gZGVmaW5pdGlvbnM7XG4gICAgY29uc3Qgcm9vdEdyb3VwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICByb290R3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odmlld3BvcnQudHJhbnNmb3JtKSk7XG4gICAgc3ZnLmFwcGVuZChyb290R3JvdXApO1xuICAgIHRoaXMuc3ZnID0gcm9vdEdyb3VwO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgX2Vuc3VyZUNsaXBHcm91cCgpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudC5jbGlwR3JvdXApIHtcbiAgICAgIGNvbnN0IGNsaXBHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICBjbGlwR3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXBhdGhcIiwgdGhpcy5jdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgICAgdGhpcy5zdmcuYXBwZW5kKGNsaXBHcm91cCk7XG4gICAgICB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwID0gY2xpcEdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50LmNsaXBHcm91cDtcbiAgfVxuICBfZW5zdXJlVHJhbnNmb3JtR3JvdXAoKSB7XG4gICAgaWYgKCF0aGlzLnRncnApIHtcbiAgICAgIHRoaXMudGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICB0aGlzLnRncnAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odGhpcy50cmFuc2Zvcm1NYXRyaXgpKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVDbGlwR3JvdXAoKS5hcHBlbmQodGhpcy50Z3JwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ZnLmFwcGVuZCh0aGlzLnRncnApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50Z3JwO1xuICB9XG59XG5leHBvcnRzLlNWR0dyYXBoaWNzID0gU1ZHR3JhcGhpY3M7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuWGZhVGV4dCA9IHZvaWQgMDtcbmNsYXNzIFhmYVRleHQge1xuICBzdGF0aWMgdGV4dENvbnRlbnQoeGZhKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBpdGVtcyxcbiAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0ciA9IG51bGw7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICghWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChub2RlPy5hdHRyaWJ1dGVzPy50ZXh0Q29udGVudCkge1xuICAgICAgICBzdHIgPSBub2RlLmF0dHJpYnV0ZXMudGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgc3RyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2Fsayh4ZmEpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgc3RhdGljIHNob3VsZEJ1aWxkVGV4dChuYW1lKSB7XG4gICAgcmV0dXJuICEobmFtZSA9PT0gXCJ0ZXh0YXJlYVwiIHx8IG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcIm9wdGlvblwiIHx8IG5hbWUgPT09IFwic2VsZWN0XCIpO1xuICB9XG59XG5leHBvcnRzLlhmYVRleHQgPSBYZmFUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlRleHRMYXllclJlbmRlclRhc2sgPSB2b2lkIDA7XG5leHBvcnRzLnJlbmRlclRleHRMYXllciA9IHJlbmRlclRleHRMYXllcjtcbmV4cG9ydHMudXBkYXRlVGV4dExheWVyID0gdXBkYXRlVGV4dExheWVyO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5jb25zdCBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiA9IDEwMDAwMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gMzA7XG5jb25zdCBERUZBVUxUX0ZPTlRfQVNDRU5UID0gMC44O1xuY29uc3QgYXNjZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDdHgoc2l6ZSwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpIHtcbiAgbGV0IGN0eDtcbiAgaWYgKGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkICYmIF91dGlsLkZlYXR1cmVUZXN0LmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gICAgY3R4ID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhzaXplLCBzaXplKS5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiBnZXRBc2NlbnQoZm9udEZhbWlseSwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpIHtcbiAgY29uc3QgY2FjaGVkQXNjZW50ID0gYXNjZW50Q2FjaGUuZ2V0KGZvbnRGYW1pbHkpO1xuICBpZiAoY2FjaGVkQXNjZW50KSB7XG4gICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgfVxuICBjb25zdCBjdHggPSBnZXRDdHgoREVGQVVMVF9GT05UX1NJWkUsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKTtcbiAgY3R4LmZvbnQgPSBgJHtERUZBVUxUX0ZPTlRfU0laRX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgbGV0IGFzY2VudCA9IG1ldHJpY3MuZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICBsZXQgZGVzY2VudCA9IE1hdGguYWJzKG1ldHJpY3MuZm9udEJvdW5kaW5nQm94RGVzY2VudCk7XG4gIGlmIChhc2NlbnQpIHtcbiAgICBjb25zdCByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgY3R4LnN0cm9rZVRleHQoXCJnXCIsIDAsIDApO1xuICBsZXQgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gIGRlc2NlbnQgPSAwO1xuICBmb3IgKGxldCBpID0gcGl4ZWxzLmxlbmd0aCAtIDEgLSAzOyBpID49IDA7IGkgLT0gNCkge1xuICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICBkZXNjZW50ID0gTWF0aC5jZWlsKGkgLyA0IC8gREVGQVVMVF9GT05UX1NJWkUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgY3R4LnN0cm9rZVRleHQoXCJBXCIsIDAsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gIGFzY2VudCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgIGFzY2VudCA9IERFRkFVTFRfRk9OVF9TSVpFIC0gTWF0aC5mbG9vcihpIC8gNCAvIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICBpZiAoYXNjZW50KSB7XG4gICAgY29uc3QgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbiAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIERFRkFVTFRfRk9OVF9BU0NFTlQpO1xuICByZXR1cm4gREVGQVVMVF9GT05UX0FTQ0VOVDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGFzaywgZ2VvbSwgc3R5bGVzKSB7XG4gIGNvbnN0IHRleHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgYW5nbGU6IDAsXG4gICAgY2FudmFzV2lkdGg6IDAsXG4gICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICBmb250U2l6ZTogMFxuICB9O1xuICB0YXNrLl90ZXh0RGl2cy5wdXNoKHRleHREaXYpO1xuICBjb25zdCB0eCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKHRhc2suX3RyYW5zZm9ybSwgZ2VvbS50cmFuc2Zvcm0pO1xuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVzW2dlb20uZm9udE5hbWVdO1xuICBpZiAoc3R5bGUudmVydGljYWwpIHtcbiAgICBhbmdsZSArPSBNYXRoLlBJIC8gMjtcbiAgfVxuICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICBjb25zdCBmb250QXNjZW50ID0gZm9udEhlaWdodCAqIGdldEFzY2VudChzdHlsZS5mb250RmFtaWx5LCB0YXNrLl9pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gIGxldCBsZWZ0LCB0b3A7XG4gIGlmIChhbmdsZSA9PT0gMCkge1xuICAgIGxlZnQgPSB0eFs0XTtcbiAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gIH1cbiAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tc2NhbGUtZmFjdG9yKSpcIjtcbiAgY29uc3QgZGl2U3R5bGUgPSB0ZXh0RGl2LnN0eWxlO1xuICBpZiAodGFzay5fY29udGFpbmVyID09PSB0YXNrLl9yb290Q29udGFpbmVyKSB7XG4gICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGFzay5fcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIGRpdlN0eWxlLnRvcCA9IGAkeygxMDAgKiB0b3AgLyB0YXNrLl9wYWdlSGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICB9IGVsc2Uge1xuICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgIGRpdlN0eWxlLnRvcCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7dG9wLnRvRml4ZWQoMil9cHgpYDtcbiAgfVxuICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7Zm9udEhlaWdodC50b0ZpeGVkKDIpfXB4KWA7XG4gIGRpdlN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5O1xuICB0ZXh0RGl2UHJvcGVydGllcy5mb250U2l6ZSA9IGZvbnRIZWlnaHQ7XG4gIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgdGV4dERpdi50ZXh0Q29udGVudCA9IGdlb20uc3RyO1xuICB0ZXh0RGl2LmRpciA9IGdlb20uZGlyO1xuICBpZiAodGFzay5fZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICB0ZXh0RGl2LmRhdGFzZXQuZm9udE5hbWUgPSBnZW9tLmZvbnROYW1lO1xuICB9XG4gIGlmIChhbmdsZSAhPT0gMCkge1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gIH1cbiAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICBpZiAoZ2VvbS5zdHIubGVuZ3RoID4gMSkge1xuICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgIGNvbnN0IGFic1NjYWxlWCA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzBdKSxcbiAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcbiAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkU2NhbGVUZXh0KSB7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggPSBzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aDtcbiAgfVxuICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuICBpZiAodGFzay5faXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIHRhc2suX2xheW91dFRleHQodGV4dERpdik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxheW91dChwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGRpdixcbiAgICBzY2FsZSxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIGN0eCxcbiAgICBwcmV2Rm9udFNpemUsXG4gICAgcHJldkZvbnRGYW1pbHlcbiAgfSA9IHBhcmFtcztcbiAgY29uc3Qge1xuICAgIHN0eWxlXG4gIH0gPSBkaXY7XG4gIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICBpZiAocHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCAmJiBwcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb250RmFtaWx5XG4gICAgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgZm9udFNpemVcbiAgICB9ID0gcHJvcGVydGllcztcbiAgICBpZiAocHJldkZvbnRTaXplICE9PSBmb250U2l6ZSB8fCBwcmV2Rm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xuICAgICAgY3R4LmZvbnQgPSBgJHtmb250U2l6ZSAqIHNjYWxlfXB4ICR7Zm9udEZhbWlseX1gO1xuICAgICAgcGFyYW1zLnByZXZGb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgcGFyYW1zLnByZXZGb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGhcbiAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KGRpdi50ZXh0Q29udGVudCk7XG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogc2NhbGUgLyB3aWR0aH0pYDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXIodGFzaykge1xuICBpZiAodGFzay5fY2FuY2VsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGV4dERpdnMgPSB0YXNrLl90ZXh0RGl2cztcbiAgY29uc3QgY2FwYWJpbGl0eSA9IHRhc2suX2NhcGFiaWxpdHk7XG4gIGNvbnN0IHRleHREaXZzTGVuZ3RoID0gdGV4dERpdnMubGVuZ3RoO1xuICBpZiAodGV4dERpdnNMZW5ndGggPiBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUikge1xuICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRhc2suX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICBmb3IgKGNvbnN0IHRleHREaXYgb2YgdGV4dERpdnMpIHtcbiAgICAgIHRhc2suX2xheW91dFRleHQodGV4dERpdik7XG4gICAgfVxuICB9XG4gIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xufVxuY2xhc3MgVGV4dExheWVyUmVuZGVyVGFzayB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnQsXG4gICAgdGV4dERpdnMsXG4gICAgdGV4dERpdlByb3BlcnRpZXMsXG4gICAgdGV4dENvbnRlbnRJdGVtc1N0cixcbiAgICBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFxuICB9KSB7XG4gICAgdGhpcy5fdGV4dENvbnRlbnRTb3VyY2UgPSB0ZXh0Q29udGVudFNvdXJjZTtcbiAgICB0aGlzLl9pc1JlYWRhYmxlU3RyZWFtID0gdGV4dENvbnRlbnRTb3VyY2UgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9yb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX3RleHREaXZzID0gdGV4dERpdnMgfHwgW107XG4gICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRleHRDb250ZW50SXRlbXNTdHIgfHwgW107XG4gICAgdGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDtcbiAgICB0aGlzLl9mb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcyB8fCBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMgPSB7XG4gICAgICBwcmV2Rm9udFNpemU6IG51bGwsXG4gICAgICBwcmV2Rm9udEZhbWlseTogbnVsbCxcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHNjYWxlOiB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSksXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4OiBnZXRDdHgoMCwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IFsxLCAwLCAwLCAtMSwgLXBhZ2VYLCBwYWdlWSArIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMuX3BhZ2VXaWR0aCA9IHBhZ2VXaWR0aDtcbiAgICB0aGlzLl9wYWdlSGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShjb250YWluZXIsIHZpZXdwb3J0KTtcbiAgICB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG4gIH1cbiAgX3Byb2Nlc3NJdGVtcyhpdGVtcywgc3R5bGVDYWNoZSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIGFwcGVuZFRleHQodGhpcywgaXRlbSwgc3R5bGVDYWNoZSk7XG4gICAgfVxuICB9XG4gIF9sYXlvdXRUZXh0KHRleHREaXYpIHtcbiAgICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHRoaXMuX2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzLmdldCh0ZXh0RGl2KTtcbiAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zLmRpdiA9IHRleHREaXY7XG4gICAgbGF5b3V0KHRoaXMuX2xheW91dFRleHRQYXJhbXMpO1xuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzRU9MKSB7XG4gICAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKGJyKTtcbiAgICB9XG4gIH1cbiAgX3JlbmRlcigpIHtcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgbGV0IHN0eWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICh0aGlzLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pID0+IHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVDYWNoZSwgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0aGlzLl9wcm9jZXNzSXRlbXModmFsdWUuaXRlbXMsIHN0eWxlQ2FjaGUpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgY2FwYWJpbGl0eS5yZWplY3QpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHRoaXMuX3RleHRDb250ZW50U291cmNlLmdldFJlYWRlcigpO1xuICAgICAgcHVtcCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdGV4dENvbnRlbnRTb3VyY2UpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHN0eWxlc1xuICAgICAgfSA9IHRoaXMuX3RleHRDb250ZW50U291cmNlO1xuICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZXMpO1xuICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIGNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHN0eWxlQ2FjaGUgPSBudWxsO1xuICAgICAgcmVuZGVyKHRoaXMpO1xuICAgIH0sIHRoaXMuX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgfVxufVxuZXhwb3J0cy5UZXh0TGF5ZXJSZW5kZXJUYXNrID0gVGV4dExheWVyUmVuZGVyVGFzaztcbmZ1bmN0aW9uIHJlbmRlclRleHRMYXllcihwYXJhbXMpIHtcbiAgaWYgKCFwYXJhbXMudGV4dENvbnRlbnRTb3VyY2UgJiYgKHBhcmFtcy50ZXh0Q29udGVudCB8fCBwYXJhbXMudGV4dENvbnRlbnRTdHJlYW0pKSB7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiVGhlIFRleHRMYXllclJlbmRlciBgdGV4dENvbnRlbnRgL2B0ZXh0Q29udGVudFN0cmVhbWAgcGFyYW1ldGVycyBcIiArIFwid2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIHBsZWFzZSB1c2UgYHRleHRDb250ZW50U291cmNlYCBpbnN0ZWFkLlwiKTtcbiAgICBwYXJhbXMudGV4dENvbnRlbnRTb3VyY2UgPSBwYXJhbXMudGV4dENvbnRlbnQgfHwgcGFyYW1zLnRleHRDb250ZW50U3RyZWFtO1xuICB9XG4gIGNvbnN0IHtcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSA9IHBhcmFtcztcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gIGNvbnN0IHZpc2liaWxpdHkgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwidmlzaWJpbGl0eVwiKTtcbiAgY29uc3Qgc2NhbGVGYWN0b3IgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXNjYWxlLWZhY3RvclwiKSk7XG4gIGlmICh2aXNpYmlsaXR5ID09PSBcInZpc2libGVcIiAmJiAoIXNjYWxlRmFjdG9yIHx8IE1hdGguYWJzKHNjYWxlRmFjdG9yIC0gdmlld3BvcnQuc2NhbGUpID4gMWUtNSkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVGhlIGAtLXNjYWxlLWZhY3RvcmAgQ1NTLXZhcmlhYmxlIG11c3QgYmUgc2V0LCBcIiArIFwidG8gdGhlIHNhbWUgdmFsdWUgYXMgYHZpZXdwb3J0LnNjYWxlYCwgXCIgKyBcImVpdGhlciBvbiB0aGUgYGNvbnRhaW5lcmAtZWxlbWVudCBpdHNlbGYgb3IgaGlnaGVyIHVwIGluIHRoZSBET00uXCIpO1xuICB9XG4gIGNvbnN0IHRhc2sgPSBuZXcgVGV4dExheWVyUmVuZGVyVGFzayhwYXJhbXMpO1xuICB0YXNrLl9yZW5kZXIoKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5mdW5jdGlvbiB1cGRhdGVUZXh0TGF5ZXIoe1xuICBjb250YWluZXIsXG4gIHZpZXdwb3J0LFxuICB0ZXh0RGl2cyxcbiAgdGV4dERpdlByb3BlcnRpZXMsXG4gIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICBtdXN0Um90YXRlID0gdHJ1ZSxcbiAgbXVzdFJlc2NhbGUgPSB0cnVlXG59KSB7XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykoY29udGFpbmVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgfVxuICBpZiAobXVzdFJlc2NhbGUpIHtcbiAgICBjb25zdCBjdHggPSBnZXRDdHgoMCwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICAgIGNvbnN0IHNjYWxlID0gdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHByZXZGb250U2l6ZTogbnVsbCxcbiAgICAgIHByZXZGb250RmFtaWx5OiBudWxsLFxuICAgICAgZGl2OiBudWxsLFxuICAgICAgc2NhbGUsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0ZXh0RGl2cykge1xuICAgICAgcGFyYW1zLnByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcy5nZXQoZGl2KTtcbiAgICAgIHBhcmFtcy5kaXYgPSBkaXY7XG4gICAgICBsYXlvdXQocGFyYW1zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9mcmVldGV4dCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIF9pbmsgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3N0YW1wID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICNhbGxvd0NsaWNrID0gZmFsc2U7XG4gICNhbm5vdGF0aW9uTGF5ZXIgPSBudWxsO1xuICAjYm91bmRQb2ludGVydXAgPSB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAjYm91bmRQb2ludGVyZG93biA9IHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKTtcbiAgI2VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gICNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1aU1hbmFnZXIsXG4gICAgcGFnZUluZGV4LFxuICAgIGRpdixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uTGF5ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgbDEwblxuICB9KSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZXMgPSBbX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yLCBfaW5rLklua0VkaXRvciwgX3N0YW1wLlN0YW1wRWRpdG9yXTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIGVkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUuaW5pdGlhbGl6ZShsMTBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdWlNYW5hZ2VyLnJlZ2lzdGVyRWRpdG9yVHlwZXMoZWRpdG9yVHlwZXMpO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllciA9IGFubm90YXRpb25MYXllcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gIH1cbiAgdXBkYXRlTW9kZShtb2RlID0gdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSkge1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBpZiAobW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKSB7XG4gICAgICB0aGlzLmFkZElua0VkaXRvcklmTmVlZGVkKGZhbHNlKTtcbiAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgIT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVlVGV4dEVkaXRpbmdcIiwgbW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImlua0VkaXRpbmdcIiwgbW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJzdGFtcEVkaXRpbmdcIiwgbW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVApO1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFkZElua0VkaXRvcklmTmVlZGVkKGlzQ29tbWl0dGluZykge1xuICAgIGlmICghaXNDb21taXR0aW5nICYmIHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgIT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tbWl0dGluZykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgIG9mZnNldFg6IDAsXG4gICAgICBvZmZzZXRZOiAwXG4gICAgfSwgZmFsc2UpO1xuICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgY29uc3QgYW5ub3RhdGlvbkVsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICBlZGl0YWJsZS5oaWRlKCk7XG4gICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWRzLmhhcyhlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZGVzZXJpYWxpemUoZWRpdGFibGUpO1xuICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIGNvbnN0IGhpZGRlbkFubm90YXRpb25JZHMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8IGVkaXRvci5zZXJpYWxpemUoKSAhPT0gbnVsbCkge1xuICAgICAgICBoaWRkZW5Bbm5vdGF0aW9uSWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRFZGl0YWJsZUFubm90YXRpb24oZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpPy5zaG93KCk7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVkaXRhYmxlLmRhdGE7XG4gICAgICAgIGlmIChoaWRkZW5Bbm5vdGF0aW9uSWRzLmhhcyhpZCkgfHwgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZFBvaW50ZXJkb3duKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kUG9pbnRlcnVwKTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRQb2ludGVydXApO1xuICB9XG4gIGF0dGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICAgIH0gPSBlZGl0b3I7XG4gICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQgJiYgdGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGRldGFjaChlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgIGlmICghdGhpcy4jaXNEaXNhYmxpbmcgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGVkaXRvcikge1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLmZvY3VzTWFpbkNvbnRhaW5lcigpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIGlmICghdGhpcy4jaXNDbGVhbmluZ1VwKSB7XG4gICAgICB0aGlzLmFkZElua0VkaXRvcklmTmVlZGVkKGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgY2hhbmdlUGFyZW50KGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3IucGFyZW50Py5kZXRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2V0UGFyZW50KHRoaXMpO1xuICAgIGlmIChlZGl0b3IuZGl2ICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWRpdG9yLmRpdik7XG4gICAgfVxuICB9XG4gIGFkZChlZGl0b3IpIHtcbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCgpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gIH1cbiAgbW92ZUVkaXRvckluRE9NKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGVkaXRvci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWRpdG9yLmRpdiwgZWRpdG9yLmNvbnRlbnREaXYsIHRydWUpO1xuICB9XG4gIGFkZE9yUmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLm5lZWRzVG9CZVJlYnVpbHQoKSkge1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgc3dpdGNoICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IF9mcmVldGV4dC5GcmVlVGV4dEVkaXRvcihwYXJhbXMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgX2luay5JbmtFZGl0b3IocGFyYW1zKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgX3N0YW1wLlN0YW1wRWRpdG9yKHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHBhc3RlRWRpdG9yKG1vZGUsIHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfSA9IHRoaXMuI2dldENlbnRlclBvaW50KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IG9mZnNldFgsXG4gICAgICB5OiBvZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgIHN3aXRjaCAoZGF0YS5hbm5vdGF0aW9uVHlwZSA/PyBkYXRhLmFubm90YXRpb25FZGl0b3JUeXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcik7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIF9pbmsuSW5rRWRpdG9yLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcik7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gX3N0YW1wLlN0YW1wRWRpdG9yLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gICNjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWRcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcigpIHtcbiAgICB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmlzU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBwb2ludGVydXAoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIGlmICghdGhpcy4jYWxsb3dDbGljaykge1xuICAgICAgdGhpcy4jYWxsb3dDbGljayA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG4gIGZpbmROZXdQYXJlbnQoZWRpdG9yLCB4LCB5KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiN1aU1hbmFnZXIuZmluZFBhcmVudCh4LCB5KTtcbiAgICBpZiAobGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGF5ZXIuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpPy5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgICBlZGl0b3Iuc2V0UGFyZW50KG51bGwpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuI2VkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gIH1cbiAgI2NsZWFudXAoKSB7XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2lzQ2xlYW5pbmdVcCA9IGZhbHNlO1xuICB9XG4gIHJlbmRlcih7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKSh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICBnZXQgcGFnZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JMYXllciA9IEFubm90YXRpb25FZGl0b3JMYXllcjtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfYW5ub3RhdGlvbl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYm91bmRFZGl0b3JEaXZCbHVyID0gdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdkZvY3VzID0gdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZJbnB1dCA9IHRoaXMuZWRpdG9yRGl2SW5wdXQuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2S2V5ZG93biA9IHRoaXMuZWRpdG9yRGl2S2V5ZG93bi5iaW5kKHRoaXMpO1xuICAjY29sb3I7XG4gICNjb250ZW50ID0gXCJcIjtcbiAgI2VkaXRvckRpdklkID0gYCR7dGhpcy5pZH0tZWRpdG9yYDtcbiAgI2ZvbnRTaXplO1xuICAjaW5pdGlhbERhdGEgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi5pc0VtcHR5KCk7XG4gICAgY29uc3Qgc21hbGwgPSBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gX3Rvb2xzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBfdG9vbHMuS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCtzXCIsIFwibWFjK21ldGErc1wiLCBcImN0cmwrcFwiLCBcIm1hYyttZXRhK3BcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfV0sIFtbXCJjdHJsK0VudGVyXCIsIFwibWFjK21ldGErRW50ZXJcIiwgXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by5jb21taXRPclJlbW92ZV0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIHN0YXRpYyBfdHlwZSA9IFwiZnJlZXRleHRcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwge1xuICAgICAgc3RyaW5nczogW1wiZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnRcIiwgXCJlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsXCJdXG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKGZvbnRTaXplKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKHNhdmVkRm9udHNpemUpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZLZXlkb3duKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZGb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZCbHVyKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZJbnB1dCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2S2V5ZG93bik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Rm9jdXMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Qmx1cik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2SW5wdXQpO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRFZGl0aW5nXCIpO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB0aGlzLiNjaGVhdEluaXRpYWxSZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBkaXZzID0gdGhpcy5lZGl0b3JEaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIik7XG4gICAgaWYgKGRpdnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0O1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBkaXZzKSB7XG4gICAgICBidWZmZXIucHVzaChkaXYuaW5uZXJUZXh0LnJlcGxhY2UoL1xcclxcbj98XFxuLywgXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgIH1cbiAgICBpZiAodGhpcy5yb3RhdGlvbiAlIDE4MCA9PT0gdGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCkge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LmhlaWdodCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LndpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIGNvbnN0IHNhdmVkVGV4dCA9IHRoaXMuI2NvbnRlbnQ7XG4gICAgY29uc3QgbmV3VGV4dCA9IHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICBpZiAoc2F2ZWRUZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldFRleHQgPSB0ZXh0ID0+IHtcbiAgICAgIHRoaXMuI2NvbnRlbnQgPSB0ZXh0O1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZWJ1aWxkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChuZXdUZXh0KTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQoc2F2ZWRUZXh0KTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbkVkaXRNb2RlKCk7XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICB9XG4gIGRibGNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlZGl0b3JEaXZLZXlkb3duKGV2ZW50KSB7XG4gICAgRnJlZVRleHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuICBlZGl0b3JEaXZCbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBlZGl0b3JEaXZJbnB1dChldmVudCkge1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZVRleHRFZGl0aW5nXCIsIHRoaXMuaXNFbXB0eSgpKTtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuZWRpdG9yRGl2Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnRcIikudGhlbihtc2cgPT4gdGhpcy5lZGl0b3JEaXY/LnNldEF0dHJpYnV0ZShcImRlZmF1bHQtY29udGVudFwiLCBtc2cpKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgICgwLCBfdG9vbHMuYmluZEV2ZW50cykodGhpcywgdGhpcy5kaXYsIFtcImRibGNsaWNrXCIsIFwia2V5ZG93blwiXSk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLiNpbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX2xheWVyLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gZGF0YS52YWx1ZTtcbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuI2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgICBpZDogdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgICBkZWxldGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICBjb25zdCBjb2xvciA9IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5pc0F0dGFjaGVkVG9ET00gPyBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWRpdG9yRGl2KS5jb2xvciA6IHRoaXMuI2NvbG9yKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgY29sb3IsXG4gICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUsXG4gICAgICB2YWx1ZTogdGhpcy4jY29udGVudCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9udFNpemUsXG4gICAgICBjb2xvcixcbiAgICAgIHJlY3QsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy4jaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQucmVjdC5zb21lKCh4LCBpKSA9PiBNYXRoLmFicyh4IC0gcmVjdFtpXSkgPj0gMSkgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICAjY2hlYXRJbml0aWFsUmVjdChkZWxheWVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgaWYgKCFkZWxheWVkICYmICh0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwKSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLiNjaGVhdEluaXRpYWxSZWN0KHRydWUpLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHRoaXMuI2luaXRpYWxEYXRhLnJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gIH1cbn1cbmV4cG9ydHMuRnJlZVRleHRFZGl0b3IgPSBGcmVlVGV4dEVkaXRvcjtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TdGFtcEFubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5JbmtBbm5vdGF0aW9uRWxlbWVudCA9IGV4cG9ydHMuRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCA9IGV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgX3NjcmlwdGluZ191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzApO1xudmFyIF9kaXNwbGF5TDEwbl91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIF94ZmFfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbmNvbnN0IERFRkFVTFRfVEFCX0lOREVYID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGdldFJlY3REaW1zKHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICB9O1xufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNoYXNCb3JkZXIgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywge1xuICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlLFxuICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1JlbmRlcmFibGUgPSBpc1JlbmRlcmFibGU7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1ldGVycy5kYXRhO1xuICAgIHRoaXMubGF5ZXIgPSBwYXJhbWV0ZXJzLmxheWVyO1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckZvcm1zID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX2ZpZWxkT2JqZWN0cyA9IHBhcmFtZXRlcnMuZmllbGRPYmplY3RzO1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVRdWFkcmlsYXRlcmFscygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2hhc1BvcHVwRGF0YSh7XG4gICAgdGl0bGVPYmosXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHRcbiAgfSkge1xuICAgIHJldHVybiAhISh0aXRsZU9iaj8uc3RyIHx8IGNvbnRlbnRzT2JqPy5zdHIgfHwgcmljaFRleHQ/LnN0cik7XG4gIH1cbiAgZ2V0IGhhc1BvcHVwRGF0YSgpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YSh0aGlzLmRhdGEpO1xuICB9XG4gIF9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICBwYWdlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiwgZGF0YS5pZCk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdpZGdldEFubm90YXRpb25FbGVtZW50KSkge1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSB0aGlzLnBhcmVudC56SW5kZXgrKztcbiAgICBpZiAodGhpcy5kYXRhLnBvcHVwUmVmKSB7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcImRpYWxvZ1wiKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubm9Sb3RhdGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9yb3RhdGVcIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgaWYgKCFkYXRhLnJlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCFkYXRhLmhhc093bkNhbnZhcyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHt3aWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke2hlaWdodH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuREFTSEVEOlxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJTdHlsZSA9IFwiZGFzaGVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGJvcmRlckNvbG9yWzBdIHwgMCwgYm9yZGVyQ29sb3JbMV0gfCAwLCBib3JkZXJDb2xvclsyXSB8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBjb250YWluZXIuc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHsxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIHNldFJvdGF0aW9uKGFuZ2xlLCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcikge1xuICAgIGlmICghdGhpcy5kYXRhLnJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHRoaXMuZGF0YS5yZWN0KTtcbiAgICBsZXQgZWxlbWVudFdpZHRoLCBlbGVtZW50SGVpZ2h0O1xuICAgIGlmIChhbmdsZSAlIDE4MCA9PT0gMCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogaGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIHdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudFdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50SGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBfc2NyaXB0aW5nX3V0aWxzLkNvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBfc2NyaXB0aW5nX3V0aWxzLkNvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X3JnYmBdKGNvbG9yQXJyYXkpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdDtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IFssIHtcbiAgICAgICAgeDogdHJYLFxuICAgICAgICB5OiB0cllcbiAgICAgIH0sIHtcbiAgICAgICAgeDogYmxYLFxuICAgICAgICB5OiBibFlcbiAgICAgIH1dID0gcXVhZFBvaW50c1swXTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChjb25zdCBbLCB7XG4gICAgICB4OiB0clgsXG4gICAgICB5OiB0cllcbiAgICB9LCB7XG4gICAgICB4OiBibFgsXG4gICAgICB5OiBibFlcbiAgICB9XSBvZiBxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJkaWFsb2dcIik7XG4gICAgY29uc3QgcG9wdXAgPSBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbG9yOiBkYXRhLmNvbG9yLFxuICAgICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgICBjb250ZW50c09iajogZGF0YS5jb250ZW50c09iaixcbiAgICAgICAgcmljaFRleHQ6IGRhdGEucmljaFRleHQsXG4gICAgICAgIHBhcmVudFJlY3Q6IGRhdGEucmVjdCxcbiAgICAgICAgYm9yZGVyU3R5bGU6IDAsXG4gICAgICAgIGlkOiBgcG9wdXBfJHtkYXRhLmlkfWAsXG4gICAgICAgIHJvdGF0aW9uOiBkYXRhLnJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiBbdGhpc11cbiAgICB9KTtcbiAgICB0aGlzLnBhcmVudC5kaXYuYXBwZW5kKHBvcHVwLnJlbmRlcigpKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIHNraXBJZCA9IG51bGwpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBpZiAodGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICBjb25zdCBmaWVsZE9iaiA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tuYW1lXTtcbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlkID09PSBza2lwSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IHR5cGVvZiBleHBvcnRWYWx1ZXMgPT09IFwic3RyaW5nXCIgPyBleHBvcnRWYWx1ZXMgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FZGl0b3JUeXBlOiBtb2RlLFxuICAgICAgZGF0YToge1xuICAgICAgICBpZDogZWRpdElkXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGVkaXRJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIExpbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6ICEhb3B0aW9ucz8uaWdub3JlQm9yZGVyLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzVG9vbHRpcE9ubHkgPSBwYXJhbWV0ZXJzLmRhdGEuaXNUb29sdGlwT25seTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGxpbmtTZXJ2aWNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGRhdGEuaWQpO1xuICAgIGxldCBpc0JvdW5kID0gZmFsc2U7XG4gICAgaWYgKGRhdGEudXJsKSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhsaW5rLCBkYXRhLnVybCwgZGF0YS5uZXdXaW5kb3cpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbikge1xuICAgICAgdGhpcy5fYmluZE5hbWVkQWN0aW9uKGxpbmssIGRhdGEuYWN0aW9uKTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRhY2htZW50KSB7XG4gICAgICB0aGlzLl9iaW5kQXR0YWNobWVudChsaW5rLCBkYXRhLmF0dGFjaG1lbnQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnNldE9DR1N0YXRlKSB7XG4gICAgICB0aGlzLiNiaW5kU2V0T0NHU3RhdGUobGluaywgZGF0YS5zZXRPQ0dTdGF0ZSk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZGVzdCkge1xuICAgICAgdGhpcy5fYmluZExpbmsobGluaywgZGF0YS5kZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0YS5hY3Rpb25zICYmIChkYXRhLmFjdGlvbnMuQWN0aW9uIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIFVwXCJdIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIERvd25cIl0pICYmIHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5yZXNldEZvcm0pIHtcbiAgICAgICAgdGhpcy5fYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCBkYXRhLnJlc2V0Rm9ybSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVG9vbHRpcE9ubHkgJiYgIWlzQm91bmQpIHtcbiAgICAgICAgdGhpcy5fYmluZExpbmsobGluaywgXCJcIik7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGlua0Fubm90YXRpb25cIik7XG4gICAgaWYgKGlzQm91bmQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChsaW5rKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gICNzZXRJbnRlcm5hbExpbmsoKSB7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1pbnRlcm5hbC1saW5rXCIsIFwiXCIpO1xuICB9XG4gIF9iaW5kTGluayhsaW5rLCBkZXN0aW5hdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0RGVzdGluYXRpb25IYXNoKGRlc3RpbmF0aW9uKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5nb1RvRGVzdGluYXRpb24oZGVzdGluYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKGRlc3RpbmF0aW9uIHx8IGRlc3RpbmF0aW9uID09PSBcIlwiKSB7XG4gICAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICB9XG4gIH1cbiAgX2JpbmROYW1lZEFjdGlvbihsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVOYW1lZEFjdGlvbihhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRBdHRhY2htZW50KGxpbmssIGF0dGFjaG1lbnQpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGFpbmVyLCBhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gXCJyZXNldEZvcm1cIiBhY3Rpb24gbm90IHN1cHBvcnRlZCwgYCArIFwiZW5zdXJlIHRoYXQgdGhlIGBmaWVsZE9iamVjdHNgIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIG90aGVyQ2xpY2tBY3Rpb24/LigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZHM6IHJlc2V0Rm9ybUZpZWxkcyxcbiAgICAgICAgcmVmczogcmVzZXRGb3JtUmVmcyxcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfSA9IHJlc2V0Rm9ybTtcbiAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IFtdO1xuICAgICAgaWYgKHJlc2V0Rm9ybUZpZWxkcy5sZW5ndGggIT09IDAgfHwgcmVzZXRGb3JtUmVmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgZmllbGRJZHMgPSBuZXcgU2V0KHJlc2V0Rm9ybVJlZnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiByZXNldEZvcm1GaWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZE9iamVjdHNbZmllbGROYW1lXSB8fCBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkSWRzLmFkZChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRJZHMuaGFzKGZpZWxkLmlkKSA9PT0gaW5jbHVkZSkge1xuICAgICAgICAgICAgICBhbGxGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBhbGxGaWVsZHMucHVzaCguLi5maWVsZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIGNvbnN0IGFsbElkcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBhbGxGaWVsZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBmaWVsZDtcbiAgICAgICAgYWxsSWRzLnB1c2goaWQpO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJyYWRpb2J1dHRvblwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSA9PT0gZmllbGQuZXhwb3J0VmFsdWVzO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJjb21ib2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJsaXN0Ym94XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1lbGVtZW50LWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgaWYgKCFkb21FbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLmFsdCA9IFwiW3t7dHlwZX19IEFubm90YXRpb25dXCI7XG4gICAgaW1hZ2UuZGF0YXNldC5sMTBuSWQgPSBcInRleHRfYW5ub3RhdGlvbl90eXBlXCI7XG4gICAgaW1hZ2UuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci50aXRsZSA9IHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1dpbixcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBpc1dpbiAmJiBldmVudC5jdHJsS2V5IHx8IGlzTWFjICYmIGV2ZW50Lm1ldGFLZXk7XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIHZhbHVlR2V0dGVyKSB7XG4gICAgaWYgKGJhc2VOYW1lLmluY2x1ZGVzKFwibW91c2VcIikpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbW9kaWZpZXI6IHRoaXMuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChiYXNlTmFtZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlR2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgbmFtZXMsIGdldHRlcikge1xuICAgIGZvciAoY29uc3QgW2Jhc2VOYW1lLCBldmVudE5hbWVdIG9mIG5hbWVzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcIkFjdGlvblwiIHx8IHRoaXMuZGF0YS5hY3Rpb25zPy5bZXZlbnROYW1lXSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgfHwgZXZlbnROYW1lID09PSBcIkJsdXJcIikge1xuICAgICAgICAgIGVsZW1lbnREYXRhIHx8PSB7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgZ2V0dGVyKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiYmx1clwiLCBcIkJsdXJcIiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSBcIkJsdXJcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJmb2N1c1wiLCBcIkZvY3VzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5kYXRhLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IgPT09IG51bGwgPyBcInRyYW5zcGFyZW50XCIgOiBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgfVxuICBfc2V0VGV4dFN0eWxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBURVhUX0FMSUdOTUVOVCA9IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXTtcbiAgICBjb25zdCB7XG4gICAgICBmb250Q29sb3JcbiAgICB9ID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemUgfHwgREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCByb3VuZFRvT25lRGVjaW1hbCA9IHggPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoX3V0aWwuTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIF91dGlsLkxJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIF91dGlsLkxJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcm9wZXJ0eU9uU2libGluZ3MoYmFzZSwga2V5LCB2YWx1ZSwga2V5SW5TdG9yYWdlKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGJhc2UubmFtZSwgYmFzZS5pZCkpIHtcbiAgICAgIGlmIChlbGVtZW50LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5kb21FbGVtZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoZWxlbWVudC5pZCwge1xuICAgICAgICBba2V5SW5TdG9yYWdlXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGxldCBlbGVtZW50ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZW5kZXJGb3Jtcykge1xuICAgICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgICB9KTtcbiAgICAgIGxldCB0ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWUgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1heExlbiA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgY2hhckxpbWl0OiB0aGlzLmRhdGEubWF4TGVuXG4gICAgICB9KS5jaGFyTGltaXQ7XG4gICAgICBpZiAobWF4TGVuICYmIHRleHRDb250ZW50Lmxlbmd0aCA+IG1heExlbikge1xuICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIG1heExlbik7XG4gICAgICB9XG4gICAgICBsZXQgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBzdG9yZWREYXRhLmZvcm1hdHRlZFZhbHVlIHx8IHRoaXMuZGF0YS50ZXh0Q29udGVudD8uam9pbihcIlxcblwiKSB8fCBudWxsO1xuICAgICAgaWYgKGZpZWxkRm9ybWF0dGVkVmFsdWVzICYmIHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMucmVwbGFjZUFsbCgvXFxzKy9nLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnREYXRhID0ge1xuICAgICAgICB1c2VyVmFsdWU6IHRleHRDb250ZW50LFxuICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogZmllbGRGb3JtYXR0ZWRWYWx1ZXMsXG4gICAgICAgIGxhc3RDb21taXR0ZWRWYWx1ZTogbnVsbCxcbiAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1ggPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgICBpZiAobWF4TGVuKSB7XG4gICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gbWF4TGVuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU9uU2libGluZ3MoZWxlbWVudCwgXCJ2YWx1ZVwiLCBldmVudC50YXJnZXQudmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlID8/IFwiXCI7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgbGV0IGJsdXJMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGpzRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlID8/IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudERhdGEudXNlclZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZXZlbnQudGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbFJhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSguLi5ldmVudC5kZXRhaWwuc2VsUmFuZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYXJMaW1pdDogZXZlbnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgY2hhckxpbWl0XG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICBpZiAoY2hhckxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcIm1heExlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcIm1heExlbmd0aFwiLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoIDw9IGNoYXJMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQ6IHRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgIHNlbEVuZDogdGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGxldCBjb21taXRLZXkgPSAtMTtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIXRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21taXRLZXkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgY29tbWl0S2V5LFxuICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9ibHVyTGlzdGVuZXIgPSBibHVyTGlzdGVuZXI7XG4gICAgICAgIGJsdXJMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21taXRLZXk6IGVsZW1lbnREYXRhLmNvbW1pdEtleSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JsdXJMaXN0ZW5lcihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmFjdGlvbnM/LktleXN0cm9rZSkge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxFbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9cXHcqW15cXHddKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkRm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXlteXFx3XSpcXHcqLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBjb25zdCBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIG1heExlbjtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gYGNhbGMoJHtjb21iV2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpIC0gMWNoKWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGF0YS5maWVsZFZhbHVlO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgIH1cbiAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiAhIXBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXNcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5leHBvcnRWYWx1ZSA9PT0gZGF0YS5maWVsZFZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcImNoZWNrQm94XCIpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgY2hlY2tib3ggb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIGNoZWNrYm94LmV4cG9ydFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgICAgICBpZiAoY2hlY2tib3guZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNoZWNrYm94LmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgfHwgXCJPZmZcIjtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlID09PSBkYXRhLmV4cG9ydFZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZXZlbnQuZGV0YWlsLnZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJyYWRpb0J1dHRvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGlkID0gZGF0YS5pZDtcbiAgICBsZXQgdmFsdWUgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogZGF0YS5maWVsZFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlXG4gICAgfSkudmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInJhZGlvXCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBwZGZCdXR0b25WYWx1ZSA9PT0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgcmFkaW8uaWQgPT09IGlkO1xuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbmtFbGVtZW50ID0gY29udGFpbmVyLmxhc3RDaGlsZDtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMgJiYgbGlua0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGxpbmtFbGVtZW50KTtcbiAgICAgIGxpbmtFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KHt9LCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2hvaWNlV2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlXG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKHNlbGVjdEVsZW1lbnQpO1xuICAgIHNlbGVjdEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBzZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKHNlbGVjdEVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICBzZWxlY3RFbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgbGV0IGFkZEFuRW1wdHlFbnRyeSA9IHRoaXMuZGF0YS5jb21ibyAmJiB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGggPiAwO1xuICAgIGlmICghdGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpU2VsZWN0KSB7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IG9wdGlvbi52YWx1ZSA9PT0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHRoaXMuZGF0YS5vcHRpb25zKSB7XG4gICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb24uZGlzcGxheVZhbHVlO1xuICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IG9wdGlvbi5leHBvcnRWYWx1ZTtcbiAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlLmluY2x1ZGVzKG9wdGlvbi5leHBvcnRWYWx1ZSkpIHtcbiAgICAgICAgb3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgICAgYWRkQW5FbXB0eUVudHJ5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICB9XG4gICAgbGV0IHJlbW92ZUVtcHR5RW50cnkgPSBudWxsO1xuICAgIGlmIChhZGRBbkVtcHR5RW50cnkpIHtcbiAgICAgIGNvbnN0IG5vbmVPcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnZhbHVlID0gXCIgXCI7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgIHNlbGVjdEVsZW1lbnQucHJlcGVuZChub25lT3B0aW9uRWxlbWVudCk7XG4gICAgICByZW1vdmVFbXB0eUVudHJ5ID0gKCkgPT4ge1xuICAgICAgICBub25lT3B0aW9uRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgIH1cbiAgICBjb25zdCBnZXRWYWx1ZSA9IGlzRXhwb3J0ID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpc0V4cG9ydCA/IFwidmFsdWVcIiA6IFwidGV4dENvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgbXVsdGlwbGVcbiAgICAgIH0gPSBzZWxlY3RFbGVtZW50O1xuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5zZWxlY3RlZEluZGV4ID09PSAtMSA/IG51bGwgOiBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF1bbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpLm1hcChvcHRpb24gPT4gb3B0aW9uW25hbWVdKTtcbiAgICB9O1xuICAgIGxldCBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICBjb25zdCBnZXRJdGVtcyA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgICBleHBvcnRWYWx1ZTogb3B0aW9uLnZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZXMuaGFzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZShldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuZGV0YWlsLnJlbW92ZTtcbiAgICAgICAgICAgIG9wdGlvbnNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsZWFyKGV2ZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnNlcnQoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWwuaW5zZXJ0O1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0Q2hpbGQgPSBzZWxlY3RFbGVtZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gaXRlbTtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBleHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZXZlbnQudGFyZ2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5kaWNlcy5oYXMob3B0aW9uLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdGFibGUoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFldmVudC5kZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBleHBvcnRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICBjaGFuZ2VFeDogZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgIGtleURvd246IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoc2VsZWN0RWxlbWVudCwgbnVsbCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl0sIFtcImlucHV0XCIsIFwiQWN0aW9uXCJdLCBbXCJpbnB1dFwiLCBcIlZhbGlkYXRlXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5jb21ibykge1xuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlKHNlbGVjdEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7fVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihzZWxlY3RFbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhzZWxlY3RFbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc2VsZWN0RWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGVsZW1lbnRzXG4gICAgfSA9IHBhcmFtZXRlcnM7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKGRhdGEpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwicG9wdXBBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlT2JqOiB0aGlzLmRhdGEudGl0bGVPYmosXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLmRhdGEuY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy5kYXRhLnJpY2hUZXh0LFxuICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3QsXG4gICAgICBwYXJlbnRSZWN0OiB0aGlzLmRhdGEucGFyZW50UmVjdCB8fCBudWxsLFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiB0aGlzLmVsZW1lbnRzLFxuICAgICAgb3BlbjogdGhpcy5kYXRhLm9wZW5cbiAgICB9KTtcbiAgICBjb25zdCBlbGVtZW50SWRzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQucG9wdXAgPSBwb3B1cDtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoaWQgPT4gYCR7X3V0aWwuQW5ub3RhdGlvblByZWZpeH0ke2lkfWApLmpvaW4oXCIsXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwRWxlbWVudCB7XG4gICNkYXRlVGltZVByb21pc2UgPSBudWxsO1xuICAjYm91bmRLZXlEb3duID0gdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRIaWRlID0gdGhpcy4jaGlkZS5iaW5kKHRoaXMpO1xuICAjYm91bmRTaG93ID0gdGhpcy4jc2hvdy5iaW5kKHRoaXMpO1xuICAjYm91bmRUb2dnbGUgPSB0aGlzLiN0b2dnbGUuYmluZCh0aGlzKTtcbiAgI2NvbG9yID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICNjb250ZW50c09iaiA9IG51bGw7XG4gICNlbGVtZW50cyA9IG51bGw7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjcGFyZW50UmVjdCA9IG51bGw7XG4gICNwaW5uZWQgPSBmYWxzZTtcbiAgI3BvcHVwID0gbnVsbDtcbiAgI3JlY3QgPSBudWxsO1xuICAjcmljaFRleHQgPSBudWxsO1xuICAjdGl0bGVPYmogPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICBjb25zdCBkYXRlT2JqZWN0ID0gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgaWYgKGRhdGVPYmplY3QpIHtcbiAgICAgIHRoaXMuI2RhdGVUaW1lUHJvbWlzZSA9IHBhcmVudC5sMTBuLmdldChcImFubm90YXRpb25fZGF0ZV9zdHJpbmdcIiwge1xuICAgICAgICBkYXRlOiBkYXRlT2JqZWN0LnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICB0aW1lOiBkYXRlT2JqZWN0LnRvTG9jYWxlVGltZVN0cmluZygpXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuI2JvdW5kU2hvdyk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jcGFyZW50O1xuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHBvcHVwLmNsYXNzTmFtZSA9IFwicG9wdXBcIjtcbiAgICBpZiAodGhpcy4jY29sb3IpIHtcbiAgICAgIGNvbnN0IGJhc2VDb2xvciA9IHBvcHVwLnN0eWxlLm91dGxpbmVDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yKTtcbiAgICAgIGlmIChDU1Muc3VwcG9ydHMoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiY29sb3ItbWl4KGluIHNyZ2IsIHJlZCAzMCUsIHdoaXRlKVwiKSkge1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBgY29sb3ItbWl4KGluIHNyZ2IsICR7YmFzZUNvbG9yfSAzMCUsIHdoaXRlKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBCQUNLR1JPVU5EX0VOTElHSFQgPSAwLjc7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLnRoaXMuI2NvbG9yLm1hcChjID0+IE1hdGguZmxvb3IoQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGMpICsgYykpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaGVhZGVyLmNsYXNzTmFtZSA9IFwiaGVhZGVyXCI7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XG4gICAgaGVhZGVyLmFwcGVuZCh0aXRsZSk7XG4gICAgKHtcbiAgICAgIGRpcjogdGl0bGUuZGlyLFxuICAgICAgc3RyOiB0aXRsZS50ZXh0Q29udGVudFxuICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgcG9wdXAuYXBwZW5kKGhlYWRlcik7XG4gICAgaWYgKHRoaXMuI2RhdGVUaW1lUHJvbWlzZSkge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc0xpc3QuYWRkKFwicG9wdXBEYXRlXCIpO1xuICAgICAgdGhpcy4jZGF0ZVRpbWVQcm9taXNlLnRoZW4obG9jYWxpemVkID0+IHtcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZS50ZXh0Q29udGVudCA9IGxvY2FsaXplZDtcbiAgICAgIH0pO1xuICAgICAgaGVhZGVyLmFwcGVuZChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudHNPYmogPSB0aGlzLiNjb250ZW50c09iajtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGlmIChyaWNoVGV4dD8uc3RyICYmICghY29udGVudHNPYmo/LnN0ciB8fCBjb250ZW50c09iai5zdHIgPT09IHJpY2hUZXh0LnN0cikpIHtcbiAgICAgIF94ZmFfbGF5ZXIuWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgICAgeGZhSHRtbDogcmljaFRleHQuaHRtbCxcbiAgICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCIsXG4gICAgICAgIGRpdjogcG9wdXBcbiAgICAgIH0pO1xuICAgICAgcG9wdXAubGFzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJyaWNoVGV4dFwiLCBcInBvcHVwQ29udGVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyhjb250ZW50c09iaik7XG4gICAgICBwb3B1cC5hcHBlbmQoY29udGVudHMpO1xuICAgIH1cbiAgICBsZXQgdXNlUGFyZW50UmVjdCA9ICEhdGhpcy4jcGFyZW50UmVjdDtcbiAgICBsZXQgcmVjdCA9IHVzZVBhcmVudFJlY3QgPyB0aGlzLiNwYXJlbnRSZWN0IDogdGhpcy4jcmVjdDtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy4jZWxlbWVudHMpIHtcbiAgICAgIGlmICghcmVjdCB8fCBfdXRpbC5VdGlsLmludGVyc2VjdChlbGVtZW50LmRhdGEucmVjdCwgcmVjdCkgIT09IG51bGwpIHtcbiAgICAgICAgcmVjdCA9IGVsZW1lbnQuZGF0YS5yZWN0O1xuICAgICAgICB1c2VQYXJlbnRSZWN0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtyZWN0WzBdLCB2aWV3WzNdIC0gcmVjdFsxXSArIHZpZXdbMV0sIHJlY3RbMl0sIHZpZXdbM10gLSByZWN0WzNdICsgdmlld1sxXV0pO1xuICAgIGNvbnN0IEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA9IDU7XG4gICAgY29uc3QgcGFyZW50V2lkdGggPSB1c2VQYXJlbnRSZWN0ID8gcmVjdFsyXSAtIHJlY3RbMF0gKyBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gOiAwO1xuICAgIGNvbnN0IHBvcHVwTGVmdCA9IG5vcm1hbGl6ZWRSZWN0WzBdICsgcGFyZW50V2lkdGg7XG4gICAgY29uc3QgcG9wdXBUb3AgPSBub3JtYWxpemVkUmVjdFsxXTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiNjb250YWluZXI7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChwb3B1cExlZnQgLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHBvcHVwKTtcbiAgfVxuICBfZm9ybWF0Q29udGVudHMoe1xuICAgIHN0cixcbiAgICBkaXJcbiAgfSkge1xuICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICBwLmNsYXNzTGlzdC5hZGQoXCJwb3B1cENvbnRlbnRcIik7XG4gICAgcC5kaXIgPSBkaXI7XG4gICAgY29uc3QgbGluZXMgPSBzdHIuc3BsaXQoLyg/Olxcclxcbj98XFxuKS8pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcbiAgICAgIGlmIChpIDwgaWkgLSAxKSB7XG4gICAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpICsgMTAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmb2N1c2VkXCIpO1xuICAgIH1cbiAgfVxuICAjaGlkZSgpIHtcbiAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzZWRcIik7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCB8fCAhdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXgpIC0gMTAwMDtcbiAgfVxuICBmb3JjZUhpZGUoKSB7XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgfVxuICBtYXliZVNob3coKSB7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9PT0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gcGFyYW1ldGVycy5kYXRhLnRleHRDb250ZW50O1xuICAgIHRoaXMudGV4dFBvc2l0aW9uID0gcGFyYW1ldGVycy5kYXRhLnRleHRQb3NpdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmV4cG9ydHMuRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCA9IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQ7XG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibGluZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTFcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMV0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNzcXVhcmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVhcmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLiNzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3F1YXJlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIENpcmNsZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjY2lyY2xlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2lyY2xlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy4jY2lyY2xlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZWxsaXBzZVwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgaGVpZ2h0IC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ4XCIsIHdpZHRoIC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChjaXJjbGUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NpcmNsZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgZm9yIChjb25zdCBjb29yZGluYXRlIG9mIGRhdGEudmVydGljZXMpIHtcbiAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICBjb25zdCB5ID0gZGF0YS5yZWN0WzNdIC0gY29vcmRpbmF0ZS55O1xuICAgICAgcG9pbnRzLnB1c2goeCArIFwiLFwiICsgeSk7XG4gICAgfVxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuI3BvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmVzID0gW107XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBkYXRhLmlua0xpc3RzKSB7XG4gICAgICBsZXQgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGNvb3JkaW5hdGUgb2YgaW5rTGlzdCkge1xuICAgICAgICBjb25zdCB4ID0gY29vcmRpbmF0ZS54IC0gZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCB5ID0gZGF0YS5yZWN0WzNdIC0gY29vcmRpbmF0ZS55O1xuICAgICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XG4gICAgICB9XG4gICAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgICB9XG4gICAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lcztcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5leHBvcnRzLklua0Fubm90YXRpb25FbGVtZW50ID0gSW5rQW5ub3RhdGlvbkVsZW1lbnQ7XG5jbGFzcyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1aWdnbHlBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdGFtcEFubm90YXRpb25cIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuZXhwb3J0cy5TdGFtcEFubm90YXRpb25FbGVtZW50ID0gU3RhbXBBbm5vdGF0aW9uRWxlbWVudDtcbmNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN0cmlnZ2VyID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgY29udGVudFxuICAgIH0gPSB0aGlzLmRhdGEuZmlsZTtcbiAgICB0aGlzLmZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybCkoZmlsZW5hbWUsIHRydWUpO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChkYXRhLmhhc0FwcGVhcmFuY2UgfHwgZGF0YS5maWxsQWxwaGEgPT09IDApIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIHRyaWdnZXIuc3JjID0gYCR7dGhpcy5pbWFnZVJlc291cmNlc1BhdGh9YW5ub3RhdGlvbi0key9wYXBlcmNsaXAvaS50ZXN0KGRhdGEubmFtZSkgPyBcInBhcGVyY2xpcFwiIDogXCJwdXNocGluXCJ9LnN2Z2A7XG4gICAgICBpZiAoZGF0YS5maWxsQWxwaGEgJiYgZGF0YS5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUgPSBgZmlsdGVyOiBvcGFjaXR5KCR7TWF0aC5yb3VuZChkYXRhLmZpbGxBbHBoYSAqIDEwMCl9JSk7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy4jZG93bmxvYWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy4jdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2dCA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gXCJFbnRlclwiICYmIChpc01hYyA/IGV2dC5tZXRhS2V5IDogZXZ0LmN0cmxLZXkpKSB7XG4gICAgICAgIHRoaXMuI2Rvd25sb2FkKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdHJpZ2dlcjtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG4gICNkb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGw7XG4gICNlZGl0YWJsZUFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgbDEwbixcbiAgICBwYWdlLFxuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMubDEwbiA9IGwxMG47XG4gICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIHRoaXMubDEwbiB8fD0gX2Rpc3BsYXlMMTBuX3V0aWxzLk51bGxMMTBuO1xuICB9XG4gICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb250ZW50RWxlbWVudC5pZCA9IGAke191dGlsLkFubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIHRoaXMuZGl2LmFwcGVuZChlbGVtZW50KTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgfVxuICBhc3luYyByZW5kZXIocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbnNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHBhcmFtcy5saW5rU2VydmljZSxcbiAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1zLmRvd25sb2FkTWFuYWdlcixcbiAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogcGFyYW1zLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgcmVuZGVyRm9ybXM6IHBhcmFtcy5yZW5kZXJGb3JtcyAhPT0gZmFsc2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtcy5hbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgX2Fubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24gJiYgZGF0YS5wb3B1cFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5wb3B1cFJlZik7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBwb3B1cFRvRWxlbWVudHMuc2V0KGRhdGEucG9wdXBSZWYsIFtlbGVtZW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYW5ub3RhdGlvbkVkaXRvclR5cGUgPiAwKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGF3YWl0IHRoaXMubDEwbi50cmFuc2xhdGUobGF5ZXIpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBmaXJzdENoaWxkXG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGlmICghZmlyc3RDaGlsZCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdENoaWxkLm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZVdpdGgoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gQW5ub3RhdGlvbkxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkNvbG9yQ29udmVydGVycyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBzY2FsZUFuZENsYW1wKHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgMjU1ICogeCkpO1xufVxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhbZ10pIHtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKFtnXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKFtnXSkge1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhbciwgZywgYl0pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoW3IsIGcsIGJdKSB7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5leHBvcnRzLkNvbG9yQ29udmVydGVycyA9IENvbG9yQ29udmVydGVycztcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5OdWxsTDEwbiA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0TDEwbkZhbGxiYWNrID0gZ2V0TDEwbkZhbGxiYWNrO1xuY29uc3QgREVGQVVMVF9MMTBOX1NUUklOR1MgPSB7XG4gIG9mX3BhZ2VzOiBcIm9mIHt7cGFnZXNDb3VudH19XCIsXG4gIHBhZ2Vfb2ZfcGFnZXM6IFwiKHt7cGFnZU51bWJlcn19IG9mIHt7cGFnZXNDb3VudH19KVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX2tiOiBcInt7c2l6ZV9rYn19IEtCICh7e3NpemVfYn19IGJ5dGVzKVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX21iOiBcInt7c2l6ZV9tYn19IE1CICh7e3NpemVfYn19IGJ5dGVzKVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX2RhdGVfc3RyaW5nOiBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV91bml0X2luY2hlczogXCJpblwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV91bml0X21pbGxpbWV0ZXJzOiBcIm1tXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX29yaWVudGF0aW9uX3BvcnRyYWl0OiBcInBvcnRyYWl0XCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX29yaWVudGF0aW9uX2xhbmRzY2FwZTogXCJsYW5kc2NhcGVcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9hMzogXCJBM1wiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2E0OiBcIkE0XCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfbGV0dGVyOiBcIkxldHRlclwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xlZ2FsOiBcIkxlZ2FsXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX2RpbWVuc2lvbl9zdHJpbmc6IFwie3t3aWR0aH19IMOXIHt7aGVpZ2h0fX0ge3t1bml0fX0gKHt7b3JpZW50YXRpb259fSlcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX25hbWVfc3RyaW5nOiBcInt7d2lkdGh9fSDDlyB7e2hlaWdodH19IHt7dW5pdH19ICh7e25hbWV9fSwge3tvcmllbnRhdGlvbn19KVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX2xpbmVhcml6ZWRfeWVzOiBcIlllc1wiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX2xpbmVhcml6ZWRfbm86IFwiTm9cIixcbiAgYWRkaXRpb25hbF9sYXllcnM6IFwiQWRkaXRpb25hbCBMYXllcnNcIixcbiAgcGFnZV9sYW5kbWFyazogXCJQYWdlIHt7cGFnZX19XCIsXG4gIHRodW1iX3BhZ2VfdGl0bGU6IFwiUGFnZSB7e3BhZ2V9fVwiLFxuICB0aHVtYl9wYWdlX2NhbnZhczogXCJUaHVtYm5haWwgb2YgUGFnZSB7e3BhZ2V9fVwiLFxuICBmaW5kX3JlYWNoZWRfdG9wOiBcIlJlYWNoZWQgdG9wIG9mIGRvY3VtZW50LCBjb250aW51ZWQgZnJvbSBib3R0b21cIixcbiAgZmluZF9yZWFjaGVkX2JvdHRvbTogXCJSZWFjaGVkIGVuZCBvZiBkb2N1bWVudCwgY29udGludWVkIGZyb20gdG9wXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudFtvbmVdXCI6IFwie3tjdXJyZW50fX0gb2Yge3t0b3RhbH19IG1hdGNoXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudFtvdGhlcl1cIjogXCJ7e2N1cnJlbnR9fSBvZiB7e3RvdGFsfX0gbWF0Y2hlc1wiLFxuICBcImZpbmRfbWF0Y2hfY291bnRfbGltaXRbb25lXVwiOiBcIk1vcmUgdGhhbiB7e2xpbWl0fX0gbWF0Y2hcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50X2xpbWl0W290aGVyXVwiOiBcIk1vcmUgdGhhbiB7e2xpbWl0fX0gbWF0Y2hlc1wiLFxuICBmaW5kX25vdF9mb3VuZDogXCJQaHJhc2Ugbm90IGZvdW5kXCIsXG4gIHBhZ2Vfc2NhbGVfd2lkdGg6IFwiUGFnZSBXaWR0aFwiLFxuICBwYWdlX3NjYWxlX2ZpdDogXCJQYWdlIEZpdFwiLFxuICBwYWdlX3NjYWxlX2F1dG86IFwiQXV0b21hdGljIFpvb21cIixcbiAgcGFnZV9zY2FsZV9hY3R1YWw6IFwiQWN0dWFsIFNpemVcIixcbiAgcGFnZV9zY2FsZV9wZXJjZW50OiBcInt7c2NhbGV9fSVcIixcbiAgbG9hZGluZ19lcnJvcjogXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHRoZSBQREYuXCIsXG4gIGludmFsaWRfZmlsZV9lcnJvcjogXCJJbnZhbGlkIG9yIGNvcnJ1cHRlZCBQREYgZmlsZS5cIixcbiAgbWlzc2luZ19maWxlX2Vycm9yOiBcIk1pc3NpbmcgUERGIGZpbGUuXCIsXG4gIHVuZXhwZWN0ZWRfcmVzcG9uc2VfZXJyb3I6IFwiVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UuXCIsXG4gIHJlbmRlcmluZ19lcnJvcjogXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZW5kZXJpbmcgdGhlIHBhZ2UuXCIsXG4gIGFubm90YXRpb25fZGF0ZV9zdHJpbmc6IFwie3tkYXRlfX0sIHt7dGltZX19XCIsXG4gIHByaW50aW5nX25vdF9zdXBwb3J0ZWQ6IFwiV2FybmluZzogUHJpbnRpbmcgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXCIsXG4gIHByaW50aW5nX25vdF9yZWFkeTogXCJXYXJuaW5nOiBUaGUgUERGIGlzIG5vdCBmdWxseSBsb2FkZWQgZm9yIHByaW50aW5nLlwiLFxuICB3ZWJfZm9udHNfZGlzYWJsZWQ6IFwiV2ViIGZvbnRzIGFyZSBkaXNhYmxlZDogdW5hYmxlIHRvIHVzZSBlbWJlZGRlZCBQREYgZm9udHMuXCIsXG4gIGZyZWVfdGV4dDJfZGVmYXVsdF9jb250ZW50OiBcIlN0YXJ0IHR5cGluZ+KAplwiLFxuICBlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsOiBcIlRleHQgRWRpdG9yXCIsXG4gIGVkaXRvcl9pbmsyX2FyaWFfbGFiZWw6IFwiRHJhdyBFZGl0b3JcIixcbiAgZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbDogXCJVc2VyLWNyZWF0ZWQgaW1hZ2VcIixcbiAgZWRpdG9yX2FsdF90ZXh0X2J1dHRvbl9sYWJlbDogXCJBbHQgdGV4dFwiLFxuICBlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWw6IFwiRWRpdCBhbHQgdGV4dFwiLFxuICBlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwOiBcIk1hcmtlZCBhcyBkZWNvcmF0aXZlXCJcbn07XG57XG4gIERFRkFVTFRfTDEwTl9TVFJJTkdTLnByaW50X3Byb2dyZXNzX3BlcmNlbnQgPSBcInt7cHJvZ3Jlc3N9fSVcIjtcbn1cbmZ1bmN0aW9uIGdldEwxMG5GYWxsYmFjayhrZXksIGFyZ3MpIHtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIFwiZmluZF9tYXRjaF9jb3VudFwiOlxuICAgICAga2V5ID0gYGZpbmRfbWF0Y2hfY291bnRbJHthcmdzLnRvdGFsID09PSAxID8gXCJvbmVcIiA6IFwib3RoZXJcIn1dYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaW5kX21hdGNoX2NvdW50X2xpbWl0XCI6XG4gICAgICBrZXkgPSBgZmluZF9tYXRjaF9jb3VudF9saW1pdFske2FyZ3MubGltaXQgPT09IDEgPyBcIm9uZVwiIDogXCJvdGhlclwifV1gO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIERFRkFVTFRfTDEwTl9TVFJJTkdTW2tleV0gfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIGZvcm1hdEwxMG5WYWx1ZSh0ZXh0LCBhcmdzKSB7XG4gIGlmICghYXJncykge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIHJldHVybiB0ZXh0LnJlcGxhY2VBbGwoL1xce1xce1xccyooXFx3KylcXHMqXFx9XFx9L2csIChhbGwsIG5hbWUpID0+IHtcbiAgICByZXR1cm4gbmFtZSBpbiBhcmdzID8gYXJnc1tuYW1lXSA6IFwie3tcIiArIG5hbWUgKyBcIn19XCI7XG4gIH0pO1xufVxuY29uc3QgTnVsbEwxMG4gPSB7XG4gIGFzeW5jIGdldExhbmd1YWdlKCkge1xuICAgIHJldHVybiBcImVuLXVzXCI7XG4gIH0sXG4gIGFzeW5jIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gXCJsdHJcIjtcbiAgfSxcbiAgYXN5bmMgZ2V0KGtleSwgYXJncyA9IG51bGwsIGZhbGxiYWNrID0gZ2V0TDEwbkZhbGxiYWNrKGtleSwgYXJncykpIHtcbiAgICByZXR1cm4gZm9ybWF0TDEwblZhbHVlKGZhbGxiYWNrLCBhcmdzKTtcbiAgfSxcbiAgYXN5bmMgdHJhbnNsYXRlKGVsZW1lbnQpIHt9XG59O1xuZXhwb3J0cy5OdWxsTDEwbiA9IE51bGxMMTBuO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlhmYUxheWVyID0gdm9pZCAwO1xudmFyIF94ZmFfdGV4dCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKHtcbiAgICBodG1sLFxuICAgIGVsZW1lbnQsXG4gICAgc3RvcmFnZSA9IG51bGwsXG4gICAgaW50ZW50LFxuICAgIGxpbmtTZXJ2aWNlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgaXNIVE1MQW5jaG9yRWxlbWVudCA9IGh0bWwgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YUlkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0Q29udGVudFwiOlxuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWlzSFRNTEFuY2hvckVsZW1lbnQgfHwga2V5ICE9PSBcImhyZWZcIiAmJiBrZXkgIT09IFwibmV3V2luZG93XCIpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGh0bWwsIGF0dHJpYnV0ZXMuaHJlZiwgYXR0cmlidXRlcy5uZXdXaW5kb3cpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSAmJiBhdHRyaWJ1dGVzLmRhdGFJZCkge1xuICAgICAgdGhpcy5zZXR1cFN0b3JhZ2UoaHRtbCwgYXR0cmlidXRlcy5kYXRhSWQsIGVsZW1lbnQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcbiAgICBpZiAocm9vdC5hdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBodG1sOiByb290SHRtbCxcbiAgICAgICAgZWxlbWVudDogcm9vdCxcbiAgICAgICAgaW50ZW50LFxuICAgICAgICBsaW5rU2VydmljZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW1tyb290LCAtMSwgcm9vdEh0bWxdXTtcbiAgICBjb25zdCByb290RGl2ID0gcGFyYW1ldGVycy5kaXY7XG4gICAgcm9vdERpdi5hcHBlbmQocm9vdEh0bWwpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG4gICAgaWYgKGludGVudCAhPT0gXCJyaWNoVGV4dFwiKSB7XG4gICAgICByb290RGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwieGZhTGF5ZXIgeGZhRm9udFwiKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dERpdnMgPSBbXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW3BhcmVudCwgaSwgaHRtbF0gPSBzdGFjay5hdCgtMSk7XG4gICAgICBpZiAoaSArIDEgPT09IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bKytzdGFjay5hdCgtMSlbMV1dO1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIGh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkSHRtbCA9IGNoaWxkPy5hdHRyaWJ1dGVzPy54bWxucyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhjaGlsZC5hdHRyaWJ1dGVzLnhtbG5zLCBuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgICBodG1sLmFwcGVuZChjaGlsZEh0bWwpO1xuICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICBodG1sOiBjaGlsZEh0bWwsXG4gICAgICAgICAgZWxlbWVudDogY2hpbGQsXG4gICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICBpbnRlbnQsXG4gICAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFjay5wdXNoKFtjaGlsZCwgLTEsIGNoaWxkSHRtbF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICBpZiAoX3hmYV90ZXh0LlhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHJvb3REaXYucXVlcnlTZWxlY3RvckFsbChcIi54ZmFOb25JbnRlcmFjdGl2ZSBpbnB1dCwgLnhmYU5vbkludGVyYWN0aXZlIHRleHRhcmVhXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREaXZzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG59XG5leHBvcnRzLlhmYUxheWVyID0gWGZhTGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuSW5rRWRpdG9yID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfYW5ub3RhdGlvbl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2Jhc2VIZWlnaHQgPSAwO1xuICAjYmFzZVdpZHRoID0gMDtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUgPSB0aGlzLmNhbnZhc1BvaW50ZXJtb3ZlLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSA9IHRoaXMuY2FudmFzUG9pbnRlcmxlYXZlLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJ1cCA9IHRoaXMuY2FudmFzUG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJkb3duID0gdGhpcy5jYW52YXNQb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAjY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgI2Rpc2FibGVFZGl0aW5nID0gZmFsc2U7XG4gICNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3JlYWxXaWR0aCA9IDA7XG4gICNyZWFsSGVpZ2h0ID0gMDtcbiAgI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTtcbiAgc3RhdGljIF90eXBlID0gXCJpbmtcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgbnVsbDtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgbnVsbDtcbiAgICB0aGlzLm9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBudWxsO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICB0aGlzLmJlemllclBhdGgyRCA9IFtdO1xuICAgIHRoaXMuYWxsUmF3UGF0aHMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IDE7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB7XG4gICAgICBzdHJpbmdzOiBbXCJlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsXCIsIFwiZWRpdG9yX2luazJfYXJpYV9sYWJlbFwiXVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgdGhpcy4jdXBkYXRlT3BhY2l0eSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgKiAxMDApXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCB0aGlzLnRoaWNrbmVzcyB8fCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCB0aGlzLmNvbG9yIHx8IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSwgTWF0aC5yb3VuZCgxMDAgKiAodGhpcy5vcGFjaXR5ID8/IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkpKV1dO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHNhdmVkVGhpY2tuZXNzO1xuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2xvciA9IHNhdmVkQ29sb3I7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZU9wYWNpdHkob3BhY2l0eSkge1xuICAgIG9wYWNpdHkgLz0gMTAwO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IHNhdmVkT3BhY2l0eTtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIH1cbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy4jb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCAmJiBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgcGFyZW50ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGluZ1wiKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHMubGVuZ3RoID09PSAwIHx8IHRoaXMucGF0aHMubGVuZ3RoID09PSAxICYmIHRoaXMucGF0aHNbMF0ubGVuZ3RoID09PSAwO1xuICB9XG4gICNnZXRJbml0aWFsQkJveCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRSb3RhdGlvbixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFt3aWR0aCwgaGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMCwgaGVpZ2h0LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIDAsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFswLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3NldFN0cm9rZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICB0aGlja25lc3MsXG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHNjYWxlRmFjdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcyAqIHBhcmVudFNjYWxlIC8gc2NhbGVGYWN0b3I7XG4gICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYCR7Y29sb3J9JHsoMCwgX3Rvb2xzLm9wYWNpdHlUb0hleCkob3BhY2l0eSl9YDtcbiAgfVxuICAjc3RhcnREcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVydXApO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgaWYgKCF0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICAgIHRoaXMudGhpY2tuZXNzIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3M7XG4gICAgICB0aGlzLmNvbG9yIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgICB0aGlzLm9wYWNpdHkgPz89IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy4jZHJhd1BvaW50cygpO1xuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gIH1cbiAgI2RyYXcoeCwgeSkge1xuICAgIGNvbnN0IFtsYXN0WCwgbGFzdFldID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID4gMSAmJiB4ID09PSBsYXN0WCAmJiB5ID09PSBsYXN0WSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgbGV0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IHRydWU7XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICAgIHBhdGgyRC5saW5lVG8oeCwgeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQgPSBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICB9XG4gICAgdGhpcy4jbWFrZUJlemllckN1cnZlKHBhdGgyRCwgLi4uY3VycmVudFBhdGguYXQoLTMpLCAuLi5jdXJyZW50UGF0aC5hdCgtMiksIHgsIHkpO1xuICB9XG4gICNlbmRQYXRoKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJELmxpbmVUbyguLi5sYXN0UG9pbnQpO1xuICB9XG4gICNzdG9wRHJhd2luZyh4LCB5KSB7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCAwKSwgdGhpcy5jYW52YXMud2lkdGgpO1xuICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCh5LCAwKSwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiNkcmF3KHgsIHkpO1xuICAgIHRoaXMuI2VuZFBhdGgoKTtcbiAgICBsZXQgYmV6aWVyO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCAhPT0gMSkge1xuICAgICAgYmV6aWVyID0gdGhpcy4jZ2VuZXJhdGVCZXppZXJQb2ludHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeHkgPSBbeCwgeV07XG4gICAgICBiZXppZXIgPSBbW3h5LCB4eS5zbGljZSgpLCB4eS5zbGljZSgpLCB4eV1dO1xuICAgIH1cbiAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNjdXJyZW50UGF0aDJEO1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnB1c2goY3VycmVudFBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKGJlemllcik7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5wYXRocy5wb3AoKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnBvcCgpO1xuICAgICAgaWYgKHRoaXMucGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI2RyYXdQb2ludHMoKSB7XG4gICAgaWYgKCF0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgY29uc3QgbGFzdFBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2xpY2UoLTMpO1xuICAgIGNvbnN0IHggPSBsYXN0UG9pbnRzLm1hcCh4eSA9PiB4eVswXSk7XG4gICAgY29uc3QgeSA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzFdKTtcbiAgICBjb25zdCB4TWluID0gTWF0aC5taW4oLi4ueCkgLSB0aGlja25lc3M7XG4gICAgY29uc3QgeE1heCA9IE1hdGgubWF4KC4uLngpICsgdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbiguLi55KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB5TWF4ID0gTWF0aC5tYXgoLi4ueSkgKyB0aGlja25lc3M7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSh0aGlzLiNjdXJyZW50UGF0aDJEKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gICNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY29uc3QgcHJldlggPSAoeDAgKyB4MSkgLyAyO1xuICAgIGNvbnN0IHByZXZZID0gKHkwICsgeTEpIC8gMjtcbiAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgY29uc3QgeTMgPSAoeTEgKyB5MikgLyAyO1xuICAgIHBhdGgyRC5iZXppZXJDdXJ2ZVRvKHByZXZYICsgMiAqICh4MSAtIHByZXZYKSAvIDMsIHByZXZZICsgMiAqICh5MSAtIHByZXZZKSAvIDMsIHgzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDMsIHgzLCB5Myk7XG4gIH1cbiAgI2dlbmVyYXRlQmV6aWVyUG9pbnRzKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIGlmIChwYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gW1twYXRoWzBdLCBwYXRoWzBdLCBwYXRoLmF0KC0xKSwgcGF0aC5hdCgtMSldXTtcbiAgICB9XG4gICAgY29uc3QgYmV6aWVyUG9pbnRzID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IFt4MCwgeTBdID0gcGF0aFswXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgcGF0aC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICAgIGNvbnN0IFt4MiwgeTJdID0gcGF0aFtpICsgMV07XG4gICAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICAgIGNvbnN0IGNvbnRyb2wyID0gW3gzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDNdO1xuICAgICAgYmV6aWVyUG9pbnRzLnB1c2goW1t4MCwgeTBdLCBjb250cm9sMSwgY29udHJvbDIsIFt4MywgeTNdXSk7XG4gICAgICBbeDAsIHkwXSA9IFt4MywgeTNdO1xuICAgIH1cbiAgICBjb25zdCBbeDEsIHkxXSA9IHBhdGhbaV07XG4gICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICBjb25zdCBjb250cm9sMiA9IFt4MiArIDIgKiAoeDEgLSB4MikgLyAzLCB5MiArIDIgKiAoeTEgLSB5MikgLyAzXTtcbiAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gyLCB5Ml1dKTtcbiAgICByZXR1cm4gYmV6aWVyUG9pbnRzO1xuICB9XG4gICNyZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzLFxuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgdGhpcy4jZml0VG9Db250ZW50KHRydWUpO1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMucGFyZW50LmFkZElua0VkaXRvcklmTmVlZGVkKHRydWUpO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZXZlbnQudHlwZSAhPT0gXCJtb3VzZVwiKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLiNzdGFydERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcm1vdmUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2RyYXcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICBjYW52YXNQb2ludGVybGVhdmUoZXZlbnQpIHtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICAjZW5kRHJhd2luZyhldmVudCkge1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybGVhdmUpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJtb3ZlKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcnVwKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgfSwgMTApO1xuICAgIHRoaXMuI3N0b3BEcmF3aW5nKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICAgIHRoaXMuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTmFtZSA9IFwiaW5rRWRpdG9yQ2FudmFzXCI7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuY2FudmFzPy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI29ic2VydmVyLm9ic2VydmUodGhpcy5kaXYpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpICYmIHRoaXMuI2Rpc2FibGVFZGl0aW5nO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuZGl2Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIGNvbnN0IFt4LCB5LCB3LCBoXSA9IHRoaXMuI2dldEluaXRpYWxCQm94KCk7XG4gICAgdGhpcy5zZXRBdCh4LCB5LCAwLCAwKTtcbiAgICB0aGlzLnNldERpbXModywgaCk7XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8odGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJlZGl0aW5nXCIpO1xuICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjc2V0Q2FudmFzRGltcygpIHtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCk7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByb3VuZGVkV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGlmICh0aGlzLiNyZWFsV2lkdGggPT09IHJvdW5kZWRXaWR0aCAmJiB0aGlzLiNyZWFsSGVpZ2h0ID09PSByb3VuZGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHJvdW5kZWRXaWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gcm91bmRlZEhlaWdodDtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgdGhpcy4jc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgdGhpcy5maXhEaW1zKCk7XG4gIH1cbiAgI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yVyA9ICh3aWR0aCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9ySCA9IChoZWlnaHQgLSBwYWRkaW5nKSAvIHRoaXMuI2Jhc2VIZWlnaHQ7XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IE1hdGgubWluKHNjYWxlRmFjdG9yVywgc2NhbGVGYWN0b3JIKTtcbiAgfVxuICAjdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCkgLyAyO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSh0aGlzLnNjYWxlRmFjdG9yLCAwLCAwLCB0aGlzLnNjYWxlRmFjdG9yLCB0aGlzLnRyYW5zbGF0aW9uWCAqIHRoaXMuc2NhbGVGYWN0b3IgKyBwYWRkaW5nLCB0aGlzLnRyYW5zbGF0aW9uWSAqIHRoaXMuc2NhbGVGYWN0b3IgKyBwYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgI2J1aWxkUGF0aDJEKGJlemllcikge1xuICAgIGNvbnN0IHBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gPSBiZXppZXJbaV07XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBwYXRoMkQubW92ZVRvKC4uLmZpcnN0KTtcbiAgICAgIH1cbiAgICAgIHBhdGgyRC5iZXppZXJDdXJ2ZVRvKGNvbnRyb2wxWzBdLCBjb250cm9sMVsxXSwgY29udHJvbDJbMF0sIGNvbnRyb2wyWzFdLCBzZWNvbmRbMF0sIHNlY29uZFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoMkQ7XG4gIH1cbiAgc3RhdGljICN0b1BERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgcm90YXRpb24pIHtcbiAgICBjb25zdCBbYmxYLCBibFksIHRyWCwgdHJZXSA9IHJlY3Q7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSArPSBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gcG9pbnRzW2kgKyAxXSArIGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0geCArIGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdICs9IGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0geDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgc3RhdGljICNmcm9tUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldIC09IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdIC0gYmxZO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4IC0gYmxYO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gLT0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clggLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplUGF0aHMocywgdHgsIHR5LCByZWN0KSB7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy50aGlja25lc3MgLyAyO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHMgKiB0eCArIHBhZGRpbmc7XG4gICAgY29uc3Qgc2hpZnRZID0gcyAqIHR5ICsgcGFkZGluZztcbiAgICBmb3IgKGNvbnN0IGJlemllciBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gYmV6aWVyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gPSBiZXppZXJbal07XG4gICAgICAgIGNvbnN0IHAxMCA9IHMgKiBmaXJzdFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDExID0gcyAqIGZpcnN0WzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMjAgPSBzICogY29udHJvbDFbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAyMSA9IHMgKiBjb250cm9sMVsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDMwID0gcyAqIGNvbnRyb2wyWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMzEgPSBzICogY29udHJvbDJbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHA0MCA9IHMgKiBzZWNvbmRbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHA0MSA9IHMgKiBzZWNvbmRbMV0gKyBzaGlmdFk7XG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChwMjAsIHAyMSwgcDMwLCBwMzEsIHA0MCwgcDQxKTtcbiAgICAgICAgcG9pbnRzLnB1c2gocDIwLCBwMjEpO1xuICAgICAgICBpZiAoaiA9PT0gamogLSAxKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDQwLCBwNDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgYmV6aWVyOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMoYnVmZmVyLCByZWN0LCB0aGlzLnJvdGF0aW9uKSxcbiAgICAgICAgcG9pbnRzOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCB0aGlzLnJvdGF0aW9uKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbiAgfVxuICAjZ2V0QmJveCgpIHtcbiAgICBsZXQgeE1pbiA9IEluZmluaXR5O1xuICAgIGxldCB4TWF4ID0gLUluZmluaXR5O1xuICAgIGxldCB5TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHlNYXggPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCBiYm94ID0gX3V0aWwuVXRpbC5iZXppZXJCb3VuZGluZ0JveCguLi5maXJzdCwgLi4uY29udHJvbDEsIC4uLmNvbnRyb2wyLCAuLi5zZWNvbmQpO1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgYmJveFswXSk7XG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCBiYm94WzFdKTtcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIGJib3hbMl0pO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgYmJveFszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbeE1pbiwgeU1pbiwgeE1heCwgeU1heF07XG4gIH1cbiAgI2dldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc2FibGVFZGl0aW5nID8gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSkgOiAwO1xuICB9XG4gICNmaXRUb0NvbnRlbnQoZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNnZXRCYm94KCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKTtcbiAgICB0aGlzLiNiYXNlV2lkdGggPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB0aGlzLiNiYXNlSGVpZ2h0ID0gTWF0aC5tYXgoX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VXaWR0aCAqIHRoaXMuc2NhbGVGYWN0b3IpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChwYWRkaW5nICsgdGhpcy4jYmFzZUhlaWdodCAqIHRoaXMuc2NhbGVGYWN0b3IpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25ZID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAtYmJveFswXTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IC1iYm94WzFdO1xuICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB0aGlzLiNyZWFsV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB1bnNjYWxlZFBhZGRpbmcgPSBmaXJzdFRpbWUgPyBwYWRkaW5nIC8gdGhpcy5zY2FsZUZhY3RvciAvIDIgOiAwO1xuICAgIHRoaXMudHJhbnNsYXRlKHByZXZUcmFuc2xhdGlvblggLSB0aGlzLnRyYW5zbGF0aW9uWCAtIHVuc2NhbGVkUGFkZGluZywgcHJldlRyYW5zbGF0aW9uWSAtIHRoaXMudHJhbnNsYXRpb25ZIC0gdW5zY2FsZWRQYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX2xheWVyLklua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci50aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICBlZGl0b3IuY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3Iub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IGVkaXRvci53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlZGl0b3IuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGVkaXRvci5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBwYWRkaW5nID0gZGF0YS50aGlja25lc3MgLyAyO1xuICAgIGVkaXRvci4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIGVkaXRvci4jcmVhbFdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgZWRpdG9yLiNyZWFsSGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhzLFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgZm9yIChsZXQge1xuICAgICAgYmV6aWVyXG4gICAgfSBvZiBwYXRocykge1xuICAgICAgYmV6aWVyID0gSW5rRWRpdG9yLiNmcm9tUERGQ29vcmRpbmF0ZXMoYmV6aWVyLCByZWN0LCByb3RhdGlvbik7XG4gICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICBlZGl0b3IucGF0aHMucHVzaChwYXRoKTtcbiAgICAgIGxldCBwMCA9IHNjYWxlRmFjdG9yICogKGJlemllclswXSAtIHBhZGRpbmcpO1xuICAgICAgbGV0IHAxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzFdIC0gcGFkZGluZyk7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBwMTAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaV0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDExID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAxXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMjAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDJdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgM10gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDMwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyA0XSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDVdIC0gcGFkZGluZyk7XG4gICAgICAgIHBhdGgucHVzaChbW3AwLCBwMV0sIFtwMTAsIHAxMV0sIFtwMjAsIHAyMV0sIFtwMzAsIHAzMV1dKTtcbiAgICAgICAgcDAgPSBwMzA7XG4gICAgICAgIHAxID0gcDMxO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aDJEID0gdGhpcy4jYnVpbGRQYXRoMkQocGF0aCk7XG4gICAgICBlZGl0b3IuYmV6aWVyUGF0aDJELnB1c2gocGF0aDJEKTtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IGVkaXRvci4jZ2V0QmJveCgpO1xuICAgIGVkaXRvci4jYmFzZVdpZHRoID0gTWF0aC5tYXgoX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgZWRpdG9yLiNiYXNlSGVpZ2h0ID0gTWF0aC5tYXgoX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgZWRpdG9yLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KDAsIDApO1xuICAgIGNvbnN0IGNvbG9yID0gX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmN0eC5zdHJva2VTdHlsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICBjb2xvcixcbiAgICAgIHRoaWNrbmVzczogdGhpcy50aGlja25lc3MsXG4gICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICBwYXRoczogdGhpcy4jc2VyaWFsaXplUGF0aHModGhpcy5zY2FsZUZhY3RvciAvIHRoaXMucGFyZW50U2NhbGUsIHRoaXMudHJhbnNsYXRpb25YLCB0aGlzLnRyYW5zbGF0aW9uWSwgcmVjdCksXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICB9XG59XG5leHBvcnRzLklua0VkaXRvciA9IElua0VkaXRvcjtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TdGFtcEVkaXRvciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG5jbGFzcyBTdGFtcEVkaXRvciBleHRlbmRzIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiaXRtYXAgPSBudWxsO1xuICAjYml0bWFwSWQgPSBudWxsO1xuICAjYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICNiaXRtYXBVcmwgPSBudWxsO1xuICAjYml0bWFwRmlsZSA9IG51bGw7XG4gICNjYW52YXMgPSBudWxsO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgI2lzU3ZnID0gZmFsc2U7XG4gICNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICBzdGF0aWMgX3R5cGUgPSBcInN0YW1wXCI7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwic3RhbXBFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2JpdG1hcFVybCA9IHBhcmFtcy5iaXRtYXBVcmw7XG4gICAgdGhpcy4jYml0bWFwRmlsZSA9IHBhcmFtcy5iaXRtYXBGaWxlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzKCkge1xuICAgIGNvbnN0IHR5cGVzID0gW1wiYXBuZ1wiLCBcImF2aWZcIiwgXCJibXBcIiwgXCJnaWZcIiwgXCJqcGVnXCIsIFwicG5nXCIsIFwic3ZnK3htbFwiLCBcIndlYnBcIiwgXCJ4LWljb25cIl07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwic3VwcG9ydGVkVHlwZXNcIiwgdHlwZXMubWFwKHR5cGUgPT4gYGltYWdlLyR7dHlwZX1gKSk7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlc1N0cigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJzdXBwb3J0ZWRUeXBlc1N0clwiLCB0aGlzLnN1cHBvcnRlZFR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLCB7XG4gICAgICBiaXRtYXBGaWxlOiBpdGVtLmdldEFzRmlsZSgpXG4gICAgfSk7XG4gIH1cbiAgI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgZnJvbUlkID0gZmFsc2UpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2JpdG1hcCA9IGRhdGEuYml0bWFwO1xuICAgIGlmICghZnJvbUlkKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLiNpc1N2ZyA9IGRhdGEuaXNTdmc7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICB9XG4gICNnZXRCaXRtYXBEb25lKCkge1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBpZiAodGhpcy4jY2FudmFzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3RhbXBFZGl0b3Iuc3VwcG9ydGVkVHlwZXNTdHI7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNiaXRtYXAgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5kZWxldGVJZCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICB0aGlzLiNjYW52YXM/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuI29ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMod2lkdGggKiBwYXJlbnRXaWR0aCAvIHBhZ2VXaWR0aCwgaGVpZ2h0ICogcGFyZW50SGVpZ2h0IC8gcGFnZUhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgZGl2LmFwcGVuZChjYW52YXMpO1xuICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgc3VidHlwZTogdGhpcy5lZGl0b3JUeXBlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQWx0VGV4dEJ1dHRvbigpO1xuICB9XG4gICNzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gIH1cbiAgI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IG5ld1dpZHRoID0gYml0bWFwV2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIHdoaWxlIChuZXdXaWR0aCA+IDIgKiB3aWR0aCB8fCBuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICBjb25zdCBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIGNvbnN0IHByZXZIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICBpZiAobmV3V2lkdGggPiAyICogd2lkdGgpIHtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3V2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld0hlaWdodCAvIDIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdG1hcDtcbiAgfVxuICAjZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcztcbiAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnN0IGJpdG1hcCA9IHRoaXMuI2lzU3ZnID8gdGhpcy4jYml0bWFwIDogdGhpcy4jc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAjc2VyaWFsaXplQml0bWFwKHRvVXJsKSB7XG4gICAgaWYgKHRvVXJsKSB7XG4gICAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRTdmdVcmwodGhpcy4jYml0bWFwSWQpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICh7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfSA9IHRoaXMuI2JpdG1hcCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDApO1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwLCB0aGlzLiNiaXRtYXAud2lkdGgsIHRoaXMuI2JpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLiNiaXRtYXApO1xuICB9XG4gICNjcmVhdGVPYnNlcnZlcigpIHtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy4jc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9sYXllci5TdGFtcEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci4jYml0bWFwVXJsID0gYml0bWFwVXJsO1xuICAgIH1cbiAgICBlZGl0b3IuI2lzU3ZnID0gaXNTdmc7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYXJlbnRXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIGVkaXRvci5hbHRUZXh0RGF0YSA9IGFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuYWx0VGV4dERhdGE7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5hbHRUZXh0RGF0YTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG59XG5leHBvcnRzLlN0YW1wRWRpdG9yID0gU3RhbXBFZGl0b3I7XG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dfcGRmanNfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4oKCkgPT4ge1xudmFyIGV4cG9ydHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFib3J0RXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5BYm9ydEV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvckxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIuQW5ub3RhdGlvbkVkaXRvckxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JUeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3Rvb2xzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25MYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fubm90YXRpb25fbGF5ZXIuQW5ub3RhdGlvbkxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTW9kZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbk1vZGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNNYXBDb21wcmVzc2lvblR5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRPTVNWR0ZhY3RvcnlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3Rvcnk7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZlYXR1cmVUZXN0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5GZWF0dXJlVGVzdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2xvYmFsV29ya2VyT3B0aW9uc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltYWdlS2luZFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuSW1hZ2VLaW5kO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5JbnZhbGlkUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPUFNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLk9QUztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0YVJhbmdlVHJhbnNwb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0ZVN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGV29ya2VyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlBERldvcmtlcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFzc3dvcmRSZXNwb25zZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlBhc3N3b3JkUmVzcG9uc2VzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtaXNzaW9uRmxhZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGVybWlzc2lvbkZsYWc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpeGVsc1BlckluY2hcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2g7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VDYXBhYmlsaXR5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlNWR0dyYXBoaWNzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRpbFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmVyYm9zaXR5TGV2ZWxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlZlcmJvc2l0eUxldmVsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYZmFMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3hmYV9sYXllci5YZmFMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVpbGRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuYnVpbGQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvY3VtZW50XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmdldERvY3VtZW50O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRQZGZGaWxlbmFtZUZyb21Vcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFhmYVBhZ2VWaWV3cG9ydFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0WGZhUGFnZVZpZXdwb3J0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RhdGFTY2hlbWVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmlzRGF0YVNjaGVtZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNQZGZGaWxlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5pc1BkZkZpbGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRTY3JpcHRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmxvYWRTY3JpcHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vQ29udGV4dE1lbnVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVVuaWNvZGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLm5vcm1hbGl6ZVVuaWNvZGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbmRlclRleHRMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RleHRfbGF5ZXIucmVuZGVyVGV4dExheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRMYXllckRpbWVuc2lvbnNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhZG93XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5zaGFkb3c7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVwZGF0ZVRleHRMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RleHRfbGF5ZXIudXBkYXRlVGV4dExheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLnZlcnNpb247XG4gIH1cbn0pKTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2FwaSA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF90ZXh0X2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgX2Fubm90YXRpb25fZWRpdG9yX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcbnZhciBfYW5ub3RhdGlvbl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIF94ZmFfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbmNvbnN0IHBkZmpzVmVyc2lvbiA9ICczLjExLjE3NCc7XG5jb25zdCBwZGZqc0J1aWxkID0gJ2NlODcxNjc0Myc7XG59KSgpO1xuXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGYuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicGRmanNMaWIiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIlZlcmJvc2l0eUxldmVsIiwiVXRpbCIsIlVua25vd25FcnJvckV4Y2VwdGlvbiIsIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiIsIlRleHRSZW5kZXJpbmdNb2RlIiwiUmVuZGVyaW5nSW50ZW50RmxhZyIsIlByb21pc2VDYXBhYmlsaXR5IiwiUGVybWlzc2lvbkZsYWciLCJQYXNzd29yZFJlc3BvbnNlcyIsIlBhc3N3b3JkRXhjZXB0aW9uIiwiUGFnZUFjdGlvbkV2ZW50VHlwZSIsIk9QUyIsIk1pc3NpbmdQREZFeGNlcHRpb24iLCJNQVhfSU1BR0VfU0laRV9UT19DQUNIRSIsIkxJTkVfRkFDVE9SIiwiTElORV9ERVNDRU5UX0ZBQ1RPUiIsIkludmFsaWRQREZFeGNlcHRpb24iLCJJbWFnZUtpbmQiLCJJREVOVElUWV9NQVRSSVgiLCJGb3JtYXRFcnJvciIsIkZlYXR1cmVUZXN0IiwiRk9OVF9JREVOVElUWV9NQVRSSVgiLCJEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSIsIkNNYXBDb21wcmVzc2lvblR5cGUiLCJCYXNlRXhjZXB0aW9uIiwiQkFTRUxJTkVfRkFDVE9SIiwiQW5ub3RhdGlvblR5cGUiLCJBbm5vdGF0aW9uUmVwbHlUeXBlIiwiQW5ub3RhdGlvblByZWZpeCIsIkFubm90YXRpb25Nb2RlIiwiQW5ub3RhdGlvbkZsYWciLCJBbm5vdGF0aW9uRmllbGRGbGFnIiwiQW5ub3RhdGlvbkVkaXRvclR5cGUiLCJBbm5vdGF0aW9uRWRpdG9yUHJlZml4IiwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUiLCJBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIiwiQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSIsIkFib3J0RXhjZXB0aW9uIiwiYXNzZXJ0IiwiYnl0ZXNUb1N0cmluZyIsImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwiLCJnZXRNb2RpZmljYXRpb25EYXRlIiwiZ2V0VXVpZCIsImdldFZlcmJvc2l0eUxldmVsIiwiaW5mbyIsImlzQXJyYXlCdWZmZXIiLCJpc0FycmF5RXF1YWwiLCJpc05vZGVKUyIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJvYmplY3RGcm9tTWFwIiwib2JqZWN0U2l6ZSIsInNldFZlcmJvc2l0eUxldmVsIiwic2hhZG93Iiwic3RyaW5nMzIiLCJzdHJpbmdUb0J5dGVzIiwic3RyaW5nVG9QREZTdHJpbmciLCJzdHJpbmdUb1VURjhTdHJpbmciLCJ1bnJlYWNoYWJsZSIsInV0ZjhTdHJpbmdUb1N0cmluZyIsIndhcm4iLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJudyIsImVsZWN0cm9uIiwidHlwZSIsIkFOWSIsIkRJU1BMQVkiLCJQUklOVCIsIlNBVkUiLCJBTk5PVEFUSU9OU19GT1JNUyIsIkFOTk9UQVRJT05TX1NUT1JBR0UiLCJBTk5PVEFUSU9OU19ESVNBQkxFIiwiT1BMSVNUIiwiRElTQUJMRSIsIkVOQUJMRSIsIkVOQUJMRV9GT1JNUyIsIkVOQUJMRV9TVE9SQUdFIiwiTk9ORSIsIkZSRUVURVhUIiwiU1RBTVAiLCJJTksiLCJSRVNJWkUiLCJDUkVBVEUiLCJGUkVFVEVYVF9TSVpFIiwiRlJFRVRFWFRfQ09MT1IiLCJGUkVFVEVYVF9PUEFDSVRZIiwiSU5LX0NPTE9SIiwiSU5LX1RISUNLTkVTUyIsIklOS19PUEFDSVRZIiwiTU9ESUZZX0NPTlRFTlRTIiwiQ09QWSIsIk1PRElGWV9BTk5PVEFUSU9OUyIsIkZJTExfSU5URVJBQ1RJVkVfRk9STVMiLCJDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZIiwiQVNTRU1CTEUiLCJQUklOVF9ISUdIX1FVQUxJVFkiLCJGSUxMIiwiU1RST0tFIiwiRklMTF9TVFJPS0UiLCJJTlZJU0lCTEUiLCJGSUxMX0FERF9UT19QQVRIIiwiU1RST0tFX0FERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfQUREX1RPX1BBVEgiLCJBRERfVE9fUEFUSCIsIkZJTExfU1RST0tFX01BU0siLCJBRERfVE9fUEFUSF9GTEFHIiwiR1JBWVNDQUxFXzFCUFAiLCJSR0JfMjRCUFAiLCJSR0JBXzMyQlBQIiwiVEVYVCIsIkxJTksiLCJMSU5FIiwiU1FVQVJFIiwiQ0lSQ0xFIiwiUE9MWUdPTiIsIlBPTFlMSU5FIiwiSElHSExJR0hUIiwiVU5ERVJMSU5FIiwiU1FVSUdHTFkiLCJTVFJJS0VPVVQiLCJDQVJFVCIsIlBPUFVQIiwiRklMRUFUVEFDSE1FTlQiLCJTT1VORCIsIk1PVklFIiwiV0lER0VUIiwiU0NSRUVOIiwiUFJJTlRFUk1BUksiLCJUUkFQTkVUIiwiV0FURVJNQVJLIiwiVEhSRUVEIiwiUkVEQUNUIiwiR1JPVVAiLCJSRVBMWSIsIkhJRERFTiIsIk5PWk9PTSIsIk5PUk9UQVRFIiwiTk9WSUVXIiwiUkVBRE9OTFkiLCJMT0NLRUQiLCJUT0dHTEVOT1ZJRVciLCJMT0NLRURDT05URU5UUyIsIlJFUVVJUkVEIiwiTk9FWFBPUlQiLCJNVUxUSUxJTkUiLCJQQVNTV09SRCIsIk5PVE9HR0xFVE9PRkYiLCJSQURJTyIsIlBVU0hCVVRUT04iLCJDT01CTyIsIkVESVQiLCJTT1JUIiwiRklMRVNFTEVDVCIsIk1VTFRJU0VMRUNUIiwiRE9OT1RTUEVMTENIRUNLIiwiRE9OT1RTQ1JPTEwiLCJDT01CIiwiUklDSFRFWFQiLCJSQURJT1NJTlVOSVNPTiIsIkNPTU1JVE9OU0VMQ0hBTkdFIiwiU09MSUQiLCJEQVNIRUQiLCJCRVZFTEVEIiwiSU5TRVQiLCJFIiwiWCIsIkQiLCJVIiwiRm8iLCJCbCIsIlBPIiwiUEMiLCJQViIsIlBJIiwiSyIsIkYiLCJWIiwiQyIsIldDIiwiV1MiLCJEUyIsIldQIiwiRFAiLCJPIiwiRVJST1JTIiwiV0FSTklOR1MiLCJJTkZPUyIsIkJJTkFSWSIsImRlcGVuZGVuY3kiLCJzZXRMaW5lV2lkdGgiLCJzZXRMaW5lQ2FwIiwic2V0TGluZUpvaW4iLCJzZXRNaXRlckxpbWl0Iiwic2V0RGFzaCIsInNldFJlbmRlcmluZ0ludGVudCIsInNldEZsYXRuZXNzIiwic2V0R1N0YXRlIiwic2F2ZSIsInJlc3RvcmUiLCJ0cmFuc2Zvcm0iLCJtb3ZlVG8iLCJsaW5lVG8iLCJjdXJ2ZVRvIiwiY3VydmVUbzIiLCJjdXJ2ZVRvMyIsImNsb3NlUGF0aCIsInJlY3RhbmdsZSIsInN0cm9rZSIsImNsb3NlU3Ryb2tlIiwiZmlsbCIsImVvRmlsbCIsImZpbGxTdHJva2UiLCJlb0ZpbGxTdHJva2UiLCJjbG9zZUZpbGxTdHJva2UiLCJjbG9zZUVPRmlsbFN0cm9rZSIsImVuZFBhdGgiLCJjbGlwIiwiZW9DbGlwIiwiYmVnaW5UZXh0IiwiZW5kVGV4dCIsInNldENoYXJTcGFjaW5nIiwic2V0V29yZFNwYWNpbmciLCJzZXRIU2NhbGUiLCJzZXRMZWFkaW5nIiwic2V0Rm9udCIsInNldFRleHRSZW5kZXJpbmdNb2RlIiwic2V0VGV4dFJpc2UiLCJtb3ZlVGV4dCIsInNldExlYWRpbmdNb3ZlVGV4dCIsInNldFRleHRNYXRyaXgiLCJuZXh0TGluZSIsInNob3dUZXh0Iiwic2hvd1NwYWNlZFRleHQiLCJuZXh0TGluZVNob3dUZXh0IiwibmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQiLCJzZXRDaGFyV2lkdGgiLCJzZXRDaGFyV2lkdGhBbmRCb3VuZHMiLCJzZXRTdHJva2VDb2xvclNwYWNlIiwic2V0RmlsbENvbG9yU3BhY2UiLCJzZXRTdHJva2VDb2xvciIsInNldFN0cm9rZUNvbG9yTiIsInNldEZpbGxDb2xvciIsInNldEZpbGxDb2xvck4iLCJzZXRTdHJva2VHcmF5Iiwic2V0RmlsbEdyYXkiLCJzZXRTdHJva2VSR0JDb2xvciIsInNldEZpbGxSR0JDb2xvciIsInNldFN0cm9rZUNNWUtDb2xvciIsInNldEZpbGxDTVlLQ29sb3IiLCJzaGFkaW5nRmlsbCIsImJlZ2luSW5saW5lSW1hZ2UiLCJiZWdpbkltYWdlRGF0YSIsImVuZElubGluZUltYWdlIiwicGFpbnRYT2JqZWN0IiwibWFya1BvaW50IiwibWFya1BvaW50UHJvcHMiLCJiZWdpbk1hcmtlZENvbnRlbnQiLCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyIsImVuZE1hcmtlZENvbnRlbnQiLCJiZWdpbkNvbXBhdCIsImVuZENvbXBhdCIsInBhaW50Rm9ybVhPYmplY3RCZWdpbiIsInBhaW50Rm9ybVhPYmplY3RFbmQiLCJiZWdpbkdyb3VwIiwiZW5kR3JvdXAiLCJiZWdpbkFubm90YXRpb24iLCJlbmRBbm5vdGF0aW9uIiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0IiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cCIsInBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0IiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0IiwicGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrIiwiY29uc3RydWN0UGF0aCIsIk5FRURfUEFTU1dPUkQiLCJJTkNPUlJFQ1RfUEFTU1dPUkQiLCJ2ZXJib3NpdHkiLCJsZXZlbCIsIk51bWJlciIsImlzSW50ZWdlciIsIm1zZyIsImNvbnNvbGUiLCJsb2ciLCJFcnJvciIsImNvbmQiLCJfaXNWYWxpZFByb3RvY29sIiwidXJsIiwicHJvdG9jb2wiLCJiYXNlVXJsIiwib3B0aW9ucyIsImFkZERlZmF1bHRQcm90b2NvbCIsInN0YXJ0c1dpdGgiLCJkb3RzIiwibWF0Y2giLCJsZW5ndGgiLCJ0cnlDb252ZXJ0RW5jb2RpbmciLCJhYnNvbHV0ZVVybCIsIlVSTCIsIm9iaiIsInByb3AiLCJub25TZXJpYWxpemFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIm1lc3NhZ2UiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJjb2RlIiwiZGV0YWlscyIsInN0YXR1cyIsImJ5dGVzIiwidW5kZWZpbmVkIiwiTUFYX0FSR1VNRU5UX0NPVU5UIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJzdHJCdWYiLCJpIiwiY2h1bmtFbmQiLCJNYXRoIiwibWluIiwiY2h1bmsiLCJzdWJhcnJheSIsInB1c2giLCJqb2luIiwic3RyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJrZXlzIiwibWFwIiwiY3JlYXRlIiwia2V5IiwiaXNMaXR0bGVFbmRpYW4iLCJidWZmZXI4IiwidmlldzMyIiwiVWludDMyQXJyYXkiLCJidWZmZXIiLCJpc0V2YWxTdXBwb3J0ZWQiLCJGdW5jdGlvbiIsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwicGxhdGZvcm0iLCJuYXZpZ2F0b3IiLCJpc1dpbiIsImlzTWFjIiwiaW5jbHVkZXMiLCJpc0NTU1JvdW5kU3VwcG9ydGVkIiwiQ1NTIiwic3VwcG9ydHMiLCJoZXhOdW1iZXJzIiwiQXJyYXkiLCJuIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1ha2VIZXhDb2xvciIsInIiLCJnIiwiYiIsInNjYWxlTWluTWF4IiwibWluTWF4IiwidGVtcCIsIm0xIiwibTIiLCJhcHBseVRyYW5zZm9ybSIsInAiLCJtIiwieHQiLCJ5dCIsImFwcGx5SW52ZXJzZVRyYW5zZm9ybSIsImQiLCJnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveCIsInAxIiwicDIiLCJzbGljZSIsInAzIiwicDQiLCJtYXgiLCJpbnZlcnNlVHJhbnNmb3JtIiwic2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUiLCJ0cmFuc3Bvc2UiLCJhIiwiYyIsImZpcnN0Iiwic2Vjb25kIiwic3FydCIsInN4Iiwic3kiLCJub3JtYWxpemVSZWN0IiwicmVjdCIsImludGVyc2VjdCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJiZXppZXJCb3VuZGluZ0JveCIsIngwIiwieTAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ0dmFsdWVzIiwiYm91bmRzIiwidCIsInQxIiwidDIiLCJiMmFjIiwic3FydGIyYWMiLCJhYnMiLCJqIiwibXQiLCJqbGVuIiwiUERGU3RyaW5nVHJhbnNsYXRlVGFibGUiLCJlbmNvZGluZyIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlIiwiZXgiLCJpaSIsImNoYXJBdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidiIsImJ5dGVMZW5ndGgiLCJhcnIxIiwiYXJyMiIsImRhdGUiLCJEYXRlIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwic2V0dGxlZCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRhdGEiLCJyZWFzb24iLCJOb3JtYWxpemVSZWdleCIsIk5vcm1hbGl6YXRpb25NYXAiLCJNYXAiLCJyZXBsYWNlQWxsIiwiXyIsIm5vcm1hbGl6ZSIsImdldCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJidWYiLCJnZXRSYW5kb21WYWx1ZXMiLCJmbG9vciIsInJhbmRvbSIsIl9fd19wZGZqc19yZXF1aXJlX18iLCJSZW5kZXJUYXNrIiwiUERGV29ya2VyVXRpbCIsIlBERldvcmtlciIsIlBERlBhZ2VQcm94eSIsIlBERkRvY3VtZW50UHJveHkiLCJQREZEb2N1bWVudExvYWRpbmdUYXNrIiwiUERGRGF0YVJhbmdlVHJhbnNwb3J0IiwiTG9vcGJhY2tQb3J0IiwiRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiRGVmYXVsdEZpbHRlckZhY3RvcnkiLCJEZWZhdWx0Q2FudmFzRmFjdG9yeSIsIkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSIsIl9kaXNwbGF5U3ZnIiwiU1ZHR3JhcGhpY3MiLCJidWlsZCIsImdldERvY3VtZW50IiwidmVyc2lvbiIsIl91dGlsIiwiX2Fubm90YXRpb25fc3RvcmFnZSIsIl9kaXNwbGF5X3V0aWxzIiwiX2ZvbnRfbG9hZGVyIiwiX2Rpc3BsYXlOb2RlX3V0aWxzIiwiX2NhbnZhcyIsIl93b3JrZXJfb3B0aW9ucyIsIl9tZXNzYWdlX2hhbmRsZXIiLCJfbWV0YWRhdGEiLCJfb3B0aW9uYWxfY29udGVudF9jb25maWciLCJfdHJhbnNwb3J0X3N0cmVhbSIsIl9kaXNwbGF5RmV0Y2hfc3RyZWFtIiwiX2Rpc3BsYXlOZXR3b3JrIiwiX2Rpc3BsYXlOb2RlX3N0cmVhbSIsIl94ZmFfdGV4dCIsIkRFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSIsIlJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCIsIkRFTEFZRURfQ0xFQU5VUF9USU1FT1VUIiwiTm9kZUNhbnZhc0ZhY3RvcnkiLCJET01DYW52YXNGYWN0b3J5IiwiTm9kZUNNYXBSZWFkZXJGYWN0b3J5IiwiRE9NQ01hcFJlYWRlckZhY3RvcnkiLCJOb2RlRmlsdGVyRmFjdG9yeSIsIkRPTUZpbHRlckZhY3RvcnkiLCJOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsInNyYyIsInJhbmdlIiwidGFzayIsImRvY0lkIiwiZ2V0VXJsUHJvcCIsImdldERhdGFQcm9wIiwiaHR0cEhlYWRlcnMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0IiwicmFuZ2VDaHVua1NpemUiLCJ3b3JrZXIiLCJkb2NCYXNlVXJsIiwiaXNEYXRhU2NoZW1lIiwiY01hcFVybCIsImNNYXBQYWNrZWQiLCJDTWFwUmVhZGVyRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsImlnbm9yZUVycm9ycyIsInN0b3BBdEVycm9ycyIsIm1heEltYWdlU2l6ZSIsImNhbnZhc01heEFyZWFJbkJ5dGVzIiwiZGlzYWJsZUZvbnRGYWNlIiwiZm9udEV4dHJhUHJvcGVydGllcyIsImVuYWJsZVhmYSIsIm93bmVyRG9jdW1lbnQiLCJkb2N1bWVudCIsImRpc2FibGVSYW5nZSIsImRpc2FibGVTdHJlYW0iLCJkaXNhYmxlQXV0b0ZldGNoIiwicGRmQnVnIiwiTmFOIiwidXNlU3lzdGVtRm9udHMiLCJ1c2VXb3JrZXJGZXRjaCIsImlzVmFsaWRGZXRjaFVybCIsImJhc2VVUkkiLCJjYW52YXNGYWN0b3J5IiwiZmlsdGVyRmFjdG9yeSIsInN0eWxlRWxlbWVudCIsInRyYW5zcG9ydEZhY3RvcnkiLCJjTWFwUmVhZGVyRmFjdG9yeSIsImlzQ29tcHJlc3NlZCIsInN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwid29ya2VyUGFyYW1zIiwicG9ydCIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJ3b3JrZXJQb3J0IiwiZnJvbVBvcnQiLCJfd29ya2VyIiwiZmV0Y2hEb2NQYXJhbXMiLCJhcGlWZXJzaW9uIiwiZXZhbHVhdG9yT3B0aW9ucyIsInRyYW5zcG9ydFBhcmFtcyIsInRoZW4iLCJkZXN0cm95ZWQiLCJ3b3JrZXJJZFByb21pc2UiLCJfZmV0Y2hEb2N1bWVudCIsIm5ldHdvcmtTdHJlYW1Qcm9taXNlIiwibmV0d29ya1N0cmVhbSIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0iLCJpbml0aWFsRGF0YSIsInByb2dyZXNzaXZlRG9uZSIsImNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiY3JlYXRlUERGTmV0d29ya1N0cmVhbSIsInBhcmFtcyIsIlBERk5vZGVTdHJlYW0iLCJQREZGZXRjaFN0cmVhbSIsIlBERk5ldHdvcmtTdHJlYW0iLCJhbGwiLCJ3b3JrZXJJZCIsIm1lc3NhZ2VIYW5kbGVyIiwiTWVzc2FnZUhhbmRsZXIiLCJ0cmFuc3BvcnQiLCJXb3JrZXJUcmFuc3BvcnQiLCJfdHJhbnNwb3J0Iiwic2VuZCIsImNhdGNoIiwiX2NhcGFiaWxpdHkiLCJzb3VyY2UiLCJzZW5kV2l0aFByb21pc2UiLCJ2YWwiLCJocmVmIiwid2luZG93IiwibG9jYXRpb24iLCJCdWZmZXIiLCJpc05hTiIsIm9uUGFzc3dvcmQiLCJvblByb2dyZXNzIiwiZGVzdHJveSIsIl9wZW5kaW5nRGVzdHJveSIsIl9yYW5nZUxpc3RlbmVycyIsIl9wcm9ncmVzc0xpc3RlbmVycyIsIl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwiX3JlYWR5Q2FwYWJpbGl0eSIsImFkZFJhbmdlTGlzdGVuZXIiLCJsaXN0ZW5lciIsImFkZFByb2dyZXNzTGlzdGVuZXIiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwib25EYXRhUmFuZ2UiLCJiZWdpbiIsIm9uRGF0YVByb2dyZXNzIiwibG9hZGVkIiwidG90YWwiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJ0cmFuc3BvcnRSZWFkeSIsInJlcXVlc3REYXRhUmFuZ2UiLCJlbmQiLCJhYm9ydCIsInBkZkluZm8iLCJfcGRmSW5mbyIsImRlcHJlY2F0ZWQiLCJnZXRKU0FjdGlvbnMiLCJqcyIsImpzQXJyIiwiYW5ub3RhdGlvblN0b3JhZ2UiLCJudW1QYWdlcyIsImZpbmdlcnByaW50cyIsImlzUHVyZVhmYSIsIl9odG1sRm9yWGZhIiwiYWxsWGZhSHRtbCIsImdldFBhZ2UiLCJwYWdlTnVtYmVyIiwiZ2V0UGFnZUluZGV4IiwicmVmIiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJpZCIsImdldFBhZ2VMYWJlbHMiLCJnZXRQYWdlTGF5b3V0IiwiZ2V0UGFnZU1vZGUiLCJnZXRWaWV3ZXJQcmVmZXJlbmNlcyIsImdldE9wZW5BY3Rpb24iLCJnZXRBdHRhY2htZW50cyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJnZXREYXRhIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImNsZWFudXAiLCJrZWVwTG9hZGVkRm9udHMiLCJzdGFydENsZWFudXAiLCJsb2FkaW5nVGFzayIsImxvYWRpbmdQYXJhbXMiLCJnZXRGaWVsZE9iamVjdHMiLCJoYXNKU0FjdGlvbnMiLCJnZXRDYWxjdWxhdGlvbk9yZGVySWRzIiwiZGVsYXllZENsZWFudXBUaW1lb3V0IiwicGVuZGluZ0NsZWFudXAiLCJwYWdlSW5kZXgiLCJwYWdlSW5mbyIsIl9wYWdlSW5kZXgiLCJfcGFnZUluZm8iLCJfc3RhdHMiLCJTdGF0VGltZXIiLCJfcGRmQnVnIiwiY29tbW9uT2JqcyIsIm9ianMiLCJQREZPYmplY3RzIiwiX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIiwiX2ludGVudFN0YXRlcyIsInJvdGF0ZSIsInVzZXJVbml0IiwidmlldyIsImdldFZpZXdwb3J0Iiwic2NhbGUiLCJyb3RhdGlvbiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZG9udEZsaXAiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94IiwiZ2V0QW5ub3RhdGlvbnMiLCJpbnRlbnQiLCJpbnRlbnRBcmdzIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwicmVuZGVyaW5nSW50ZW50IiwiZ2V0UGFnZUpTQWN0aW9ucyIsImdldFhmYSIsImNoaWxkcmVuIiwicmVuZGVyIiwiY2FudmFzQ29udGV4dCIsInZpZXdwb3J0IiwiYW5ub3RhdGlvbk1vZGUiLCJiYWNrZ3JvdW5kIiwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSIsImFubm90YXRpb25DYW52YXNNYXAiLCJwYWdlQ29sb3JzIiwicHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsInRpbWUiLCJhYm9ydERlbGF5ZWRDbGVhbnVwIiwiaW50ZW50U3RhdGUiLCJjYWNoZUtleSIsInNldCIsInN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJpbnRlbnRQcmludCIsImRpc3BsYXlSZWFkeUNhcGFiaWxpdHkiLCJvcGVyYXRvckxpc3QiLCJmbkFycmF5IiwiYXJnc0FycmF5IiwibGFzdENodW5rIiwic2VwYXJhdGVBbm5vdHMiLCJfcHVtcE9wZXJhdG9yTGlzdCIsImNvbXBsZXRlIiwiZXJyb3IiLCJyZW5kZXJUYXNrcyIsImRlbGV0ZSIsImludGVybmFsUmVuZGVyVGFzayIsInRyeUNsZWFudXAiLCJjYXBhYmlsaXR5IiwiX2Fib3J0T3BlcmF0b3JMaXN0IiwidGltZUVuZCIsIkludGVybmFsUmVuZGVyVGFzayIsImNhbGxiYWNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiU2V0IiwiYWRkIiwicmVuZGVyVGFzayIsInRyYW5zcGFyZW5jeSIsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsInNlbmRXaXRoU3RyZWFtIiwiaGlnaFdhdGVyTWFyayIsInNpemUiLCJ0ZXh0Q29udGVudCIsIml0ZW1zIiwiZ2V0VGV4dENvbnRlbnQiLCJ4ZmEiLCJYZmFUZXh0IiwicmVhZGFibGVTdHJlYW0iLCJwdW1wIiwicmVhZGVyIiwicmVhZCIsImRvbmUiLCJhc3NpZ24iLCJzdHlsZXMiLCJnZXRSZWFkZXIiLCJnZXRTdHJ1Y3RUcmVlIiwiX2Rlc3Ryb3kiLCJ3YWl0T24iLCJ2YWx1ZXMiLCJmb3JjZSIsImNvbXBsZXRlZCIsImNhbmNlbCIsImNsZWFyIiwicmVzZXRTdGF0cyIsInN1Y2Nlc3MiLCJkZWxheWVkIiwic2V0VGltZW91dCIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInRyYW5zZmVycyIsInN0cmVhbVJlYWRlciIsIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiIsImRlbGF5IiwiZXh0cmFEZWxheSIsImN1ckNhY2hlS2V5IiwiY3VySW50ZW50U3RhdGUiLCJzdGF0cyIsImxpc3RlbmVycyIsImRlZmVycmVkIiwicG9zdE1lc3NhZ2UiLCJ0cmFuc2ZlciIsImV2ZW50Iiwic3RydWN0dXJlZENsb25lIiwiY2FsbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidGVybWluYXRlIiwiaXNXb3JrZXJEaXNhYmxlZCIsImZhbGxiYWNrV29ya2VyU3JjIiwiZmFrZVdvcmtlcklkIiwicmVxdWlyZSIsInBkZmpzRmlsZVBhdGgiLCJjdXJyZW50U2NyaXB0IiwicmVwbGFjZSIsImlzU2FtZU9yaWdpbiIsIm90aGVyVXJsIiwiYmFzZSIsIm9yaWdpbiIsIm90aGVyIiwiY3JlYXRlQ0ROV3JhcHBlciIsIndyYXBwZXIiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwid29ya2VyUG9ydHMiLCJfcG9ydCIsIl93ZWJXb3JrZXIiLCJfbWVzc2FnZUhhbmRsZXIiLCJoYXMiLCJXZWFrTWFwIiwiX2luaXRpYWxpemVGcm9tUG9ydCIsIl9pbml0aWFsaXplIiwib24iLCJfbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyIiwid29ya2VyU3JjIiwiV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJvbldvcmtlckVycm9yIiwiX3NldHVwRmFrZVdvcmtlciIsInNlbmRUZXN0IiwidGVzdE9iaiIsIl9zZXR1cEZha2VXb3JrZXJHbG9iYWwiLCJXb3JrZXJNZXNzYWdlSGFuZGxlciIsIndvcmtlckhhbmRsZXIiLCJzZXR1cCIsImNhY2hlZFBvcnQiLCJwZGZqc1dvcmtlciIsImxvYWRlciIsIm1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciIsImV2YWwiLCJsb2FkU2NyaXB0IiwibWV0aG9kUHJvbWlzZXMiLCJwYWdlQ2FjaGUiLCJwYWdlUHJvbWlzZXMiLCJwYXNzd29yZENhcGFiaWxpdHkiLCJmb250TG9hZGVyIiwiRm9udExvYWRlciIsIl9wYXJhbXMiLCJkZXN0cm95Q2FwYWJpbGl0eSIsIl9uZXR3b3JrU3RyZWFtIiwiX2Z1bGxSZWFkZXIiLCJfbGFzdFByb2dyZXNzIiwic2V0dXBNZXNzYWdlSGFuZGxlciIsImNhY2hlU2ltcGxlTWV0aG9kIiwiY2FjaGVkUHJvbWlzZSIsIkFubm90YXRpb25TdG9yYWdlIiwiaXNPcExpc3QiLCJTZXJpYWxpemFibGVFbXB0eSIsIlByaW50QW5ub3RhdGlvblN0b3JhZ2UiLCJzZXJpYWxpemFibGUiLCJoYXNoIiwicGFnZSIsImhhc093blByb3BlcnR5IiwicmVzZXRNb2RpZmllZCIsInRlcm1pbmF0ZWQiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsInNpbmsiLCJnZXRGdWxsUmVhZGVyIiwiZXZ0Iiwib25QdWxsIiwiY2xvc2UiLCJBcnJheUJ1ZmZlciIsImVucXVldWUiLCJvbkNhbmNlbCIsInJlYWR5IiwicmVhZHlSZWFzb24iLCJoZWFkZXJzQ2FwYWJpbGl0eSIsImZ1bGxSZWFkZXIiLCJoZWFkZXJzUmVhZHkiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJjb250ZW50TGVuZ3RoIiwicmFuZ2VSZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIl9udW1QYWdlcyIsImh0bWxGb3JYZmEiLCJleGNlcHRpb24iLCJ1cGRhdGVQYXNzd29yZCIsImV4cG9ydGVkRGF0YSIsImV4cG9ydGVkRXJyb3IiLCJpbnNwZWN0Rm9udCIsIkZvbnRJbnNwZWN0b3IiLCJlbmFibGVkIiwiZm9udCIsImZvbnRBZGRlZCIsIkZvbnRGYWNlT2JqZWN0IiwiYmluZCIsImZpbmFsbHkiLCJpbWFnZURhdGEiLCJwYWdlUHJveHkiLCJiaXRtYXAiLCJ3aWR0aCIsImhlaWdodCIsImZldGNoIiwiZmlsZW5hbWUiLCJudW0iLCJnZW4iLCJyZXN1bHRzIiwiT3B0aW9uYWxDb250ZW50Q29uZmlnIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsImNsZWFudXBTdWNjZXNzZnVsIiwiZW5zdXJlT2JqIiwib2JqSWQiLCJvbkNvbnRpbnVlIiwiZm9ybSIsImNhbnZhcyIsImNhbnZhc0luVXNlIiwiV2Vha1NldCIsIm9wZXJhdG9yTGlzdElkeCIsInJ1bm5pbmciLCJncmFwaGljc1JlYWR5Q2FsbGJhY2siLCJncmFwaGljc1JlYWR5IiwiX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbGxlZCIsIl9jYW5jZWxCb3VuZCIsIl9jb250aW51ZUJvdW5kIiwiX2NvbnRpbnVlIiwiX3NjaGVkdWxlTmV4dEJvdW5kIiwiX3NjaGVkdWxlTmV4dCIsIl9uZXh0Qm91bmQiLCJfbmV4dCIsIlN0ZXBwZXJNYW5hZ2VyIiwic3RlcHBlciIsImluaXQiLCJuZXh0QnJlYWtQb2ludCIsImdldE5leHRCcmVha1BvaW50IiwiZ2Z4IiwiQ2FudmFzR3JhcGhpY3MiLCJiZWdpbkRyYXdpbmciLCJlbmREcmF3aW5nIiwidXBkYXRlT3BlcmF0b3JMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZXhlY3V0ZU9wZXJhdG9yTGlzdCIsIl9lZGl0b3IiLCJfbXVybXVyaGFzaCIsImZyZWV6ZSIsIm1vZGlmaWVkIiwic3RvcmFnZSIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJnZXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsImdldFJhd1ZhbHVlIiwicmVtb3ZlIiwiQW5ub3RhdGlvbkVkaXRvciIsInNldFZhbHVlIiwiZW50cnkiLCJlbnRyaWVzIiwic2V0TW9kaWZpZWQiLCJfdHlwZSIsImdldEFsbCIsInNldEFsbCIsInByaW50IiwiTXVybXVySGFzaDNfNjQiLCJjb250ZXh0IiwiaGFzQml0bWFwIiwic2VyaWFsaXplZCIsInNlcmlhbGl6ZSIsInVwZGF0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZXhkaWdlc3QiLCJwYXJlbnQiLCJjbG9uZSIsIl90b29scyIsImFsdFRleHQiLCJhbHRUZXh0RGVjb3JhdGl2ZSIsImFsdFRleHRCdXR0b24iLCJhbHRUZXh0VG9vbHRpcCIsImFsdFRleHRUb29sdGlwVGltZW91dCIsImtlZXBBc3BlY3RSYXRpbyIsInJlc2l6ZXJzRGl2IiwiYm91bmRGb2N1c2luIiwiYm91bmRGb2N1c291dCIsImhhc0JlZW5DbGlja2VkIiwiaXNFZGl0aW5nIiwiaXNJbkVkaXRNb2RlIiwiaXNEcmFnZ2FibGUiLCJ6SW5kZXgiLCJfYm9yZGVyTGluZVdpZHRoIiwiX2NvbG9yTWFuYWdlciIsIkNvbG9yTWFuYWdlciIsIl96SW5kZXgiLCJTTUFMTF9FRElUT1JfU0laRSIsInBhcmFtZXRlcnMiLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJfaW5pdGlhbE9wdGlvbnMiLCJfdWlNYW5hZ2VyIiwiX2ZvY3VzRXZlbnRzQWxsb3dlZCIsIl9sMTBuUHJvbWlzZSIsImRpdiIsInVpTWFuYWdlciIsImFubm90YXRpb25FbGVtZW50SWQiLCJfd2lsbEtlZXBBc3BlY3RSYXRpbyIsImlzQ2VudGVyZWQiLCJfc3RydWN0VHJlZVBhcmVudElkIiwicmF3RGltcyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJwYWdlWCIsInBhZ2VZIiwicGFnZVJvdGF0aW9uIiwidmlld1BhcmFtZXRlcnMiLCJwYWdlRGltZW5zaW9ucyIsInBhZ2VUcmFuc2xhdGlvbiIsInBhcmVudERpbWVuc2lvbnMiLCJ4IiwieSIsImlzQXR0YWNoZWRUb0RPTSIsImRlbGV0ZWQiLCJlZGl0b3JUeXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJfZGVmYXVsdExpbmVDb2xvciIsImdldEhleENvZGUiLCJkZWxldGVBbm5vdGF0aW9uRWxlbWVudCIsImVkaXRvciIsImZha2VFZGl0b3IiLCJGYWtlRWRpdG9yIiwiZ2V0TmV4dElkIiwiYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSIsImluaXRpYWxpemUiLCJsMTBuIiwic3RyaW5ncyIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRvY3VtZW50RWxlbWVudCIsInBhcnNlRmxvYXQiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidXBkYXRlRGVmYXVsdFBhcmFtcyIsIl92YWx1ZSIsImRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUiLCJpc0hhbmRsaW5nTWltZUZvclBhc3RpbmciLCJtaW1lIiwicGFzdGUiLCJpdGVtIiwicHJvcGVydGllc1RvVXBkYXRlIiwiX2lzRHJhZ2dhYmxlIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiY2VudGVyIiwicGFyZW50Um90YXRpb24iLCJmaXhBbmRTZXRQb3NpdGlvbiIsImFkZENvbW1hbmRzIiwiY3VycmVudExheWVyIiwic2V0SW5CYWNrZ3JvdW5kIiwic2V0SW5Gb3JlZ3JvdW5kIiwic2V0UGFyZW50Iiwic2V0U2VsZWN0ZWQiLCJ0YXJnZXQiLCJyZWxhdGVkVGFyZ2V0IiwiY2xvc2VzdCIsInByZXZlbnREZWZhdWx0IiwiaXNNdWx0aXBsZVNlbGVjdGlvbiIsImNvbW1pdE9yUmVtb3ZlIiwiaXNFbXB0eSIsImNvbW1pdCIsInNldEF0IiwidHgiLCJ0eSIsInNjcmVlblRvUGFnZVRyYW5zbGF0aW9uIiwidHJhbnNsYXRlIiwidHJhbnNsYXRlSW5QYWdlIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsImRyYWciLCJwYXJlbnRXaWR0aCIsInBhcmVudEhlaWdodCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmROZXdQYXJlbnQiLCJieCIsImJ5IiwiZ2V0QmFzZVRyYW5zbGF0aW9uIiwibGVmdCIsInRvRml4ZWQiLCJ0b3AiLCJtb3ZlSW5ET00iLCJyb3RhdGVQb2ludCIsImFuZ2xlIiwicGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4iLCJnZXRSb3RhdGlvbk1hdHJpeCIsInBhcmVudFNjYWxlIiwicmVhbFNjYWxlIiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJyb3VuZCIsInNldERpbXMiLCJmaXhEaW1zIiwid2lkdGhQZXJjZW50IiwiZW5kc1dpdGgiLCJoZWlnaHRQZXJjZW50IiwiZ2V0SW5pdGlhbFRyYW5zbGF0aW9uIiwiY3JlYXRlUmVzaXplcnMiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NlcyIsImFwcGVuZCIsInJlc2l6ZXJQb2ludGVyZG93biIsIm5vQ29udGV4dE1lbnUiLCJwcmVwZW5kIiwiYnV0dG9uIiwiY3RybEtleSIsImJvdW5kUmVzaXplclBvaW50ZXJtb3ZlIiwicmVzaXplclBvaW50ZXJtb3ZlIiwic2F2ZWREcmFnZ2FibGUiLCJwb2ludGVyTW92ZU9wdGlvbnMiLCJwYXNzaXZlIiwiY2FwdHVyZSIsInNhdmVkWCIsInNhdmVkWSIsInNhdmVkV2lkdGgiLCJzYXZlZEhlaWdodCIsInNhdmVkUGFyZW50Q3Vyc29yIiwiY3Vyc29yIiwic2F2ZWRDdXJzb3IiLCJwb2ludGVyVXBDYWxsYmFjayIsIm5ld1giLCJuZXdZIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJjbWQiLCJ1bmRvIiwibXVzdEV4ZWMiLCJtaW5XaWR0aCIsIk1JTl9TSVpFIiwibWluSGVpZ2h0Iiwicm90YXRpb25NYXRyaXgiLCJ0cmFuc2YiLCJpbnZSb3RhdGlvbk1hdHJpeCIsImludlRyYW5zZiIsImdldFBvaW50IiwiZ2V0T3Bwb3NpdGUiLCJpc0RpYWdvbmFsIiwiaXNIb3Jpem9udGFsIiwidyIsImgiLCJwb2ludCIsIm9wcG9zaXRlUG9pbnQiLCJ0cmFuc2ZPcHBvc2l0ZVBvaW50Iiwib3Bwb3NpdGVYIiwib3Bwb3NpdGVZIiwicmF0aW9YIiwicmF0aW9ZIiwiZGVsdGFYIiwiZGVsdGFZIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwib2xkRGlhZyIsImh5cG90IiwiYWRkQWx0VGV4dEJ1dHRvbiIsImNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsInRhYkluZGV4Iiwic3RvcFByb3BhZ2F0aW9uIiwiZWRpdEFsdFRleHQiLCJzZXRBbHRUZXh0QnV0dG9uU3RhdGUiLCJQRVJDRU5UIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsIl9ldmVudEJ1cyIsImRpc3BhdGNoIiwic3VidHlwZSIsImFjdGlvbiIsImlubmVyVGV4dCIsInBhcmVudE5vZGUiLCJnZXRDbGllbnREaW1lbnNpb25zIiwiYWx0VGV4dERhdGEiLCJkZWNvcmF0aXZlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJiaW5kRXZlbnRzIiwicG9pbnRlcmRvd24iLCJzZXRVcERyYWdTZXNzaW9uIiwiaXNTZWxlY3RlZCIsInBvaW50ZXJNb3ZlQ2FsbGJhY2siLCJlIiwiZHJhZ1NlbGVjdGVkRWRpdG9ycyIsImVuZERyYWdTZXNzaW9uIiwic2hpZnRLZXkiLCJtZXRhS2V5IiwidG9nZ2xlU2VsZWN0ZWQiLCJtb3ZlRWRpdG9ySW5ET00iLCJfc2V0UGFyZW50QW5kUG9zaXRpb24iLCJjaGFuZ2VQYXJlbnQiLCJnZXRSZWN0Iiwic2hpZnRYIiwic2hpZnRZIiwiZ2V0UmVjdEluQ3VycmVudENvb3JkcyIsIm9uY2VBZGRlZCIsImVuYWJsZUVkaXRNb2RlIiwiZGlzYWJsZUVkaXRNb2RlIiwic2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMiLCJuZWVkc1RvQmVSZWJ1aWx0IiwicmVidWlsZCIsImlzRm9yQ29weWluZyIsImRlc2VyaWFsaXplIiwicmVtb3ZlRWRpdG9yIiwiaXNSZXNpemFibGUiLCJtYWtlUmVzaXphYmxlIiwic2VsZWN0IiwidW5zZWxlY3QiLCJjb250YWlucyIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1cyIsInVwZGF0ZVBhcmFtcyIsImRpc2FibGVFZGl0aW5nIiwiaGlkZGVuIiwiZW5hYmxlRWRpdGluZyIsImVudGVySW5FZGl0TW9kZSIsImNvbnRlbnREaXYiLCJzZXRBY3RpdmVFZGl0b3IiLCJzZXRBc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwiS2V5Ym9hcmRNYW5hZ2VyIiwiQ29tbWFuZE1hbmFnZXIiLCJBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwib3BhY2l0eVRvSGV4IiwiZWxlbWVudCIsIm5hbWVzIiwib3BhY2l0eSIsIklkTWFuYWdlciIsImdldElkIiwiSW1hZ2VNYW5hZ2VyIiwiYmFzZUlkIiwiY2FjaGUiLCJfaXNTVkdGaXR0aW5nQ2FudmFzIiwic3ZnIiwiY3R4IiwiZ2V0Q29udGV4dCIsImltYWdlIiwiSW1hZ2UiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJyYXdEYXRhIiwicmVmQ291bnRlciIsImlzU3ZnIiwicmVzcG9uc2UiLCJvayIsInN0YXR1c1RleHQiLCJibG9iIiwiZmlsZSIsIm11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsImltYWdlRWxlbWVudCIsImltYWdlUHJvbWlzZSIsIm9ubG9hZCIsInN2Z1VybCIsInJlc3VsdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJnZXRGcm9tRmlsZSIsImxhc3RNb2RpZmllZCIsImdldEZyb21VcmwiLCJnZXRGcm9tSWQiLCJnZXRTdmdVcmwiLCJkZWxldGVJZCIsImlzVmFsaWRJZCIsImNvbW1hbmRzIiwibG9ja2VkIiwibWF4U2l6ZSIsInBvc2l0aW9uIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwibmV4dCIsInNwbGljZSIsInJlZG8iLCJoYXNTb21ldGhpbmdUb1VuZG8iLCJoYXNTb21ldGhpbmdUb1JlZG8iLCJjYWxsYmFja3MiLCJhbGxLZXlzIiwiaXNNYWNLZXkiLCJzcGxpdCIsImF0IiwiYWx0S2V5IiwiZXhlYyIsInNlbGYiLCJidWJibGVzIiwiYXJncyIsImNoZWNrZXIiLCJfY29sb3JzTWFwcGluZyIsIl9jb2xvcnMiLCJjb2xvcnMiLCJnZXRDb2xvclZhbHVlcyIsImNvbnZlcnQiLCJjb2xvciIsInJnYiIsImdldFJHQiIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiUkdCIiwiZXZlcnkiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0b3JzIiwiYWxsTGF5ZXJzIiwiYWx0VGV4dE1hbmFnZXIiLCJjb21tYW5kTWFuYWdlciIsImN1cnJlbnRQYWdlSW5kZXgiLCJkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzIiwiZHJhZ2dpbmdFZGl0b3JzIiwiZWRpdG9yVHlwZXMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNXYWl0aW5nIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtb2RlIiwic2VsZWN0ZWRFZGl0b3JzIiwiYm91bmRCbHVyIiwiYm91bmRGb2N1cyIsImJvdW5kQ29weSIsImJvdW5kQ3V0IiwiYm91bmRQYXN0ZSIsImJvdW5kS2V5ZG93biIsImJvdW5kT25FZGl0aW5nQWN0aW9uIiwiYm91bmRPblBhZ2VDaGFuZ2luZyIsImJvdW5kT25TY2FsZUNoYW5naW5nIiwiYm91bmRPblJvdGF0aW9uQ2hhbmdpbmciLCJwcmV2aW91c1N0YXRlcyIsInRyYW5zbGF0aW9uIiwidHJhbnNsYXRpb25UaW1lb3V0SWQiLCJjb250YWluZXIiLCJ2aWV3ZXIiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsInByb3RvIiwiYXJyb3dDaGVja2VyIiwiaGFzU29tZXRoaW5nVG9Db250cm9sIiwic21hbGwiLCJiaWciLCJzZWxlY3RBbGwiLCJ1bnNlbGVjdEFsbCIsInRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyIsImV2ZW50QnVzIiwicGRmRG9jdW1lbnQiLCJibHVyIiwiY29weSIsImN1dCIsImtleWRvd24iLCJvbkVkaXRpbmdBY3Rpb24iLCJvblBhZ2VDaGFuZ2luZyIsIm9uU2NhbGVDaGFuZ2luZyIsIm9uUm90YXRpb25DaGFuZ2luZyIsImhhc1NlbGVjdGVkRWRpdG9yIiwiX29uIiwiUGl4ZWxzUGVySW5jaCIsIlBERl9UT19DU1NfVU5JVFMiLCJyZW1vdmVLZXlib2FyZE1hbmFnZXIiLCJyZW1vdmVGb2N1c01hbmFnZXIiLCJfb2ZmIiwibGF5ZXIiLCJoY21GaWx0ZXIiLCJhZGRIQ01GaWx0ZXIiLCJmb3JlZ3JvdW5kIiwiZGlyZWN0aW9uIiwiZm9jdXNNYWluQ29udGFpbmVyIiwiZmluZFBhcmVudCIsImxheWVyWCIsImxheWVyWSIsImRpc2FibGVVc2VyU2VsZWN0IiwiYWRkU2hvdWxkUmVzY2FsZSIsInJlbW92ZVNob3VsZFJlc2NhbGUiLCJwYWdlc1JvdGF0aW9uIiwiYWRkRm9jdXNNYW5hZ2VyIiwiaGFzU2VsZWN0aW9uIiwibGFzdEVkaXRvciIsIm9uY2UiLCJhZGRLZXlib2FyZE1hbmFnZXIiLCJhZGRDb3B5UGFzdGVMaXN0ZW5lcnMiLCJyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMiLCJhZGRFZGl0TGlzdGVuZXJzIiwicmVtb3ZlRWRpdExpc3RlbmVycyIsImVkaXRvcnMiLCJjbGlwYm9hcmREYXRhIiwic2V0RGF0YSIsInBhcnNlIiwiaXNBcnJheSIsIm5ld0VkaXRvcnMiLCJkZXNlcmlhbGl6ZWRFZGl0b3IiLCJhZGRFZGl0b3JUb0xheWVyIiwic2VsZWN0RWRpdG9ycyIsImdldEFjdGl2ZSIsImRpc3BhdGNoVXBkYXRlU3RhdGVzIiwiaGFzQ2hhbmdlZCIsInNvbWUiLCJkaXNwYXRjaFVwZGF0ZVVJIiwic2V0RWRpdGluZ1N0YXRlIiwicmVnaXN0ZXJFZGl0b3JUeXBlcyIsInR5cGVzIiwiZ2V0TGF5ZXIiLCJhZGRMYXllciIsImVuYWJsZSIsImRpc2FibGUiLCJyZW1vdmVMYXllciIsInVwZGF0ZU1vZGUiLCJlZGl0SWQiLCJkaXNhYmxlQWxsIiwiZW5hYmxlQWxsIiwidXBkYXRlVG9vbGJhciIsImFkZE5ld0VkaXRvciIsImVuYWJsZVdhaXRpbmciLCJtdXN0V2FpdCIsImRpc2FibGVDbGljayIsImVuYWJsZUNsaWNrIiwiZ2V0RWRpdG9ycyIsImdldEVkaXRvciIsImFkZEVkaXRvciIsImFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsImlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkT3JSZWJ1aWxkIiwiZWQiLCJub0NvbW1pdCIsInRvdGFsWCIsInRvdGFsWSIsIlRJTUVfVE9fV0FJVCIsInNhdmVkUGFnZUluZGV4IiwibmV3UGFnZUluZGV4IiwibXVzdEJlQWRkZWRJblVuZG9TdGFjayIsIm1vdmUiLCJpc0FjdGl2ZSIsImdldE1vZGUiLCJpbWFnZU1hbmFnZXIiLCJQREZEYXRlU3RyaW5nIiwiRE9NU1ZHRmFjdG9yeSIsImdldEN1cnJlbnRUcmFuc2Zvcm0iLCJnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSIsImdldEZpbGVuYW1lRnJvbVVybCIsImdldFBkZkZpbGVuYW1lRnJvbVVybCIsImdldFhmYVBhZ2VWaWV3cG9ydCIsImlzUGRmRmlsZSIsInNldExheWVyRGltZW5zaW9ucyIsIl9iYXNlX2ZhY3RvcnkiLCJTVkdfTlMiLCJQREYiLCJCYXNlRmlsdGVyRmFjdG9yeSIsIl9jYWNoZSIsIl9kZWZzIiwiaGNtS2V5IiwiaGNtVXJsIiwiaGNtSGlnaGxpZ2h0RmlsdGVyIiwiaGNtSGlnaGxpZ2h0S2V5IiwiaGNtSGlnaGxpZ2h0VXJsIiwiZGVmcyIsInZpc2liaWxpdHkiLCJjb250YWluIiwiY3JlYXRlRWxlbWVudE5TIiwiYm9keSIsImFkZEZpbHRlciIsIm1hcHMiLCJ0YWJsZVIiLCJ0YWJsZUciLCJ0YWJsZUIiLCJtYXBSIiwibWFwRyIsIm1hcEIiLCJidWZmZXJSIiwiYnVmZmVyRyIsImJ1ZmZlckIiLCJmaWx0ZXIiLCJjcmVhdGVGaWx0ZXIiLCJhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24iLCJmZ0NvbG9yIiwiYmdDb2xvciIsImZnUkdCIiwiYmdSR0IiLCJ0YWJsZSIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJzdGFydCIsImFyciIsImFkZEhpZ2hsaWdodEhDTUZpbHRlciIsIm5ld0ZnQ29sb3IiLCJuZXdCZ0NvbG9yIiwiZmdHcmF5IiwiYmdHcmF5IiwibmV3RmdSR0IiLCJuZXdCZ1JHQiIsImZnIiwiYmciLCJzdGVwIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsImsiLCJrZWVwSENNIiwiZmVDb2xvck1hdHJpeCIsImFwcGVuZEZlRnVuYyIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmdW5jIiwiZmVGdW5jIiwiclRhYmxlIiwiZ1RhYmxlIiwiYlRhYmxlIiwiQmFzZUNhbnZhc0ZhY3RvcnkiLCJfZG9jdW1lbnQiLCJfY3JlYXRlQ2FudmFzIiwiZmV0Y2hEYXRhIiwiYXNUeXBlZEFycmF5IiwiYXJyYXlCdWZmZXIiLCJ0ZXh0IiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwicmVzcG9uc2VUZXh0IiwiQmFzZUNNYXBSZWFkZXJGYWN0b3J5IiwiX2ZldGNoRGF0YSIsImNvbXByZXNzaW9uVHlwZSIsImNNYXBEYXRhIiwiQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiQmFzZVNWR0ZhY3RvcnkiLCJfY3JlYXRlU1ZHIiwiY2VudGVyWCIsImNlbnRlclkiLCJyb3RhdGVBIiwicm90YXRlQiIsInJvdGF0ZUMiLCJyb3RhdGVEIiwib2Zmc2V0Q2FudmFzWCIsIm9mZnNldENhbnZhc1kiLCJjb252ZXJ0VG9WaWV3cG9ydFBvaW50IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJjb252ZXJ0VG9QZGZQb2ludCIsInRyaW0iLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJvbmx5U3RyaXBQYXRoIiwibGFzdEluZGV4T2YiLCJkZWZhdWx0RmlsZW5hbWUiLCJyZVVSSSIsInJlRmlsZW5hbWUiLCJzcGxpdFVSSSIsInN1Z2dlc3RlZEZpbGVuYW1lIiwic3RhcnRlZCIsIm5vdyIsInRpbWVzIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsInJlbW92ZVNjcmlwdEVsZW1lbnQiLCJzY3JpcHQiLCJoZWFkIiwicGRmRGF0ZVN0cmluZ1JlZ2V4IiwidG9EYXRlT2JqZWN0IiwiaW5wdXQiLCJSZWdFeHAiLCJ5ZWFyIiwicGFyc2VJbnQiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJ1bml2ZXJzYWxUaW1lUmVsYXRpb24iLCJvZmZzZXRIb3VyIiwib2Zmc2V0TWludXRlIiwiVVRDIiwieGZhUGFnZSIsImF0dHJpYnV0ZXMiLCJjb2xvclJHQiIsInNwYW4iLCJjb21wdXRlZENvbG9yIiwiZiIsImdldFRyYW5zZm9ybSIsImludmVydFNlbGYiLCJtdXN0RmxpcCIsIm11c3RSb3RhdGUiLCJ1c2VSb3VuZCIsIndpZHRoU3RyIiwiaGVpZ2h0U3RyIiwicmVzZXQiLCJjYW52YXNBbmRDb250ZXh0Iiwic2tpcERpbWVuc2lvbnMiLCJTRUVEIiwiTUFTS19ISUdIIiwiTUFTS19MT1ciLCJzZWVkIiwiaDEiLCJoMiIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsInN5c3RlbUZvbnRzIiwibmF0aXZlRm9udEZhY2VzIiwibG9hZGluZ1JlcXVlc3RzIiwibG9hZFRlc3RGb250SWQiLCJhZGROYXRpdmVGb250RmFjZSIsIm5hdGl2ZUZvbnRGYWNlIiwiZm9udHMiLCJyZW1vdmVOYXRpdmVGb250RmFjZSIsImluc2VydFJ1bGUiLCJydWxlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0Iiwic2hlZXQiLCJjc3NSdWxlcyIsImxvYWRTeXN0ZW1Gb250IiwibG9hZGVkTmFtZSIsImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQiLCJmb250RmFjZSIsIkZvbnRGYWNlIiwibG9hZCIsImJhc2VGb250TmFtZSIsImF0dGFjaGVkIiwibWlzc2luZ0ZpbGUiLCJzeXN0ZW1Gb250SW5mbyIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsInN1cHBvcnRlZCIsInVzZXJBZ2VudCIsImNvbXBsZXRlUmVxdWVzdCIsIm90aGVyUmVxdWVzdCIsInNoaWZ0IiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiYXRvYiIsImludDMyIiwib2Zmc2V0Iiwic3BsaWNlU3RyaW5nIiwicyIsImluc2VydCIsImNodW5rMSIsImNodW5rMiIsImNhbGxlZCIsImlzRm9udFJlYWR5IiwiZmlsbFRleHQiLCJDT01NRU5UX09GRlNFVCIsIkNGRl9DSEVDS1NVTV9PRkZTRVQiLCJYWFhYX1ZBTFVFIiwiY2hlY2tzdW0iLCJidG9hIiwiZm9udEZhbWlseSIsInRyYW5zbGF0ZWREYXRhIiwiY29tcGlsZWRHbHlwaHMiLCJfaW5zcGVjdEZvbnQiLCJjc3NGb250SW5mbyIsImNzcyIsIndlaWdodCIsImZvbnRXZWlnaHQiLCJpdGFsaWNBbmdsZSIsIm1pbWV0eXBlIiwiZ2V0UGF0aEdlbmVyYXRvciIsImNoYXJhY3RlciIsImNtZHMiLCJqc0J1ZiIsImN1cnJlbnQiLCJmcyIsInJlYWRGaWxlIiwiQ2FudmFzIiwiY3JlYXRlQ2FudmFzIiwiX3BhdHRlcm5faGVscGVyIiwiX2ltYWdlX3V0aWxzIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJNQVhfR1JPVVBfU0laRSIsIkVYRUNVVElPTl9USU1FIiwiRVhFQ1VUSU9OX1NURVBTIiwiTUFYX1NJWkVfVE9fQ09NUElMRSIsIkZVTExfQ0hVTktfSEVJR0hUIiwibWlycm9yQ29udGV4dE9wZXJhdGlvbnMiLCJkZXN0Q3R4IiwiX3JlbW92ZU1pcnJvcmluZyIsIl9fb3JpZ2luYWxTYXZlIiwiX19vcmlnaW5hbFJlc3RvcmUiLCJfX29yaWdpbmFsUm90YXRlIiwiX19vcmlnaW5hbFNjYWxlIiwiX19vcmlnaW5hbFRyYW5zbGF0ZSIsIl9fb3JpZ2luYWxUcmFuc2Zvcm0iLCJfX29yaWdpbmFsU2V0VHJhbnNmb3JtIiwic2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtIiwicmVzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsQ2xpcCIsIl9fb3JpZ2luYWxNb3ZlVG8iLCJfX29yaWdpbmFsTGluZVRvIiwiX19vcmlnaW5hbEJlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImJlZ2luUGF0aCIsImN0eFNhdmUiLCJjdHhSZXN0b3JlIiwiY3R4VHJhbnNsYXRlIiwiY3R4U2NhbGUiLCJjdHhUcmFuc2Zvcm0iLCJjdHhTZXRUcmFuc2Zvcm0iLCJjdHhSZXNldFRyYW5zZm9ybSIsImN0eFJvdGF0ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImdldENhbnZhcyIsImNhbnZhc0VudHJ5IiwiZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzIiwic3JjSW1nIiwic3JjWCIsInNyY1kiLCJzcmNXIiwic3JjSCIsImRlc3RYIiwiZGVzdFkiLCJkZXN0VyIsImRlc3RIIiwidGxYIiwiclRsWCIsInRsWSIsInJUbFkiLCJiclgiLCJyV2lkdGgiLCJiclkiLCJySGVpZ2h0Iiwic2lnbiIsInNjYWxlWCIsInNjYWxlWSIsImNvbXBpbGVUeXBlM0dseXBoIiwiaW1nRGF0YSIsIlBPSU5UX1RPX1BST0NFU1NfTElNSVQiLCJQT0lOVF9UWVBFUyIsIndpZHRoMSIsInBvaW50cyIsImowIiwibGluZVNpemUiLCJwb3MiLCJlbGVtIiwibWFzayIsImNvdW50Iiwic3VtIiwic3RlcHMiLCJJbnQzMkFycmF5IiwicGF0aCIsIlBhdGgyRCIsInAwIiwicHAiLCJkcmF3T3V0bGluZSIsIkNhbnZhc0V4dHJhU3RhdGUiLCJhbHBoYUlzU2hhcGUiLCJmb250U2l6ZSIsImZvbnRTaXplU2NhbGUiLCJ0ZXh0TWF0cml4IiwidGV4dE1hdHJpeFNjYWxlIiwiZm9udE1hdHJpeCIsImxlYWRpbmciLCJsaW5lWCIsImxpbmVZIiwiY2hhclNwYWNpbmciLCJ3b3JkU3BhY2luZyIsInRleHRIU2NhbGUiLCJ0ZXh0UmVuZGVyaW5nTW9kZSIsInRleHRSaXNlIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJwYXR0ZXJuRmlsbCIsImZpbGxBbHBoYSIsInN0cm9rZUFscGhhIiwibGluZVdpZHRoIiwiYWN0aXZlU01hc2siLCJ0cmFuc2Zlck1hcHMiLCJzdGFydE5ld1BhdGhBbmRDbGlwQm94IiwiY2xpcEJveCIsInNldEN1cnJlbnRQb2ludCIsInVwZGF0ZVBhdGhNaW5NYXgiLCJtaW5YIiwibWluWSIsIm1heFgiLCJtYXhZIiwidXBkYXRlUmVjdE1pbk1heCIsInVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4IiwidXBkYXRlQ3VydmVQYXRoTWluTWF4IiwiYm94IiwiZ2V0UGF0aEJvdW5kaW5nQm94IiwicGF0aFR5cGUiLCJQYXRoVHlwZSIsInhTdHJva2VQYWQiLCJ5U3Ryb2tlUGFkIiwidXBkYXRlQ2xpcEZyb21QYXRoIiwiaXNFbXB0eUNsaXAiLCJJbmZpbml0eSIsImdldENsaXBwZWRQYXRoQm91bmRpbmdCb3giLCJwdXRCaW5hcnlJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJwdXRJbWFnZURhdGEiLCJwYXJ0aWFsQ2h1bmtIZWlnaHQiLCJmdWxsQ2h1bmtzIiwidG90YWxDaHVua3MiLCJjaHVua0ltZ0RhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJzcmNQb3MiLCJkZXN0UG9zIiwiZGVzdCIsInRoaXNDaHVua0hlaWdodCIsImVsZW1zSW5UaGlzQ2h1bmsiLCJraW5kIiwic3JjTGVuZ3RoIiwiZGVzdDMyIiwiZGVzdDMyRGF0YUxlbmd0aCIsImZ1bGxTcmNEaWZmIiwid2hpdGUiLCJibGFjayIsInNyY0RpZmYiLCJrRW5kIiwia0VuZFVucm9sbGVkIiwic3JjQnl0ZSIsInB1dEJpbmFyeUltYWdlTWFzayIsImNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBIiwibm9uQmxhY2tDb2xvciIsImNvcHlDdHhTdGF0ZSIsInNvdXJjZUN0eCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eSIsInNldExpbmVEYXNoIiwiZ2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInJlc2V0Q3R4VG9EZWZhdWx0Iiwic3Ryb2tlU3R5bGUiLCJmaWxsU3R5bGUiLCJmaWxsUnVsZSIsImdsb2JhbEFscGhhIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImNvbXBvc2VTTWFza0JhY2tkcm9wIiwicjAiLCJnMCIsImIwIiwiYWxwaGEiLCJhbHBoYV8iLCJjb21wb3NlU01hc2tBbHBoYSIsIm1hc2tEYXRhIiwibGF5ZXJEYXRhIiwidHJhbnNmZXJNYXAiLCJjb21wb3NlU01hc2tMdW1pbm9zaXR5IiwiZ2VuZXJpY0NvbXBvc2VTTWFzayIsIm1hc2tDdHgiLCJsYXllckN0eCIsImJhY2tkcm9wIiwibGF5ZXJPZmZzZXRYIiwibGF5ZXJPZmZzZXRZIiwibWFza09mZnNldFgiLCJtYXNrT2Zmc2V0WSIsImhhc0JhY2tkcm9wIiwiY29tcG9zZUZuIiwiUElYRUxTX1RPX1BST0NFU1MiLCJjaHVua1NpemUiLCJjZWlsIiwicm93IiwiY2h1bmtIZWlnaHQiLCJjb21wb3NlU01hc2siLCJzbWFzayIsImxheWVyQm94IiwibGF5ZXJXaWR0aCIsImxheWVySGVpZ2h0IiwiZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW50ZXJwb2xhdGUiLCJmcm91bmQiLCJhY3R1YWxTY2FsZSIsImRldmljZVBpeGVsUmF0aW8iLCJMSU5FX0NBUF9TVFlMRVMiLCJMSU5FX0pPSU5fU1RZTEVTIiwiTk9STUFMX0NMSVAiLCJFT19DTElQIiwiY2FudmFzQ3R4IiwibWFya2VkQ29udGVudFN0YWNrIiwic3RhdGVTdGFjayIsInBlbmRpbmdDbGlwIiwicGVuZGluZ0VPRmlsbCIsInJlcyIsInhvYmpzIiwiZ3JvdXBTdGFjayIsInByb2Nlc3NpbmdUeXBlMyIsImJhc2VUcmFuc2Zvcm0iLCJiYXNlVHJhbnNmb3JtU3RhY2siLCJncm91cExldmVsIiwic21hc2tTdGFjayIsInNtYXNrQ291bnRlciIsInRlbXBTTWFzayIsInN1c3BlbmRlZEN0eCIsImNvbnRlbnRWaXNpYmxlIiwiY2FjaGVkQ2FudmFzZXMiLCJjYWNoZWRQYXR0ZXJucyIsInZpZXdwb3J0U2NhbGUiLCJvdXRwdXRTY2FsZVgiLCJvdXRwdXRTY2FsZVkiLCJfY2FjaGVkU2NhbGVGb3JTdHJva2luZyIsIl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoIiwiX2NhY2hlZEJpdG1hcHNNYXAiLCJnZXRPYmplY3QiLCJmYWxsYmFjayIsInNhdmVkRmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0cmFuc3BhcmVudENhbnZhcyIsImNvbXBvc2l0ZUN0eCIsImV4ZWN1dGlvblN0YXJ0SWR4IiwiY29udGludWVDYWxsYmFjayIsImFyZ3NBcnJheUxlbiIsImNodW5rT3BlcmF0aW9ucyIsImVuZFRpbWUiLCJmbklkIiwiYnJlYWtJdCIsImRlcE9iaklkIiwib2Jqc1Bvb2wiLCJyZXN0b3JlSW5pdGlhbFN0YXRlIiwiaW5TTWFza01vZGUiLCJIVE1MQ2FudmFzRWxlbWVudCIsImRyYXdGaWx0ZXIiLCJoY21GaWx0ZXJJZCIsInNhdmVkRmlsdGVyIiwiX3NjYWxlSW1hZ2UiLCJpbWciLCJ3aWR0aFNjYWxlIiwiaGVpZ2h0U2NhbGUiLCJwYWludFdpZHRoIiwicGFpbnRIZWlnaHQiLCJ0bXBDYW52YXNJZCIsInRtcENhbnZhcyIsInRtcEN0eCIsImNsZWFyUmVjdCIsIl9jcmVhdGVNYXNrQ2FudmFzIiwiaXNQYXR0ZXJuRmlsbCIsImN1cnJlbnRUcmFuc2Zvcm0iLCJzY2FsZWQiLCJtYXNrQ2FudmFzIiwibWFpbktleSIsImNhY2hlZEltYWdlIiwibWFza1RvQ2FudmFzIiwiY29yZDEiLCJjb3JkMiIsImRyYXduV2lkdGgiLCJkcmF3bkhlaWdodCIsImZpbGxDYW52YXMiLCJmaWxsQ3R4IiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW52ZXJzZSIsImdldFBhdHRlcm4iLCJsaW1pdCIsImRhc2hBcnJheSIsImRhc2hQaGFzZSIsImZsYXRuZXNzIiwic3RhdGVzIiwiY2hlY2tTTWFza1N0YXRlIiwiYmVnaW5TTWFza01vZGUiLCJlbmRTTWFza01vZGUiLCJjYWNoZUlkIiwic2NyYXRjaENhbnZhcyIsImNvbXBvc2UiLCJkaXJ0eUJveCIsIm9sZCIsInBvcCIsIm9wcyIsInN0YXJ0WCIsInN0YXJ0WSIsImlzU2NhbGluZ01hdHJpeCIsIm1pbk1heEZvckJlemllciIsInh3IiwieWgiLCJjb25zdW1lUGF0aCIsInJlc2NhbGVBbmRTdHJva2UiLCJuZWVkUmVzdG9yZSIsInBhdGhzIiwicGVuZGluZ1RleHRQYXRocyIsImFkZFRvUGF0aCIsInNwYWNpbmciLCJmb250UmVmTmFtZSIsImZvbnRPYmoiLCJmb250RGlyZWN0aW9uIiwiaXNUeXBlM0ZvbnQiLCJ0eXBlZmFjZSIsImZhbGxiYWNrTmFtZSIsImJvbGQiLCJpdGFsaWMiLCJicm93c2VyRm9udFNpemUiLCJyaXNlIiwicGFpbnRDaGFyIiwicGF0dGVyblRyYW5zZm9ybSIsImZpbGxTdHJva2VNb2RlIiwiaXNBZGRUb1BhdGhTZXQiLCJzdHJva2VUZXh0IiwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWQiLCJnbHlwaHMiLCJzaG93VHlwZTNUZXh0IiwiZ2x5cGhzTGVuZ3RoIiwidmVydGljYWwiLCJzcGFjaW5nRGlyIiwiZGVmYXVsdFZNZXRyaWNzIiwid2lkdGhBZHZhbmNlU2NhbGUiLCJzaW1wbGVGaWxsVGV4dCIsInBhdHRlcm4iLCJnZXRTaW5nbGVQaXhlbFdpZHRoIiwiaXNJbnZhbGlkUERGanNGb250IiwiY2hhcnMiLCJnbHlwaCIsInVuaWNvZGUiLCJyZXN0b3JlTmVlZGVkIiwiaXNTcGFjZSIsImZvbnRDaGFyIiwiYWNjZW50Iiwic2NhbGVkWCIsInNjYWxlZFkiLCJ2bWV0cmljIiwidngiLCJ2eSIsInJlbWVhc3VyZSIsIm1lYXN1cmVkV2lkdGgiLCJtZWFzdXJlVGV4dCIsImNoYXJhY3RlclNjYWxlWCIsImlzSW5Gb250Iiwic2NhbGVkQWNjZW50WCIsInNjYWxlZEFjY2VudFkiLCJjaGFyV2lkdGgiLCJpc1RleHRJbnZpc2libGUiLCJzcGFjaW5nTGVuZ3RoIiwiY2hhclByb2NPcGVyYXRvckxpc3QiLCJvcGVyYXRvckxpc3RJZCIsInRyYW5zZm9ybWVkIiwieFdpZHRoIiwieVdpZHRoIiwibGx4IiwibGx5IiwidXJ4IiwidXJ5IiwiZ2V0Q29sb3JOX1BhdHRlcm4iLCJJUiIsImNhbnZhc0dyYXBoaWNzRmFjdG9yeSIsImNyZWF0ZUNhbnZhc0dyYXBoaWNzIiwiVGlsaW5nUGF0dGVybiIsIl9nZXRQYXR0ZXJuIiwiYXJndW1lbnRzIiwibWF0cml4IiwiZ2V0U2hhZGluZ1BhdHRlcm4iLCJTSEFESU5HIiwiaW52IiwiYmJveCIsImdyb3VwIiwiY3VycmVudEN0eCIsImlzb2xhdGVkIiwia25vY2tvdXQiLCJjYW52YXNCb3VuZHMiLCJncm91cEN0eCIsInN0YXJ0VHJhbnNmb3JtSW52ZXJzZSIsImN1cnJlbnRNdHgiLCJoYXNPd25DYW52YXMiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImFubm90YXRpb25DYW52YXMiLCJzYXZlZEN0eCIsImNvbXBpbGVkIiwic2tld1giLCJza2V3WSIsInBvc2l0aW9ucyIsInRyYW5zIiwiaW1hZ2VzIiwiYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAiLCJpbWdUb1BhaW50IiwiSFRNTEVsZW1lbnQiLCJ0YWciLCJ2aXNpYmxlIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwib3AiLCJhcHBseUJvdW5kaW5nQm94IiwicmVnaW9uIiwiQmFzZVNoYWRpbmdQYXR0ZXJuIiwiUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiIsIl9iYm94IiwiX2NvbG9yU3RvcHMiLCJfcDAiLCJfcDEiLCJfcjAiLCJfcjEiLCJfY3JlYXRlR3JhZGllbnQiLCJncmFkIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImNvbG9yU3RvcCIsImFkZENvbG9yU3RvcCIsIm93bmVyIiwib3duZXJCQm94IiwiY3JlYXRlUGF0dGVybiIsImRvbU1hdHJpeCIsIkRPTU1hdHJpeCIsImRyYXdUcmlhbmdsZSIsImMxIiwiYzIiLCJjMyIsImNvb3JkcyIsInJvd1NpemUiLCJ0bXAiLCJjMXIiLCJjMWciLCJjMWIiLCJjMnIiLCJjMmciLCJjMmIiLCJjM3IiLCJjM2ciLCJjM2IiLCJ4YSIsImNhciIsImNhZyIsImNhYiIsInhiIiwiY2JyIiwiY2JnIiwiY2JiIiwieDFfIiwieDJfIiwiZHJhd0ZpZ3VyZSIsImZpZ3VyZSIsInBzIiwiY3MiLCJ2ZXJ0aWNlc1BlclJvdyIsInJvd3MiLCJjb2xzIiwicSIsIk1lc2hTaGFkaW5nUGF0dGVybiIsIl9jb29yZHMiLCJfZmlndXJlcyIsIl9ib3VuZHMiLCJfYmFja2dyb3VuZCIsIl9jcmVhdGVNZXNoQ2FudmFzIiwiY29tYmluZWRTY2FsZSIsImJhY2tncm91bmRDb2xvciIsIkVYUEVDVEVEX1NDQUxFIiwiTUFYX1BBVFRFUk5fU0laRSIsIkJPUkRFUl9TSVpFIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJwYWRkZWRXaWR0aCIsInBhZGRlZEhlaWdodCIsIm1hdHJpeFNjYWxlIiwidGVtcG9yYXJ5UGF0dGVybkNhbnZhcyIsIkR1bW15U2hhZGluZ1BhdHRlcm4iLCJQYWludFR5cGUiLCJDT0xPUkVEIiwiVU5DT0xPUkVEIiwieHN0ZXAiLCJ5c3RlcCIsInBhaW50VHlwZSIsInRpbGluZ1R5cGUiLCJjcmVhdGVQYXR0ZXJuQ2FudmFzIiwiY3VyTWF0cml4U2NhbGUiLCJkaW14IiwiZ2V0U2l6ZUFuZFNjYWxlIiwiZGlteSIsImdyYXBoaWNzIiwic2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0IiwiYWRqdXN0ZWRYMCIsImFkanVzdGVkWTAiLCJhZGp1c3RlZFgxIiwiYWRqdXN0ZWRZMSIsImNsaXBCYm94IiwicmVhbE91dHB1dFNpemUiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0IiwiY3NzQ29sb3IiLCJjb252ZXJ0VG9SR0JBIiwiZ3JheVRvUkdCQSIsImNvbnZlcnRSR0JUb1JHQkEiLCJpbnZlcnNlRGVjb2RlIiwiemVyb01hcHBpbmciLCJvbmVNYXBwaW5nIiwid2lkdGhJblNvdXJjZSIsIndpZHRoUmVtYWluZGVyIiwibGVuMzIiLCJzcmMzMiIsInMxIiwiczIiLCJzMyIsImpqIiwiQ2FsbGJhY2tLaW5kIiwiVU5LTk9XTiIsIkRBVEEiLCJFUlJPUiIsIlN0cmVhbUtpbmQiLCJDQU5DRUwiLCJDQU5DRUxfQ09NUExFVEUiLCJDTE9TRSIsIkVOUVVFVUUiLCJQVUxMIiwiUFVMTF9DT01QTEVURSIsIlNUQVJUX0NPTVBMRVRFIiwid3JhcFJlYXNvbiIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29tT2JqIiwiY2FsbGJhY2tJZCIsInN0cmVhbUlkIiwic3RyZWFtU2lua3MiLCJzdHJlYW1Db250cm9sbGVycyIsImNhbGxiYWNrQ2FwYWJpbGl0aWVzIiwiYWN0aW9uSGFuZGxlciIsIl9vbkNvbU9iak9uTWVzc2FnZSIsInN0cmVhbSIsInByb2Nlc3NTdHJlYW1NZXNzYWdlIiwiY2JTb3VyY2VOYW1lIiwiY2JUYXJnZXROYW1lIiwiY3JlYXRlU3RyZWFtU2luayIsImFjdGlvbk5hbWUiLCJoYW5kbGVyIiwiYWgiLCJxdWV1ZWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVTdHJlYW0iLCJjb250cm9sbGVyIiwic3RhcnRDYXBhYmlsaXR5Iiwic3RhcnRDYWxsIiwicHVsbENhbGwiLCJjYW5jZWxDYWxsIiwiaXNDbG9zZWQiLCJkZXNpcmVkU2l6ZSIsInB1bGwiLCJwdWxsQ2FwYWJpbGl0eSIsImNhbmNlbENhcGFiaWxpdHkiLCJzdHJlYW1TaW5rIiwiaXNDYW5jZWxsZWQiLCJsYXN0RGVzaXJlZFNpemUiLCJzaW5rQ2FwYWJpbGl0eSIsInN0cmVhbUNvbnRyb2xsZXIiLCJkZWxldGVTdHJlYW1Db250cm9sbGVyIiwiYWxsU2V0dGxlZCIsIm1ldGFkYXRhTWFwIiwicGFyc2VkRGF0YSIsImdldFJhdyIsIklOVEVSTkFMIiwiU3ltYm9sIiwiT3B0aW9uYWxDb250ZW50R3JvdXAiLCJfc2V0VmlzaWJsZSIsImludGVybmFsIiwiY2FjaGVkR2V0SGFzaCIsImdyb3VwcyIsImluaXRpYWxIYXNoIiwib3JkZXIiLCJjcmVhdG9yIiwiYmFzZVN0YXRlIiwib2ZmIiwiZ2V0SGFzaCIsImV2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24iLCJhcnJheSIsIm9wZXJhdG9yIiwic3RhdGUiLCJleHByZXNzaW9uIiwicG9saWN5IiwiaWRzIiwic2V0VmlzaWJpbGl0eSIsImhhc0luaXRpYWxWaXNpYmlsaXR5IiwiZ2V0T3JkZXIiLCJnZXRHcm91cHMiLCJnZXRHcm91cCIsInBkZkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9xdWV1ZWRDaHVua3MiLCJfcHJvZ3Jlc3NpdmVEb25lIiwiX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9pc1N0cmVhbWluZ1N1cHBvcnRlZCIsIl9pc1JhbmdlU3VwcG9ydGVkIiwiX2NvbnRlbnRMZW5ndGgiLCJfZnVsbFJlcXVlc3RSZWFkZXIiLCJfcmFuZ2VSZWFkZXJzIiwiX29uUmVjZWl2ZURhdGEiLCJfb25Qcm9ncmVzcyIsIl9vblByb2dyZXNzaXZlRG9uZSIsIl9lbnF1ZXVlIiwiZm91bmQiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIl9yZW1vdmVSYW5nZVJlYWRlciIsImluZGV4T2YiLCJxdWV1ZWRDaHVua3MiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIiwiX3N0cmVhbSIsIl9kb25lIiwiX2ZpbGVuYW1lIiwiX3JlcXVlc3RzIiwiX2hlYWRlcnNSZWFkeSIsInJlcXVlc3RDYXBhYmlsaXR5IiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsIl9uZXR3b3JrX3V0aWxzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwiaGVhZGVycyIsImFib3J0Q29udHJvbGxlciIsIm1ldGhvZCIsInNpZ25hbCIsImNyZWRlbnRpYWxzIiwicmVkaXJlY3QiLCJjcmVhdGVIZWFkZXJzIiwiSGVhZGVycyIsImdldEFycmF5QnVmZmVyIiwiaXNIdHRwIiwiX3JhbmdlUmVxdWVzdFJlYWRlcnMiLCJQREZGZXRjaFN0cmVhbVJlYWRlciIsIlBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIiLCJfcmVhZGVyIiwiX3dpdGhDcmVkZW50aWFscyIsIl9oZWFkZXJzQ2FwYWJpbGl0eSIsIl9kaXNhYmxlUmFuZ2UiLCJfcmFuZ2VDaHVua1NpemUiLCJfYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiX2hlYWRlcnMiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciIsImdldFJlc3BvbnNlSGVhZGVyIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwidmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMiLCJleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyIiwiX3JlYWRDYXBhYmlsaXR5IiwiX2NvbnRlbnRfZGlzcG9zaXRpb24iLCJyZXR1cm5WYWx1ZXMiLCJjb250ZW50RW5jb2RpbmciLCJjb250ZW50RGlzcG9zaXRpb24iLCJnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIiLCJuZWVkc0VuY29kaW5nRml4dXAiLCJ0b1BhcmFtUmVnRXhwIiwicmZjMjYxNnVucXVvdGUiLCJyZmM1OTg3ZGVjb2RlIiwicmZjMjA0N2RlY29kZSIsImZpeHVwRW5jb2RpbmciLCJyZmMyMjMxZ2V0cGFyYW0iLCJhdHRyaWJ1dGVQYXR0ZXJuIiwiZmxhZ3MiLCJ0ZXh0ZGVjb2RlIiwiY29udGVudERpc3Bvc2l0aW9uU3RyIiwiaXRlciIsInF1b3QiLCJwYXJ0IiwicGFydHMiLCJxdW90aW5kZXgiLCJleHR2YWx1ZSIsImVuY29kaW5nZW5kIiwibGFuZ3ZhbHVlIiwiY2hhcnNldCIsImhleCIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwieGhyIiwiTmV0d29ya01hbmFnZXIiLCJjdXJyWGhySWQiLCJwZW5kaW5nUmVxdWVzdHMiLCJyZXF1ZXN0UmFuZ2UiLCJyZXF1ZXN0RnVsbCIsInhocklkIiwicGVuZGluZ1JlcXVlc3QiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiZXhwZWN0ZWRTdGF0dXMiLCJvbkVycm9yIiwib25TdGF0ZUNoYW5nZSIsIm9ucHJvZ3Jlc3MiLCJvbkhlYWRlcnNSZWNlaXZlZCIsIm9uRG9uZSIsInhoclN0YXR1cyIsIm9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QiLCJyYW5nZUhlYWRlciIsImdldFJlcXVlc3RYaHIiLCJpc1BlbmRpbmdSZXF1ZXN0IiwiYWJvcnRSZXF1ZXN0IiwiX3NvdXJjZSIsIl9tYW5hZ2VyIiwiX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkIiwiUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyIiwiUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciIsIm9uQ2xvc2VkIiwibWFuYWdlciIsIl9vbkhlYWRlcnNSZWNlaXZlZCIsIl9vbkRvbmUiLCJfb25FcnJvciIsIl91cmwiLCJfZnVsbFJlcXVlc3RJZCIsIl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5IiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsImxlbmd0aENvbXB1dGFibGUiLCJfcmVxdWVzdElkIiwiX2Nsb3NlIiwiZmlsZVVyaVJlZ2V4IiwicGFyc2VVcmwiLCJzb3VyY2VVcmwiLCJwYXJzZWRVcmwiLCJob3N0IiwiaXNGc1VybCIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnVsbFJlYWRlciIsIlBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIiwiUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyIiwiQmFzZUZ1bGxSZWFkZXIiLCJfcmVhZGFibGVTdHJlYW0iLCJfZXJyb3IiLCJfc2V0UmVhZGFibGVTdHJlYW0iLCJCYXNlUmFuZ2VSZWFkZXIiLCJjcmVhdGVSZXF1ZXN0T3B0aW9ucyIsImF1dGgiLCJob3N0bmFtZSIsImhhbmRsZVJlc3BvbnNlIiwic3RhdHVzQ29kZSIsIl9yZXF1ZXN0IiwiaHR0cCIsImh0dHBzIiwiX2h0dHBIZWFkZXJzIiwiUmFuZ2UiLCJsc3RhdCIsInN0YXQiLCJjcmVhdGVSZWFkU3RyZWFtIiwiU1ZHX0RFRkFVTFRTIiwiZm9udFN0eWxlIiwiWE1MX05TIiwiWExJTktfTlMiLCJjb250ZW50VHlwZSIsImZvcmNlRGF0YVNjaGVtYSIsImRpZ2l0cyIsImIxIiwiYjIiLCJiMyIsImQxIiwiZDIiLCJkMyIsImQ0IiwiY29udmVydEltZ0RhdGFUb1BuZyIsIlBOR19IRUFERVIiLCJDSFVOS19XUkFQUEVSX1NJWkUiLCJjcmNUYWJsZSIsImNyYzMyIiwiY3JjIiwid3JpdGVQbmdDaHVuayIsImxlbiIsImFkbGVyMzIiLCJkZWZsYXRlU3luYyIsImxpdGVyYWxzIiwiZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQiLCJub2RlIiwiZnJvbSIsIm91dHB1dCIsIm1heEJsb2NrTGVuZ3RoIiwiZGVmbGF0ZUJsb2NrcyIsImlkYXQiLCJwaSIsImFkbGVyIiwiZW5jb2RlIiwiaXNNYXNrIiwiYml0RGVwdGgiLCJjb2xvclR5cGUiLCJvZmZzZXRMaXRlcmFscyIsIm9mZnNldEJ5dGVzIiwiaWhkciIsInBuZ0xlbmd0aCIsIlNWR0V4dHJhU3RhdGUiLCJkZXBlbmRlbmNpZXMiLCJhY3RpdmVDbGlwVXJsIiwiY2xpcEdyb3VwIiwibWFza0lkIiwib3BMaXN0VG9UcmVlIiwib3BMaXN0Iiwib3BUcmVlIiwib3BMaXN0RWxlbWVudCIsImZuIiwicGYiLCJwbSIsImFjb3MiLCJjbGlwQ291bnQiLCJtYXNrQ291bnQiLCJzaGFkaW5nQ291bnQiLCJzdmdGYWN0b3J5IiwidHJhbnNmb3JtTWF0cml4IiwidHJhbnNmb3JtU3RhY2siLCJleHRyYVN0YWNrIiwiZW1iZWRGb250cyIsImVtYmVkZGVkRm9udHMiLCJjc3NTdHlsZSIsIl9vcGVyYXRvcklkTWFwcGluZyIsInRncnAiLCJleGVjdXRlT3BUcmVlIiwibG9hZERlcGVuZGVuY2llcyIsImdldFNWRyIsInN2Z0VsZW1lbnQiLCJjb252ZXJ0T3BMaXN0Iiwib3BlcmF0b3JJZE1hcHBpbmciLCJvcFRyZWVFbGVtZW50IiwibGluZU1hdHJpeCIsInhjb29yZHMiLCJ5Y29vcmRzIiwidHNwYW4iLCJzZXRBdHRyaWJ1dGVOUyIsInR4dEVsZW1lbnQiLCJ0eHRncnAiLCJsaW5lV2lkdGhTY2FsZSIsIl9zZXRTdHJva2VBdHRyaWJ1dGVzIiwiX2Vuc3VyZVRyYW5zZm9ybUdyb3VwIiwiYWRkRm9udFN0eWxlIiwiaGFzQ2hpbGROb2RlcyIsInNldFN0cm9rZUFscGhhIiwic2V0RmlsbEFscGhhIiwiX21ha2VDb2xvck5fUGF0dGVybiIsIl9tYWtlU2hhZGluZ1BhdHRlcm4iLCJfbWFrZVRpbGluZ1BhdHRlcm4iLCJ0aWxpbmdJZCIsInR4MCIsInR5MCIsInR4MSIsInR5MSIsInhzY2FsZSIsInlzY2FsZSIsInR4c3RlcCIsInR5c3RlcCIsInRpbGluZyIsImNoaWxkTm9kZXMiLCJzaGFkaW5nSWQiLCJjb2xvclN0b3BzIiwiZ3JhZGllbnQiLCJwb2ludDAiLCJwb2ludDEiLCJmb2NhbFBvaW50IiwiY2lyY2xlUG9pbnQiLCJmb2NhbFJhZGl1cyIsImNpcmNsZVJhZGl1cyIsInN0b3AiLCJnZXRBdHRyaWJ1dGVOUyIsImNsaXBJZCIsImNsaXBQYXRoIiwiY2xpcEVsZW1lbnQiLCJjbG9uZU5vZGUiLCJpbWdTcmMiLCJjbGlwcmVjdCIsImltZ0VsIiwiZGVmaW5pdGlvbnMiLCJyb290R3JvdXAiLCJfZW5zdXJlQ2xpcEdyb3VwIiwid2FsayIsInNob3VsZEJ1aWxkVGV4dCIsImNoaWxkIiwiVGV4dExheWVyUmVuZGVyVGFzayIsInJlbmRlclRleHRMYXllciIsInVwZGF0ZVRleHRMYXllciIsIk1BWF9URVhUX0RJVlNfVE9fUkVOREVSIiwiREVGQVVMVF9GT05UX1NJWkUiLCJERUZBVUxUX0ZPTlRfQVNDRU5UIiwiYXNjZW50Q2FjaGUiLCJnZXRDdHgiLCJnZXRBc2NlbnQiLCJjYWNoZWRBc2NlbnQiLCJtZXRyaWNzIiwiYXNjZW50IiwiZm9udEJvdW5kaW5nQm94QXNjZW50IiwiZGVzY2VudCIsImZvbnRCb3VuZGluZ0JveERlc2NlbnQiLCJyYXRpbyIsInBpeGVscyIsImFwcGVuZFRleHQiLCJnZW9tIiwidGV4dERpdiIsInRleHREaXZQcm9wZXJ0aWVzIiwiaGFzVGV4dCIsImhhc0VPTCIsIl90ZXh0RGl2cyIsIl90cmFuc2Zvcm0iLCJhdGFuMiIsImZvbnROYW1lIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJfaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiX2NvbnRhaW5lciIsIl9yb290Q29udGFpbmVyIiwiX3BhZ2VXaWR0aCIsIl9wYWdlSGVpZ2h0IiwiZGlyIiwiX2ZvbnRJbnNwZWN0b3JFbmFibGVkIiwiZGF0YXNldCIsInNob3VsZFNjYWxlVGV4dCIsImFic1NjYWxlWCIsImFic1NjYWxlWSIsIl90ZXh0RGl2UHJvcGVydGllcyIsIl9pc1JlYWRhYmxlU3RyZWFtIiwiX2xheW91dFRleHQiLCJsYXlvdXQiLCJwcmV2Rm9udFNpemUiLCJwcmV2Rm9udEZhbWlseSIsIl9jYW5jZWxlZCIsInRleHREaXZzIiwidGV4dERpdnNMZW5ndGgiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJfdGV4dENvbnRlbnRTb3VyY2UiLCJfdGV4dENvbnRlbnRJdGVtc1N0ciIsIl9sYXlvdXRUZXh0UGFyYW1zIiwiX3Byb2Nlc3NJdGVtcyIsInN0eWxlQ2FjaGUiLCJiciIsIl9yZW5kZXIiLCJ0ZXh0Q29udGVudFN0cmVhbSIsInNjYWxlRmFjdG9yIiwibXVzdFJlc2NhbGUiLCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXIiLCJfZnJlZXRleHQiLCJfaW5rIiwiX3N0YW1wIiwiYWNjZXNzaWJpbGl0eU1hbmFnZXIiLCJhbGxvd0NsaWNrIiwiYW5ub3RhdGlvbkxheWVyIiwiYm91bmRQb2ludGVydXAiLCJib3VuZFBvaW50ZXJkb3duIiwiaGFkUG9pbnRlckRvd24iLCJpc0NsZWFuaW5nVXAiLCJpc0Rpc2FibGluZyIsIl9pbml0aWFsaXplZCIsInBvaW50ZXJ1cCIsIkZyZWVUZXh0RWRpdG9yIiwiSW5rRWRpdG9yIiwiU3RhbXBFZGl0b3IiLCJhZGRJbmtFZGl0b3JJZk5lZWRlZCIsImlzQ29tbWl0dGluZyIsImNyZWF0ZUFuZEFkZE5ld0VkaXRvciIsInBvaW50ZXJFdmVudHMiLCJhbm5vdGF0aW9uRWxlbWVudElkcyIsImVkaXRhYmxlcyIsImdldEVkaXRhYmxlQW5ub3RhdGlvbnMiLCJlZGl0YWJsZSIsImhpZGUiLCJoaWRkZW5Bbm5vdGF0aW9uSWRzIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9uIiwic2hvdyIsImN1cnJlbnRBY3RpdmUiLCJhdHRhY2giLCJkZXRhY2giLCJyZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIiLCJtb3ZlRWxlbWVudEluRE9NIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjcmVhdGVOZXdFZGl0b3IiLCJwYXN0ZUVkaXRvciIsImdldENlbnRlclBvaW50IiwiYW5ub3RhdGlvblR5cGUiLCJhbm5vdGF0aW9uRWRpdG9yVHlwZSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIl9hbm5vdGF0aW9uX2xheWVyIiwiYm91bmRFZGl0b3JEaXZCbHVyIiwiYm91bmRFZGl0b3JEaXZGb2N1cyIsImJvdW5kRWRpdG9yRGl2SW5wdXQiLCJib3VuZEVkaXRvckRpdktleWRvd24iLCJjb250ZW50IiwiZWRpdG9yRGl2SWQiLCJfZnJlZVRleHREZWZhdWx0Q29udGVudCIsIl9pbnRlcm5hbFBhZGRpbmciLCJfZGVmYXVsdENvbG9yIiwiX2RlZmF1bHRGb250U2l6ZSIsIl90cmFuc2xhdGVFbXB0eSIsImVkaXRvckRpdkJsdXIiLCJlZGl0b3JEaXZGb2N1cyIsImVkaXRvckRpdklucHV0IiwiZWRpdG9yRGl2S2V5ZG93biIsInVwZGF0ZUZvbnRTaXplIiwidXBkYXRlQ29sb3IiLCJzZXRGb250c2l6ZSIsImVkaXRvckRpdiIsInNldEVkaXRvckRpbWVuc2lvbnMiLCJzYXZlZEZvbnRzaXplIiwic2F2ZWRDb2xvciIsIm92ZXJsYXlEaXYiLCJjb250ZW50RWRpdGFibGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwcmV2ZW50U2Nyb2xsIiwiY2hlYXRJbml0aWFsUmVjdCIsImV4dHJhY3RUZXh0IiwiZGl2cyIsInNhdmVkRGlzcGxheSIsImRpc3BsYXkiLCJzYXZlZFRleHQiLCJuZXdUZXh0IiwidHJpbUVuZCIsInNldFRleHQiLCJzZXRDb250ZW50IiwiZGJsY2xpY2siLCJiYXNlWCIsImJhc2VZIiwicG9zWCIsInBvc1kiLCJyZXBsYWNlQ2hpbGRyZW4iLCJsaW5lIiwiY3JlYXRlVGV4dE5vZGUiLCJGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IiwiZGVmYXVsdEFwcGVhcmFuY2VEYXRhIiwiZm9udENvbG9yIiwidGV4dFBvc2l0aW9uIiwicGFkZGluZyIsInN0cnVjdFRyZWVQYXJlbnRJZCIsImhhc0VsZW1lbnRDaGFuZ2VkIiwiU3RhbXBBbm5vdGF0aW9uRWxlbWVudCIsIklua0Fubm90YXRpb25FbGVtZW50IiwiQW5ub3RhdGlvbkxheWVyIiwiX3NjcmlwdGluZ191dGlscyIsIl9kaXNwbGF5TDEwbl91dGlscyIsIl94ZmFfbGF5ZXIiLCJERUZBVUxUX1RBQl9JTkRFWCIsIkdldEVsZW1lbnRzQnlOYW1lU2V0IiwiZ2V0UmVjdERpbXMiLCJBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkiLCJMaW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJmaWVsZFR5cGUiLCJUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJyYWRpb0J1dHRvbiIsIlJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJjaGVja0JveCIsIkNoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb3B1cEFubm90YXRpb25FbGVtZW50IiwiTGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQiLCJDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJDYXJldEFubm90YXRpb25FbGVtZW50IiwiUG9seWdvbkFubm90YXRpb25FbGVtZW50IiwiSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQiLCJVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQiLCJTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCIsIkZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uRWxlbWVudCIsImhhc0JvcmRlciIsImlzUmVuZGVyYWJsZSIsImlnbm9yZUJvcmRlciIsImNyZWF0ZVF1YWRyaWxhdGVyYWxzIiwibGlua1NlcnZpY2UiLCJkb3dubG9hZE1hbmFnZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJyZW5kZXJGb3JtcyIsImVuYWJsZVNjcmlwdGluZyIsIl9maWVsZE9iamVjdHMiLCJmaWVsZE9iamVjdHMiLCJfY3JlYXRlQ29udGFpbmVyIiwiX2NyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiX2hhc1BvcHVwRGF0YSIsInRpdGxlT2JqIiwiY29udGVudHNPYmoiLCJyaWNoVGV4dCIsImhhc1BvcHVwRGF0YSIsInBvcHVwUmVmIiwibm9Sb3RhdGUiLCJzZXRSb3RhdGlvbiIsImJvcmRlclN0eWxlIiwiYm9yZGVyV2lkdGgiLCJob3Jpem9udGFsUmFkaXVzIiwiaG9yaXpvbnRhbENvcm5lclJhZGl1cyIsInZlcnRpY2FsUmFkaXVzIiwidmVydGljYWxDb3JuZXJSYWRpdXMiLCJyYWRpdXMiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckNvbG9yIiwiZWxlbWVudFdpZHRoIiwiZWxlbWVudEhlaWdodCIsIl9jb21tb25BY3Rpb25zIiwic2V0Q29sb3IiLCJqc05hbWUiLCJzdHlsZU5hbWUiLCJkZXRhaWwiLCJjb2xvckFycmF5IiwiQ29sb3JDb252ZXJ0ZXJzIiwibm9WaWV3Iiwibm9QcmludCIsInVzZXJOYW1lIiwidGl0bGUiLCJyZWFkb25seSIsImRpc2FibGVkIiwicmVxdWlyZWQiLCJfc2V0UmVxdWlyZWQiLCJ0ZXh0Q29sb3IiLCJfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94IiwiYWN0aW9ucyIsImpzRXZlbnQiLCJjb21tb25BY3Rpb25zIiwiX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTIiwic3RvcmVkRGF0YSIsImV2ZW50UHJveHkiLCJxdWFkUG9pbnRzIiwicmVjdEJsWCIsInJlY3RCbFkiLCJyZWN0VHJYIiwicmVjdFRyWSIsInRyWCIsInRyWSIsImJsWCIsImJsWSIsInN2Z0J1ZmZlciIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJfY3JlYXRlUG9wdXAiLCJwb3B1cCIsIm1vZGlmaWNhdGlvbkRhdGUiLCJwYXJlbnRSZWN0IiwiZWxlbWVudHMiLCJfZ2V0RWxlbWVudHNCeU5hbWUiLCJza2lwSWQiLCJmaWVsZHMiLCJmaWVsZE9iaiIsImV4cG9ydFZhbHVlcyIsImV4cG9ydFZhbHVlIiwiZG9tRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRFbGVtZW50c0J5TmFtZSIsImdldEF0dHJpYnV0ZSIsIm1heWJlU2hvdyIsImZvcmNlSGlkZSIsImdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAiLCJhZGRIaWdobGlnaHRBcmVhIiwidHJpZ2dlcnMiLCJfZWRpdE9uRG91YmxlQ2xpY2siLCJpc1Rvb2x0aXBPbmx5IiwibGluayIsImlzQm91bmQiLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsIl9iaW5kTmFtZWRBY3Rpb24iLCJhdHRhY2htZW50IiwiX2JpbmRBdHRhY2htZW50Iiwic2V0T0NHU3RhdGUiLCJiaW5kU2V0T0NHU3RhdGUiLCJfYmluZExpbmsiLCJBY3Rpb24iLCJfYmluZEpTQWN0aW9uIiwicmVzZXRGb3JtIiwiX2JpbmRSZXNldEZvcm1BY3Rpb24iLCJzZXRJbnRlcm5hbExpbmsiLCJkZXN0aW5hdGlvbiIsImdldERlc3RpbmF0aW9uSGFzaCIsIm9uY2xpY2siLCJnb1RvRGVzdGluYXRpb24iLCJnZXRBbmNob3JVcmwiLCJleGVjdXRlTmFtZWRBY3Rpb24iLCJvcGVuT3JEb3dubG9hZERhdGEiLCJleGVjdXRlU2V0T0NHU3RhdGUiLCJvdGhlckNsaWNrQWN0aW9uIiwicmVzZXRGb3JtRmllbGRzIiwicmVmcyIsInJlc2V0Rm9ybVJlZnMiLCJpbmNsdWRlIiwiYWxsRmllbGRzIiwiZmllbGRJZHMiLCJmaWVsZE5hbWUiLCJmaWVsZCIsImFsbElkcyIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsImFsdCIsImwxMG5JZCIsImwxMG5BcmdzIiwiYWx0ZXJuYXRpdmVUZXh0Iiwic2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzIiwicHJldmlvdXNTaWJsaW5nIiwibm9kZU5hbWUiLCJfZ2V0S2V5TW9kaWZpZXIiLCJfc2V0RXZlbnRMaXN0ZW5lciIsImVsZW1lbnREYXRhIiwiYmFzZU5hbWUiLCJldmVudE5hbWUiLCJ2YWx1ZUdldHRlciIsIm1vZGlmaWVyIiwiZm9jdXNlZCIsIl9zZXRFdmVudExpc3RlbmVycyIsImdldHRlciIsIkJsdXIiLCJGb2N1cyIsIl9zZXRCYWNrZ3JvdW5kQ29sb3IiLCJfc2V0VGV4dFN0eWxlIiwiVEVYVF9BTElHTk1FTlQiLCJjb21wdXRlZEZvbnRTaXplIiwicm91bmRUb09uZURlY2ltYWwiLCJtdWx0aUxpbmUiLCJudW1iZXJPZkxpbmVzIiwibGluZUhlaWdodCIsInRleHRBbGlnbm1lbnQiLCJ0ZXh0QWxpZ24iLCJpc1JlcXVpcmVkIiwiaGFzQXBwZWFyYW5jZSIsImZpZWxkVmFsdWUiLCJzZXRQcm9wZXJ0eU9uU2libGluZ3MiLCJrZXlJblN0b3JhZ2UiLCJtYXhMZW4iLCJjaGFyTGltaXQiLCJmaWVsZEZvcm1hdHRlZFZhbHVlcyIsImZvcm1hdHRlZFZhbHVlIiwiY29tYiIsInVzZXJWYWx1ZSIsImxhc3RDb21taXR0ZWRWYWx1ZSIsImNvbW1pdEtleSIsImRvTm90U2Nyb2xsIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwicmVhZE9ubHkiLCJtYXhMZW5ndGgiLCJkZWZhdWx0RmllbGRWYWx1ZSIsImJsdXJMaXN0ZW5lciIsInNjcm9sbExlZnQiLCJzZWxSYW5nZSIsInNldFNlbGVjdGlvblJhbmdlIiwid2lsbENvbW1pdCIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJfYmx1ckxpc3RlbmVyIiwiS2V5c3Ryb2tlIiwiaW5wdXRUeXBlIiwiY2hhbmdlIiwiZmllbGRXaWR0aCIsImNvbWJXaWR0aCIsImxldHRlclNwYWNpbmciLCJ2ZXJ0aWNhbEFsaWduIiwiY2hlY2tlZCIsImNoZWNrYm94IiwiY3VyQ2hlY2tlZCIsImJ1dHRvblZhbHVlIiwicmFkaW8iLCJwZGZCdXR0b25WYWx1ZSIsImxpbmtFbGVtZW50IiwibGFzdENoaWxkIiwic2VsZWN0RWxlbWVudCIsImFkZEFuRW1wdHlFbnRyeSIsImNvbWJvIiwibXVsdGlTZWxlY3QiLCJtdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkIiwib3B0aW9uRWxlbWVudCIsImRpc3BsYXlWYWx1ZSIsInJlbW92ZUVtcHR5RW50cnkiLCJub25lT3B0aW9uRWxlbWVudCIsImlzRXhwb3J0Iiwic2VsZWN0ZWRJbmRleCIsInNlbGVjdGVkVmFsdWVzIiwiZ2V0SXRlbXMiLCJtdWx0aXBsZVNlbGVjdGlvbiIsImluZGV4IiwiZmluZEluZGV4Iiwic2VsZWN0Q2hpbGQiLCJiZWZvcmUiLCJpbmRpY2VzIiwiY2hhbmdlRXgiLCJrZXlEb3duIiwiUG9wdXBFbGVtZW50IiwiZWxlbWVudElkcyIsImRhdGVUaW1lUHJvbWlzZSIsImJvdW5kS2V5RG93biIsImJvdW5kSGlkZSIsImJvdW5kU2hvdyIsImJvdW5kVG9nZ2xlIiwicGlubmVkIiwid2FzVmlzaWJsZSIsImRhdGVPYmplY3QiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJ0cmlnZ2VyIiwiZmxhdE1hcCIsImJhc2VDb2xvciIsIm91dGxpbmVDb2xvciIsIkJBQ0tHUk9VTkRfRU5MSUdIVCIsImhlYWRlciIsImxvY2FsaXplZCIsIlhmYUxheWVyIiwieGZhSHRtbCIsImh0bWwiLCJjb250ZW50cyIsIl9mb3JtYXRDb250ZW50cyIsInVzZVBhcmVudFJlY3QiLCJub3JtYWxpemVkUmVjdCIsIkhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiIsInBvcHVwTGVmdCIsInBvcHVwVG9wIiwibGluZXMiLCJsaW5lU3BhbiIsImxpbmVDb29yZGluYXRlcyIsInNxdWFyZSIsImNpcmNsZSIsInBvbHlsaW5lIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwic3ZnRWxlbWVudE5hbWUiLCJjb29yZGluYXRlIiwidmVydGljZXMiLCJwb2x5bGluZXMiLCJpbmtMaXN0IiwiaW5rTGlzdHMiLCJkb3dubG9hZCIsImVkaXRhYmxlQW5ub3RhdGlvbnMiLCJOdWxsTDEwbiIsImFwcGVuZEVsZW1lbnQiLCJjb250ZW50RWxlbWVudCIsImZpcnN0Q2hpbGQiLCJhbm5vdGF0aW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsInJlcGxhY2VXaXRoIiwibWFrZUNvbG9yQ29tcCIsInNjYWxlQW5kQ2xhbXAiLCJDTVlLX0ciLCJHX0NNWUsiLCJHX1JHQiIsIkdfcmdiIiwiR19IVE1MIiwiRyIsIlJHQl9HIiwiUkdCX3JnYiIsIlJHQl9IVE1MIiwiVF9IVE1MIiwiVF9yZ2IiLCJDTVlLX1JHQiIsIkNNWUtfcmdiIiwiQ01ZS19IVE1MIiwiY29tcG9uZW50cyIsIlJHQl9DTVlLIiwiZ2V0TDEwbkZhbGxiYWNrIiwiREVGQVVMVF9MMTBOX1NUUklOR1MiLCJvZl9wYWdlcyIsInBhZ2Vfb2ZfcGFnZXMiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX2tiIiwiZG9jdW1lbnRfcHJvcGVydGllc19tYiIsImRvY3VtZW50X3Byb3BlcnRpZXNfZGF0ZV9zdHJpbmciLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV91bml0X2luY2hlcyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfbWlsbGltZXRlcnMiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9vcmllbnRhdGlvbl9wb3J0cmFpdCIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX29yaWVudGF0aW9uX2xhbmRzY2FwZSIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTMiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2E0IiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9sZXR0ZXIiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xlZ2FsIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX3N0cmluZyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX2RpbWVuc2lvbl9uYW1lX3N0cmluZyIsImRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF95ZXMiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX2xpbmVhcml6ZWRfbm8iLCJhZGRpdGlvbmFsX2xheWVycyIsInBhZ2VfbGFuZG1hcmsiLCJ0aHVtYl9wYWdlX3RpdGxlIiwidGh1bWJfcGFnZV9jYW52YXMiLCJmaW5kX3JlYWNoZWRfdG9wIiwiZmluZF9yZWFjaGVkX2JvdHRvbSIsImZpbmRfbm90X2ZvdW5kIiwicGFnZV9zY2FsZV93aWR0aCIsInBhZ2Vfc2NhbGVfZml0IiwicGFnZV9zY2FsZV9hdXRvIiwicGFnZV9zY2FsZV9hY3R1YWwiLCJwYWdlX3NjYWxlX3BlcmNlbnQiLCJsb2FkaW5nX2Vycm9yIiwiaW52YWxpZF9maWxlX2Vycm9yIiwibWlzc2luZ19maWxlX2Vycm9yIiwidW5leHBlY3RlZF9yZXNwb25zZV9lcnJvciIsInJlbmRlcmluZ19lcnJvciIsImFubm90YXRpb25fZGF0ZV9zdHJpbmciLCJwcmludGluZ19ub3Rfc3VwcG9ydGVkIiwicHJpbnRpbmdfbm90X3JlYWR5Iiwid2ViX2ZvbnRzX2Rpc2FibGVkIiwiZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnQiLCJlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsIiwiZWRpdG9yX2luazJfYXJpYV9sYWJlbCIsImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWwiLCJlZGl0b3JfYWx0X3RleHRfYnV0dG9uX2xhYmVsIiwiZWRpdG9yX2FsdF90ZXh0X2VkaXRfYnV0dG9uX2xhYmVsIiwiZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcCIsInByaW50X3Byb2dyZXNzX3BlcmNlbnQiLCJmb3JtYXRMMTBuVmFsdWUiLCJnZXRMYW5ndWFnZSIsImdldERpcmVjdGlvbiIsInNldHVwU3RvcmFnZSIsInhmYU9uIiwieGZhT2ZmIiwic2V0QXR0cmlidXRlcyIsImlzSFRNTEFuY2hvckVsZW1lbnQiLCJIVE1MQW5jaG9yRWxlbWVudCIsImRhdGFJZCIsInJvb3RIdG1sIiwic3RhY2siLCJyb290RGl2IiwiY2hpbGRIdG1sIiwieG1sbnMiLCJlbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJiYXNlSGVpZ2h0IiwiYmFzZVdpZHRoIiwiYm91bmRDYW52YXNQb2ludGVybW92ZSIsImJvdW5kQ2FudmFzUG9pbnRlcmxlYXZlIiwiYm91bmRDYW52YXNQb2ludGVydXAiLCJib3VuZENhbnZhc1BvaW50ZXJkb3duIiwiY3VycmVudFBhdGgyRCIsImhhc1NvbWV0aGluZ1RvRHJhdyIsImlzQ2FudmFzSW5pdGlhbGl6ZWQiLCJvYnNlcnZlciIsInJlYWxXaWR0aCIsInJlYWxIZWlnaHQiLCJyZXF1ZXN0RnJhbWVDYWxsYmFjayIsIl9kZWZhdWx0T3BhY2l0eSIsIl9kZWZhdWx0VGhpY2tuZXNzIiwiY2FudmFzUG9pbnRlcm1vdmUiLCJjYW52YXNQb2ludGVybGVhdmUiLCJjYW52YXNQb2ludGVydXAiLCJjYW52YXNQb2ludGVyZG93biIsInRoaWNrbmVzcyIsImJlemllclBhdGgyRCIsImFsbFJhd1BhdGhzIiwiY3VycmVudFBhdGgiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJ1cGRhdGVUaGlja25lc3MiLCJ1cGRhdGVPcGFjaXR5Iiwic2F2ZWRUaGlja25lc3MiLCJmaXRUb0NvbnRlbnQiLCJyZWRyYXciLCJzYXZlZE9wYWNpdHkiLCJjcmVhdGVPYnNlcnZlciIsInNldENhbnZhc0RpbXMiLCJkaXNjb25uZWN0Iiwic2V0RGltZW5zaW9ucyIsImdldEluaXRpYWxCQm94Iiwic2V0U3Ryb2tlIiwic3RhcnREcmF3aW5nIiwiZHJhd1BvaW50cyIsImRyYXciLCJsYXN0WCIsImxhc3RZIiwicGF0aDJEIiwibWFrZUJlemllckN1cnZlIiwibGFzdFBvaW50Iiwic3RvcERyYXdpbmciLCJiZXppZXIiLCJnZW5lcmF0ZUJlemllclBvaW50cyIsInh5IiwibGFzdFBvaW50cyIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJwcmV2WCIsInByZXZZIiwiYmV6aWVyUG9pbnRzIiwiY29udHJvbDEiLCJjb250cm9sMiIsInVwZGF0ZVRyYW5zZm9ybSIsIlJlc2l6ZU9ic2VydmVyIiwiY29udGVudFJlY3QiLCJvYnNlcnZlIiwicm91bmRlZFdpZHRoIiwicm91bmRlZEhlaWdodCIsInNldFNjYWxlRmFjdG9yIiwiZ2V0UGFkZGluZyIsInNjYWxlRmFjdG9yVyIsInNjYWxlRmFjdG9ySCIsImJ1aWxkUGF0aDJEIiwidG9QREZDb29yZGluYXRlcyIsImZyb21QREZDb29yZGluYXRlcyIsInNlcmlhbGl6ZVBhdGhzIiwicDEwIiwicDExIiwicDIwIiwicDIxIiwicDMwIiwicDMxIiwicDQwIiwicDQxIiwiZ2V0QmJveCIsImZpcnN0VGltZSIsInByZXZUcmFuc2xhdGlvblgiLCJwcmV2VHJhbnNsYXRpb25ZIiwidW5zY2FsZWRQYWRkaW5nIiwiYml0bWFwSWQiLCJiaXRtYXBQcm9taXNlIiwiYml0bWFwVXJsIiwiYml0bWFwRmlsZSIsInJlc2l6ZVRpbWVvdXRJZCIsImhhc0JlZW5BZGRlZEluVW5kb1N0YWNrIiwic3VwcG9ydGVkVHlwZXMiLCJzdXBwb3J0ZWRUeXBlc1N0ciIsImdldEFzRmlsZSIsImdldEJpdG1hcEZldGNoZWQiLCJmcm9tSWQiLCJnZXRCaXRtYXBEb25lIiwiZ2V0Qml0bWFwIiwiYWNjZXB0IiwiZmlsZXMiLCJjbGljayIsIk1BWF9SQVRJTyIsImZhY3RvciIsImRyYXdCaXRtYXAiLCJzY2FsZUJpdG1hcCIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0IiwicHJldldpZHRoIiwicHJldkhlaWdodCIsIm9mZnNjcmVlbiIsInRyYW5zZmVyVG9JbWFnZUJpdG1hcCIsInNlcmlhbGl6ZUJpdG1hcCIsInRvVXJsIiwidG9EYXRhVVJMIiwiYWNjZXNzaWJpbGl0eURhdGEiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIiLCJfYXBpIiwiX3RleHRfbGF5ZXIiLCJwZGZqc1ZlcnNpb24iLCJwZGZqc0J1aWxkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Document.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Document.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var make_event_props__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! make-event-props */ \"(ssr)/./node_modules/make-event-props/dist/esm/index.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var dequal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dequal */ \"(ssr)/./node_modules/dequal/dist/index.mjs\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _DocumentContext_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/DocumentContext.js\");\n/* harmony import */ var _Message_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Message.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Message.js\");\n/* harmony import */ var _LinkService_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LinkService.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/LinkService.js\");\n/* harmony import */ var _PasswordResponses_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PasswordResponses.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/PasswordResponses.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./shared/propTypes.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/propTypes.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { PDFDataRangeTransport } = _pdfjs_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nconst defaultOnPassword = (callback, reason)=>{\n    switch(reason){\n        case _PasswordResponses_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].NEED_PASSWORD:\n            {\n                // eslint-disable-next-line no-alert\n                const password = prompt(\"Enter the password to open this PDF file.\");\n                callback(password);\n                break;\n            }\n        case _PasswordResponses_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].INCORRECT_PASSWORD:\n            {\n                // eslint-disable-next-line no-alert\n                const password = prompt(\"Invalid password. Please try again.\");\n                callback(password);\n                break;\n            }\n        default:\n    }\n};\nfunction isParameterObject(file) {\n    return typeof file === \"object\" && file !== null && (\"data\" in file || \"range\" in file || \"url\" in file);\n}\n/**\n * Loads a document passed using `file` prop.\n */ const Document = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Document(_a, ref) {\n    var { children, className, error = \"Failed to load PDF file.\", externalLinkRel, externalLinkTarget, file, inputRef, imageResourcesPath, loading = \"Loading PDF…\", noData = \"No PDF file specified.\", onItemClick, onLoadError: onLoadErrorProps, onLoadProgress, onLoadSuccess: onLoadSuccessProps, onPassword = defaultOnPassword, onSourceError: onSourceErrorProps, onSourceSuccess: onSourceSuccessProps, options, renderMode, rotate } = _a, otherProps = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"error\",\n        \"externalLinkRel\",\n        \"externalLinkTarget\",\n        \"file\",\n        \"inputRef\",\n        \"imageResourcesPath\",\n        \"loading\",\n        \"noData\",\n        \"onItemClick\",\n        \"onLoadError\",\n        \"onLoadProgress\",\n        \"onLoadSuccess\",\n        \"onPassword\",\n        \"onSourceError\",\n        \"onSourceSuccess\",\n        \"options\",\n        \"renderMode\",\n        \"rotate\"\n    ]);\n    const [sourceState, sourceDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    const { value: source, error: sourceError } = sourceState;\n    const [pdfState, pdfDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    const { value: pdf, error: pdfError } = pdfState;\n    const linkService = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new _LinkService_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]());\n    const pages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const prevFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const prevOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (file && file !== prevFile.current && isParameterObject(file)) {\n            warning__WEBPACK_IMPORTED_MODULE_3__(!(0,dequal__WEBPACK_IMPORTED_MODULE_4__.dequal)(file, prevFile.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"file\" prop.`);\n            prevFile.current = file;\n        }\n    }, [\n        file\n    ]);\n    // Detect non-memoized changes in options prop\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (options && options !== prevOptions.current) {\n            warning__WEBPACK_IMPORTED_MODULE_3__(!(0,dequal__WEBPACK_IMPORTED_MODULE_4__.dequal)(options, prevOptions.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to \"options\" prop.`);\n            prevOptions.current = options;\n        }\n    }, [\n        options\n    ]);\n    const viewer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        // Handling jumping to internal links target\n        scrollPageIntoView: (args)=>{\n            const { dest, pageNumber, pageIndex = pageNumber - 1 } = args;\n            // First, check if custom handling of onItemClick was provided\n            if (onItemClick) {\n                onItemClick({\n                    dest,\n                    pageIndex,\n                    pageNumber\n                });\n                return;\n            }\n            // If not, try to look for target page within the <Document>.\n            const page = pages.current[pageIndex];\n            if (page) {\n                // Scroll to the page automatically\n                page.scrollIntoView();\n                return;\n            }\n            warning__WEBPACK_IMPORTED_MODULE_3__(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>({\n            linkService,\n            pages,\n            viewer\n        }), []);\n    /**\n     * Called when a document source is resolved correctly\n     */ function onSourceSuccess() {\n        if (onSourceSuccessProps) {\n            onSourceSuccessProps();\n        }\n    }\n    /**\n     * Called when a document source failed to be resolved correctly\n     */ function onSourceError() {\n        if (!sourceError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, sourceError.toString());\n        if (onSourceErrorProps) {\n            onSourceErrorProps(sourceError);\n        }\n    }\n    function resetSource() {\n        sourceDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetSource, [\n        file,\n        sourceDispatch\n    ]);\n    const findDocumentSource = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>__awaiter(this, void 0, void 0, function*() {\n            if (!file) {\n                return null;\n            }\n            // File is a string\n            if (typeof file === \"string\") {\n                if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.isDataURI)(file)) {\n                    const fileByteString = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.dataURItoByteString)(file);\n                    return {\n                        data: fileByteString\n                    };\n                }\n                (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.displayCORSWarning)();\n                return {\n                    url: file\n                };\n            }\n            // File is PDFDataRangeTransport\n            if (file instanceof PDFDataRangeTransport) {\n                return {\n                    range: file\n                };\n            }\n            // File is an ArrayBuffer\n            if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.isArrayBuffer)(file)) {\n                return {\n                    data: file\n                };\n            }\n            /**\n         * The cases below are browser-only.\n         * If you're running on a non-browser environment, these cases will be of no use.\n         */ if (_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.isBrowser) {\n                // File is a Blob\n                if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.isBlob)(file)) {\n                    const data = yield (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.loadFromFile)(file);\n                    return {\n                        data\n                    };\n                }\n            }\n            // At this point, file must be an object\n            (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(typeof file === \"object\", \"Invalid parameter in file, need either Uint8Array, string or a parameter object\");\n            (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(isParameterObject(file), \"Invalid parameter object: need either .data, .range or .url\");\n            // File .url is a string\n            if (\"url\" in file && typeof file.url === \"string\") {\n                if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.isDataURI)(file.url)) {\n                    const { url } = file, otherParams = __rest(file, [\n                        \"url\"\n                    ]);\n                    const fileByteString = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.dataURItoByteString)(url);\n                    return Object.assign({\n                        data: fileByteString\n                    }, otherParams);\n                }\n                (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.displayCORSWarning)();\n            }\n            return file;\n        }), [\n        file\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(findDocumentSource());\n        cancellable.promise.then((nextSource)=>{\n            sourceDispatch({\n                type: \"RESOLVE\",\n                value: nextSource\n            });\n        }).catch((error)=>{\n            sourceDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_9__.cancelRunningTask)(cancellable);\n        };\n    }, [\n        findDocumentSource,\n        sourceDispatch\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof source === \"undefined\") {\n            return;\n        }\n        if (source === false) {\n            onSourceError();\n            return;\n        }\n        onSourceSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        source\n    ]);\n    /**\n     * Called when a document is read successfully\n     */ function onLoadSuccess() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(pdf);\n        }\n        pages.current = new Array(pdf.numPages);\n        linkService.current.setDocument(pdf);\n    }\n    /**\n     * Called when a document failed to read successfully\n     */ function onLoadError() {\n        if (!pdfError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, pdfError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(pdfError);\n        }\n    }\n    function resetDocument() {\n        pdfDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetDocument, [\n        pdfDispatch,\n        source\n    ]);\n    function loadDocument() {\n        if (!source) {\n            return;\n        }\n        const documentInitParams = options ? Object.assign(Object.assign({}, source), options) : source;\n        const destroyable = _pdfjs_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].getDocument(documentInitParams);\n        if (onLoadProgress) {\n            destroyable.onProgress = onLoadProgress;\n        }\n        if (onPassword) {\n            destroyable.onPassword = onPassword;\n        }\n        const loadingTask = destroyable;\n        loadingTask.promise.then((nextPdf)=>{\n            pdfDispatch({\n                type: \"RESOLVE\",\n                value: nextPdf\n            });\n        }).catch((error)=>{\n            if (loadingTask.destroyed) {\n                return;\n            }\n            pdfDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            loadingTask.destroy();\n        };\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadDocument, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        options,\n        pdfDispatch,\n        source\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof pdf === \"undefined\") {\n            return;\n        }\n        if (pdf === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        pdf\n    ]);\n    function setupLinkService() {\n        linkService.current.setViewer(viewer.current);\n        linkService.current.setExternalLinkRel(externalLinkRel);\n        linkService.current.setExternalLinkTarget(externalLinkTarget);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(setupLinkService, [\n        externalLinkRel,\n        externalLinkTarget\n    ]);\n    function registerPage(pageIndex, ref) {\n        pages.current[pageIndex] = ref;\n    }\n    function unregisterPage(pageIndex) {\n        delete pages.current[pageIndex];\n    }\n    const childContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            imageResourcesPath,\n            linkService: linkService.current,\n            onItemClick,\n            pdf,\n            registerPage,\n            renderMode,\n            rotate,\n            unregisterPage\n        }), [\n        imageResourcesPath,\n        onItemClick,\n        pdf,\n        renderMode,\n        rotate\n    ]);\n    const eventProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,make_event_props__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(otherProps, ()=>pdf), [\n        otherProps,\n        pdf\n    ]);\n    function renderChildren() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_DocumentContext_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].Provider, {\n            value: childContext\n        }, children);\n    }\n    function renderContent() {\n        if (!file) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                type: \"no-data\"\n            }, typeof noData === \"function\" ? noData() : noData);\n        }\n        if (pdf === undefined || pdf === null) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                type: \"loading\"\n            }, typeof loading === \"function\" ? loading() : loading);\n        }\n        if (pdf === false) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                type: \"error\"\n            }, typeof error === \"function\" ? error() : error);\n        }\n        return renderChildren();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"react-pdf__Document\", className),\n        ref: inputRef,\n        style: {\n            [\"--scale-factor\"]: \"1\"\n        }\n    }, eventProps), renderContent());\n});\nconst isFunctionOrNode = prop_types__WEBPACK_IMPORTED_MODULE_14__.oneOfType([\n    prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    prop_types__WEBPACK_IMPORTED_MODULE_14__.node\n]);\nDocument.propTypes = Object.assign(Object.assign({}, _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_15__.eventProps), {\n    children: prop_types__WEBPACK_IMPORTED_MODULE_14__.node,\n    className: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_15__.isClassName,\n    error: isFunctionOrNode,\n    externalLinkRel: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n    externalLinkTarget: prop_types__WEBPACK_IMPORTED_MODULE_14__.oneOf([\n        \"_self\",\n        \"_blank\",\n        \"_parent\",\n        \"_top\"\n    ]),\n    file: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_15__.isFile,\n    imageResourcesPath: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n    inputRef: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_15__.isRef,\n    loading: isFunctionOrNode,\n    noData: isFunctionOrNode,\n    onItemClick: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onLoadProgress: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onLoadSuccess: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onPassword: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onSourceError: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    onSourceSuccess: prop_types__WEBPACK_IMPORTED_MODULE_14__.func,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_14__.shape({\n        canvasFactory: prop_types__WEBPACK_IMPORTED_MODULE_14__.any,\n        canvasMaxAreaInBytes: prop_types__WEBPACK_IMPORTED_MODULE_14__.number,\n        cMapPacked: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        CMapReaderFactory: prop_types__WEBPACK_IMPORTED_MODULE_14__.any,\n        cMapUrl: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n        disableAutoFetch: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        disableFontFace: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        disableRange: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        disableStream: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        docBaseUrl: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n        enableXfa: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        filterFactory: prop_types__WEBPACK_IMPORTED_MODULE_14__.any,\n        fontExtraProperties: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        httpHeaders: prop_types__WEBPACK_IMPORTED_MODULE_14__.object,\n        isEvalSupported: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        isOffscreenCanvasSupported: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        length: prop_types__WEBPACK_IMPORTED_MODULE_14__.number,\n        maxImageSize: prop_types__WEBPACK_IMPORTED_MODULE_14__.number,\n        ownerDocument: prop_types__WEBPACK_IMPORTED_MODULE_14__.any,\n        password: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n        pdfBug: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        rangeChunkSize: prop_types__WEBPACK_IMPORTED_MODULE_14__.number,\n        StandardFontDataFactory: prop_types__WEBPACK_IMPORTED_MODULE_14__.any,\n        standardFontDataUrl: prop_types__WEBPACK_IMPORTED_MODULE_14__.string,\n        stopAtErrors: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        useSystemFonts: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        useWorkerFetch: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        verbosity: prop_types__WEBPACK_IMPORTED_MODULE_14__.number,\n        withCredentials: prop_types__WEBPACK_IMPORTED_MODULE_14__.bool,\n        worker: prop_types__WEBPACK_IMPORTED_MODULE_14__.any\n    }),\n    rotate: prop_types__WEBPACK_IMPORTED_MODULE_14__.number\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Document);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL0RvY3VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZEQUNBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLFNBQVMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsTUFBTSxJQUFLLFNBQVVDLENBQUMsRUFBRVAsQ0FBQztJQUNoRCxJQUFJUSxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtGLEVB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NkNBQWM7UUFDL0JrSyxRQUFRbEssNENBQWE7SUFDekI7SUFBSTRELFFBQVE1RCwrQ0FBZ0I7QUFBQztBQUNqQyxpRUFBZW1DLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vRG9jdW1lbnQuanM/ZDkyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vLCB1c2VSZWYsIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYWtlRXZlbnRQcm9wcyBmcm9tICdtYWtlLWV2ZW50LXByb3BzJztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCB7IGRlcXVhbCB9IGZyb20gJ2RlcXVhbCc7XG5pbXBvcnQgcGRmanMgZnJvbSAnLi9wZGZqcy5qcyc7XG5pbXBvcnQgRG9jdW1lbnRDb250ZXh0IGZyb20gJy4vRG9jdW1lbnRDb250ZXh0LmpzJztcbmltcG9ydCBNZXNzYWdlIGZyb20gJy4vTWVzc2FnZS5qcyc7XG5pbXBvcnQgTGlua1NlcnZpY2UgZnJvbSAnLi9MaW5rU2VydmljZS5qcyc7XG5pbXBvcnQgUGFzc3dvcmRSZXNwb25zZXMgZnJvbSAnLi9QYXNzd29yZFJlc3BvbnNlcy5qcyc7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzaywgZGF0YVVSSXRvQnl0ZVN0cmluZywgZGlzcGxheUNPUlNXYXJuaW5nLCBpc0FycmF5QnVmZmVyLCBpc0Jsb2IsIGlzQnJvd3NlciwgaXNEYXRhVVJJLCBsb2FkRnJvbUZpbGUsIH0gZnJvbSAnLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHVzZVJlc29sdmVyIGZyb20gJy4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzJztcbmltcG9ydCB7IGV2ZW50UHJvcHMsIGlzQ2xhc3NOYW1lLCBpc0ZpbGUsIGlzUmVmIH0gZnJvbSAnLi9zaGFyZWQvcHJvcFR5cGVzLmpzJztcbmNvbnN0IHsgUERGRGF0YVJhbmdlVHJhbnNwb3J0IH0gPSBwZGZqcztcbmNvbnN0IGRlZmF1bHRPblBhc3N3b3JkID0gKGNhbGxiYWNrLCByZWFzb24pID0+IHtcbiAgICBzd2l0Y2ggKHJlYXNvbikge1xuICAgICAgICBjYXNlIFBhc3N3b3JkUmVzcG9uc2VzLk5FRURfUEFTU1dPUkQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwcm9tcHQoJ0VudGVyIHRoZSBwYXNzd29yZCB0byBvcGVuIHRoaXMgUERGIGZpbGUuJyk7XG4gICAgICAgICAgICBjYWxsYmFjayhwYXNzd29yZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFBhc3N3b3JkUmVzcG9uc2VzLklOQ09SUkVDVF9QQVNTV09SRDoge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFsZXJ0XG4gICAgICAgICAgICBjb25zdCBwYXNzd29yZCA9IHByb21wdCgnSW52YWxpZCBwYXNzd29yZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzUGFyYW1ldGVyT2JqZWN0KGZpbGUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBmaWxlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWxlICE9PSBudWxsICYmXG4gICAgICAgICgnZGF0YScgaW4gZmlsZSB8fCAncmFuZ2UnIGluIGZpbGUgfHwgJ3VybCcgaW4gZmlsZSkpO1xufVxuLyoqXG4gKiBMb2FkcyBhIGRvY3VtZW50IHBhc3NlZCB1c2luZyBgZmlsZWAgcHJvcC5cbiAqL1xuY29uc3QgRG9jdW1lbnQgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIERvY3VtZW50KF9hLCByZWYpIHtcbiAgICB2YXIgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBlcnJvciA9ICdGYWlsZWQgdG8gbG9hZCBQREYgZmlsZS4nLCBleHRlcm5hbExpbmtSZWwsIGV4dGVybmFsTGlua1RhcmdldCwgZmlsZSwgaW5wdXRSZWYsIGltYWdlUmVzb3VyY2VzUGF0aCwgbG9hZGluZyA9ICdMb2FkaW5nIFBERuKApicsIG5vRGF0YSA9ICdObyBQREYgZmlsZSBzcGVjaWZpZWQuJywgb25JdGVtQ2xpY2ssIG9uTG9hZEVycm9yOiBvbkxvYWRFcnJvclByb3BzLCBvbkxvYWRQcm9ncmVzcywgb25Mb2FkU3VjY2Vzczogb25Mb2FkU3VjY2Vzc1Byb3BzLCBvblBhc3N3b3JkID0gZGVmYXVsdE9uUGFzc3dvcmQsIG9uU291cmNlRXJyb3I6IG9uU291cmNlRXJyb3JQcm9wcywgb25Tb3VyY2VTdWNjZXNzOiBvblNvdXJjZVN1Y2Nlc3NQcm9wcywgb3B0aW9ucywgcmVuZGVyTW9kZSwgcm90YXRlIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJlcnJvclwiLCBcImV4dGVybmFsTGlua1JlbFwiLCBcImV4dGVybmFsTGlua1RhcmdldFwiLCBcImZpbGVcIiwgXCJpbnB1dFJlZlwiLCBcImltYWdlUmVzb3VyY2VzUGF0aFwiLCBcImxvYWRpbmdcIiwgXCJub0RhdGFcIiwgXCJvbkl0ZW1DbGlja1wiLCBcIm9uTG9hZEVycm9yXCIsIFwib25Mb2FkUHJvZ3Jlc3NcIiwgXCJvbkxvYWRTdWNjZXNzXCIsIFwib25QYXNzd29yZFwiLCBcIm9uU291cmNlRXJyb3JcIiwgXCJvblNvdXJjZVN1Y2Nlc3NcIiwgXCJvcHRpb25zXCIsIFwicmVuZGVyTW9kZVwiLCBcInJvdGF0ZVwiXSk7XG4gICAgY29uc3QgW3NvdXJjZVN0YXRlLCBzb3VyY2VEaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHNvdXJjZSwgZXJyb3I6IHNvdXJjZUVycm9yIH0gPSBzb3VyY2VTdGF0ZTtcbiAgICBjb25zdCBbcGRmU3RhdGUsIHBkZkRpc3BhdGNoXSA9IHVzZVJlc29sdmVyKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogcGRmLCBlcnJvcjogcGRmRXJyb3IgfSA9IHBkZlN0YXRlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gdXNlUmVmKG5ldyBMaW5rU2VydmljZSgpKTtcbiAgICBjb25zdCBwYWdlcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgcHJldkZpbGUgPSB1c2VSZWYoKTtcbiAgICBjb25zdCBwcmV2T3B0aW9ucyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChmaWxlICYmIGZpbGUgIT09IHByZXZGaWxlLmN1cnJlbnQgJiYgaXNQYXJhbWV0ZXJPYmplY3QoZmlsZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoIWRlcXVhbChmaWxlLCBwcmV2RmlsZS5jdXJyZW50KSwgYEZpbGUgcHJvcCBwYXNzZWQgdG8gPERvY3VtZW50IC8+IGNoYW5nZWQsIGJ1dCBpdCdzIGVxdWFsIHRvIHByZXZpb3VzIG9uZS4gVGhpcyBtaWdodCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgcmVsb2Fkcy4gQ29uc2lkZXIgbWVtb2l6aW5nIHRoZSB2YWx1ZSBwYXNzZWQgdG8gXCJmaWxlXCIgcHJvcC5gKTtcbiAgICAgICAgICAgIHByZXZGaWxlLmN1cnJlbnQgPSBmaWxlO1xuICAgICAgICB9XG4gICAgfSwgW2ZpbGVdKTtcbiAgICAvLyBEZXRlY3Qgbm9uLW1lbW9pemVkIGNoYW5nZXMgaW4gb3B0aW9ucyBwcm9wXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucyAhPT0gcHJldk9wdGlvbnMuY3VycmVudCkge1xuICAgICAgICAgICAgd2FybmluZyghZGVxdWFsKG9wdGlvbnMsIHByZXZPcHRpb25zLmN1cnJlbnQpLCBgT3B0aW9ucyBwcm9wIHBhc3NlZCB0byA8RG9jdW1lbnQgLz4gY2hhbmdlZCwgYnV0IGl0J3MgZXF1YWwgdG8gcHJldmlvdXMgb25lLiBUaGlzIG1pZ2h0IHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSByZWxvYWRzLiBDb25zaWRlciBtZW1vaXppbmcgdGhlIHZhbHVlIHBhc3NlZCB0byBcIm9wdGlvbnNcIiBwcm9wLmApO1xuICAgICAgICAgICAgcHJldk9wdGlvbnMuY3VycmVudCA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9LCBbb3B0aW9uc10pO1xuICAgIGNvbnN0IHZpZXdlciA9IHVzZVJlZih7XG4gICAgICAgIC8vIEhhbmRsaW5nIGp1bXBpbmcgdG8gaW50ZXJuYWwgbGlua3MgdGFyZ2V0XG4gICAgICAgIHNjcm9sbFBhZ2VJbnRvVmlldzogKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVzdCwgcGFnZU51bWJlciwgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEgfSA9IGFyZ3M7XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgY3VzdG9tIGhhbmRsaW5nIG9mIG9uSXRlbUNsaWNrIHdhcyBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKG9uSXRlbUNsaWNrKSB7XG4gICAgICAgICAgICAgICAgb25JdGVtQ2xpY2soeyBkZXN0LCBwYWdlSW5kZXgsIHBhZ2VOdW1iZXIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm90LCB0cnkgdG8gbG9vayBmb3IgdGFyZ2V0IHBhZ2Ugd2l0aGluIHRoZSA8RG9jdW1lbnQ+LlxuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhZ2VzLmN1cnJlbnRbcGFnZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIHRoZSBwYWdlIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICBwYWdlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgYEFuIGludGVybmFsIGxpbmsgbGVhZGluZyB0byBwYWdlICR7cGFnZU51bWJlcn0gd2FzIGNsaWNrZWQsIGJ1dCBuZWl0aGVyIDxEb2N1bWVudD4gd2FzIHByb3ZpZGVkIHdpdGggb25JdGVtQ2xpY2sgbm9yIGl0IHdhcyBhYmxlIHRvIGZpbmQgdGhlIHBhZ2Ugd2l0aGluIGl0c2VsZi4gRWl0aGVyIHByb3ZpZGUgb25JdGVtQ2xpY2sgdG8gPERvY3VtZW50PiBhbmQgaGFuZGxlIG5hdmlnYXRpbmcgYnkgeW91cnNlbGYgb3IgZW5zdXJlIHRoYXQgYWxsIHBhZ2VzIGFyZSByZW5kZXJlZCB3aXRoaW4gPERvY3VtZW50Pi5gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICAgICAgbGlua1NlcnZpY2UsXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICB2aWV3ZXIsXG4gICAgfSksIFtdKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IHNvdXJjZSBpcyByZXNvbHZlZCBjb3JyZWN0bHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblNvdXJjZVN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmIChvblNvdXJjZVN1Y2Nlc3NQcm9wcykge1xuICAgICAgICAgICAgb25Tb3VyY2VTdWNjZXNzUHJvcHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IHNvdXJjZSBmYWlsZWQgdG8gYmUgcmVzb2x2ZWQgY29ycmVjdGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Tb3VyY2VFcnJvcigpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBzb3VyY2VFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uU291cmNlRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25Tb3VyY2VFcnJvclByb3BzKHNvdXJjZUVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldFNvdXJjZSgpIHtcbiAgICAgICAgc291cmNlRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVzZXRTb3VyY2UsIFtmaWxlLCBzb3VyY2VEaXNwYXRjaF0pO1xuICAgIGNvbnN0IGZpbmREb2N1bWVudFNvdXJjZSA9IHVzZUNhbGxiYWNrKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWxlIGlzIGEgc3RyaW5nXG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChpc0RhdGFVUkkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQnl0ZVN0cmluZyA9IGRhdGFVUkl0b0J5dGVTdHJpbmcoZmlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmlsZUJ5dGVTdHJpbmcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlDT1JTV2FybmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBmaWxlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsZSBpcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnRcbiAgICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBmaWxlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsZSBpcyBhbiBBcnJheUJ1ZmZlclxuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmlsZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FzZXMgYmVsb3cgYXJlIGJyb3dzZXItb25seS5cbiAgICAgICAgICogSWYgeW91J3JlIHJ1bm5pbmcgb24gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCwgdGhlc2UgY2FzZXMgd2lsbCBiZSBvZiBubyB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAvLyBGaWxlIGlzIGEgQmxvYlxuICAgICAgICAgICAgaWYgKGlzQmxvYihmaWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBsb2FkRnJvbUZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGZpbGUgbXVzdCBiZSBhbiBvYmplY3RcbiAgICAgICAgaW52YXJpYW50KHR5cGVvZiBmaWxlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcGFyYW1ldGVyIGluIGZpbGUsIG5lZWQgZWl0aGVyIFVpbnQ4QXJyYXksIHN0cmluZyBvciBhIHBhcmFtZXRlciBvYmplY3QnKTtcbiAgICAgICAgaW52YXJpYW50KGlzUGFyYW1ldGVyT2JqZWN0KGZpbGUpLCAnSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmwnKTtcbiAgICAgICAgLy8gRmlsZSAudXJsIGlzIGEgc3RyaW5nXG4gICAgICAgIGlmICgndXJsJyBpbiBmaWxlICYmIHR5cGVvZiBmaWxlLnVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChpc0RhdGFVUkkoZmlsZS51cmwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgfSA9IGZpbGUsIG90aGVyUGFyYW1zID0gX19yZXN0KGZpbGUsIFtcInVybFwiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJ5dGVTdHJpbmcgPSBkYXRhVVJJdG9CeXRlU3RyaW5nKHVybCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBkYXRhOiBmaWxlQnl0ZVN0cmluZyB9LCBvdGhlclBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5Q09SU1dhcm5pbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9KSwgW2ZpbGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9IG1ha2VDYW5jZWxsYWJsZShmaW5kRG9jdW1lbnRTb3VyY2UoKSk7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0U291cmNlKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRTb3VyY2UgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxSdW5uaW5nVGFzayhjYW5jZWxsYWJsZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2ZpbmREb2N1bWVudFNvdXJjZSwgc291cmNlRGlzcGF0Y2hdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Tb3VyY2VFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uU291cmNlU3VjY2VzcygpO1xuICAgIH0sIFxuICAgIC8vIE9tbWl0dGVkIGNhbGxiYWNrcyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhleSBjaGFuZ2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW3NvdXJjZV0pO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgZG9jdW1lbnQgaXMgcmVhZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRTdWNjZXNzKCkge1xuICAgICAgICBpZiAoIXBkZikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvbkxvYWRTdWNjZXNzUHJvcHMocGRmKTtcbiAgICAgICAgfVxuICAgICAgICBwYWdlcy5jdXJyZW50ID0gbmV3IEFycmF5KHBkZi5udW1QYWdlcyk7XG4gICAgICAgIGxpbmtTZXJ2aWNlLmN1cnJlbnQuc2V0RG9jdW1lbnQocGRmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBkb2N1bWVudCBmYWlsZWQgdG8gcmVhZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRFcnJvcigpIHtcbiAgICAgICAgaWYgKCFwZGZFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBwZGZFcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uTG9hZEVycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uTG9hZEVycm9yUHJvcHMocGRmRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0RG9jdW1lbnQoKSB7XG4gICAgICAgIHBkZkRpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KHJlc2V0RG9jdW1lbnQsIFtwZGZEaXNwYXRjaCwgc291cmNlXSk7XG4gICAgZnVuY3Rpb24gbG9hZERvY3VtZW50KCkge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SW5pdFBhcmFtcyA9IG9wdGlvbnNcbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UpLCBvcHRpb25zKSA6IHNvdXJjZTtcbiAgICAgICAgY29uc3QgZGVzdHJveWFibGUgPSBwZGZqcy5nZXREb2N1bWVudChkb2N1bWVudEluaXRQYXJhbXMpO1xuICAgICAgICBpZiAob25Mb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lhYmxlLm9uUHJvZ3Jlc3MgPSBvbkxvYWRQcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYXNzd29yZCkge1xuICAgICAgICAgICAgZGVzdHJveWFibGUub25QYXNzd29yZCA9IG9uUGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZGluZ1Rhc2sgPSBkZXN0cm95YWJsZTtcbiAgICAgICAgbG9hZGluZ1Rhc2sucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG5leHRQZGYpID0+IHtcbiAgICAgICAgICAgIHBkZkRpc3BhdGNoKHsgdHlwZTogJ1JFU09MVkUnLCB2YWx1ZTogbmV4dFBkZiB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChsb2FkaW5nVGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZGZEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHVzZUVmZmVjdChsb2FkRG9jdW1lbnQsIFxuICAgIC8vIE9tbWl0dGVkIGNhbGxiYWNrcyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhleSBjaGFuZ2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW29wdGlvbnMsIHBkZkRpc3BhdGNoLCBzb3VyY2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBkZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWRTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcGRmXSk7XG4gICAgZnVuY3Rpb24gc2V0dXBMaW5rU2VydmljZSgpIHtcbiAgICAgICAgbGlua1NlcnZpY2UuY3VycmVudC5zZXRWaWV3ZXIodmlld2VyLmN1cnJlbnQpO1xuICAgICAgICBsaW5rU2VydmljZS5jdXJyZW50LnNldEV4dGVybmFsTGlua1JlbChleHRlcm5hbExpbmtSZWwpO1xuICAgICAgICBsaW5rU2VydmljZS5jdXJyZW50LnNldEV4dGVybmFsTGlua1RhcmdldChleHRlcm5hbExpbmtUYXJnZXQpO1xuICAgIH1cbiAgICB1c2VFZmZlY3Qoc2V0dXBMaW5rU2VydmljZSwgW2V4dGVybmFsTGlua1JlbCwgZXh0ZXJuYWxMaW5rVGFyZ2V0XSk7XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJQYWdlKHBhZ2VJbmRleCwgcmVmKSB7XG4gICAgICAgIHBhZ2VzLmN1cnJlbnRbcGFnZUluZGV4XSA9IHJlZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5yZWdpc3RlclBhZ2UocGFnZUluZGV4KSB7XG4gICAgICAgIGRlbGV0ZSBwYWdlcy5jdXJyZW50W3BhZ2VJbmRleF07XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoLFxuICAgICAgICBsaW5rU2VydmljZTogbGlua1NlcnZpY2UuY3VycmVudCxcbiAgICAgICAgb25JdGVtQ2xpY2ssXG4gICAgICAgIHBkZixcbiAgICAgICAgcmVnaXN0ZXJQYWdlLFxuICAgICAgICByZW5kZXJNb2RlLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHVucmVnaXN0ZXJQYWdlLFxuICAgIH0pLCBbaW1hZ2VSZXNvdXJjZXNQYXRoLCBvbkl0ZW1DbGljaywgcGRmLCByZW5kZXJNb2RlLCByb3RhdGVdKTtcbiAgICBjb25zdCBldmVudFByb3BzID0gdXNlTWVtbygoKSA9PiBtYWtlRXZlbnRQcm9wcyhvdGhlclByb3BzLCAoKSA9PiBwZGYpLCBbb3RoZXJQcm9wcywgcGRmXSk7XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERvY3VtZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2hpbGRDb250ZXh0IH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZXNzYWdlLCB7IHR5cGU6IFwibm8tZGF0YVwiIH0sIHR5cGVvZiBub0RhdGEgPT09ICdmdW5jdGlvbicgPyBub0RhdGEoKSA6IG5vRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBkZiA9PT0gdW5kZWZpbmVkIHx8IHBkZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2UsIHsgdHlwZTogXCJsb2FkaW5nXCIgfSwgdHlwZW9mIGxvYWRpbmcgPT09ICdmdW5jdGlvbicgPyBsb2FkaW5nKCkgOiBsb2FkaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBkZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2UsIHsgdHlwZTogXCJlcnJvclwiIH0sIHR5cGVvZiBlcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGVycm9yKCkgOiBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlckNoaWxkcmVuKCk7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBjbHN4KCdyZWFjdC1wZGZfX0RvY3VtZW50JywgY2xhc3NOYW1lKSwgcmVmOiBpbnB1dFJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIFsnLS1zY2FsZS1mYWN0b3InXTogJzEnLFxuICAgICAgICB9IH0sIGV2ZW50UHJvcHMpLCByZW5kZXJDb250ZW50KCkpKTtcbn0pO1xuY29uc3QgaXNGdW5jdGlvbk9yTm9kZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pO1xuRG9jdW1lbnQucHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFByb3BzKSwgeyBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsIGNsYXNzTmFtZTogaXNDbGFzc05hbWUsIGVycm9yOiBpc0Z1bmN0aW9uT3JOb2RlLCBleHRlcm5hbExpbmtSZWw6IFByb3BUeXBlcy5zdHJpbmcsIGV4dGVybmFsTGlua1RhcmdldDogUHJvcFR5cGVzLm9uZU9mKFsnX3NlbGYnLCAnX2JsYW5rJywgJ19wYXJlbnQnLCAnX3RvcCddKSwgZmlsZTogaXNGaWxlLCBpbWFnZVJlc291cmNlc1BhdGg6IFByb3BUeXBlcy5zdHJpbmcsIGlucHV0UmVmOiBpc1JlZiwgbG9hZGluZzogaXNGdW5jdGlvbk9yTm9kZSwgbm9EYXRhOiBpc0Z1bmN0aW9uT3JOb2RlLCBvbkl0ZW1DbGljazogUHJvcFR5cGVzLmZ1bmMsIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYywgb25Mb2FkUHJvZ3Jlc3M6IFByb3BUeXBlcy5mdW5jLCBvbkxvYWRTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYywgb25QYXNzd29yZDogUHJvcFR5cGVzLmZ1bmMsIG9uU291cmNlRXJyb3I6IFByb3BUeXBlcy5mdW5jLCBvblNvdXJjZVN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLCBvcHRpb25zOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBjYW52YXNGYWN0b3J5OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjYW52YXNNYXhBcmVhSW5CeXRlczogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgY01hcFBhY2tlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIENNYXBSZWFkZXJGYWN0b3J5OiBQcm9wVHlwZXMuYW55LFxuICAgICAgICBjTWFwVXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBkaXNhYmxlQXV0b0ZldGNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZGlzYWJsZVN0cmVhbTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGRvY0Jhc2VVcmw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGVuYWJsZVhmYTogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGZpbHRlckZhY3Rvcnk6IFByb3BUeXBlcy5hbnksXG4gICAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBodHRwSGVhZGVyczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBsZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIG1heEltYWdlU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgb3duZXJEb2N1bWVudDogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgcGFzc3dvcmQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHBkZkJ1ZzogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTogUHJvcFR5cGVzLmFueSxcbiAgICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgc3RvcEF0RXJyb3JzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgdXNlU3lzdGVtRm9udHM6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICB1c2VXb3JrZXJGZXRjaDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIHZlcmJvc2l0eTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgd29ya2VyOiBQcm9wVHlwZXMuYW55LFxuICAgIH0pLCByb3RhdGU6IFByb3BUeXBlcy5udW1iZXIgfSk7XG5leHBvcnQgZGVmYXVsdCBEb2N1bWVudDtcbiJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX3Jlc3QiLCJzIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiUmVhY3QiLCJmb3J3YXJkUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsInVzZVJlZiIsIlByb3BUeXBlcyIsIm1ha2VFdmVudFByb3BzIiwibWFrZUNhbmNlbGxhYmxlIiwiY2xzeCIsImludmFyaWFudCIsIndhcm5pbmciLCJkZXF1YWwiLCJwZGZqcyIsIkRvY3VtZW50Q29udGV4dCIsIk1lc3NhZ2UiLCJMaW5rU2VydmljZSIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJkYXRhVVJJdG9CeXRlU3RyaW5nIiwiZGlzcGxheUNPUlNXYXJuaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzQmxvYiIsImlzQnJvd3NlciIsImlzRGF0YVVSSSIsImxvYWRGcm9tRmlsZSIsInVzZVJlc29sdmVyIiwiZXZlbnRQcm9wcyIsImlzQ2xhc3NOYW1lIiwiaXNGaWxlIiwiaXNSZWYiLCJQREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJkZWZhdWx0T25QYXNzd29yZCIsImNhbGxiYWNrIiwicmVhc29uIiwiTkVFRF9QQVNTV09SRCIsInBhc3N3b3JkIiwicHJvbXB0IiwiSU5DT1JSRUNUX1BBU1NXT1JEIiwiaXNQYXJhbWV0ZXJPYmplY3QiLCJmaWxlIiwiRG9jdW1lbnQiLCJfYSIsInJlZiIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiZXJyb3IiLCJleHRlcm5hbExpbmtSZWwiLCJleHRlcm5hbExpbmtUYXJnZXQiLCJpbnB1dFJlZiIsImltYWdlUmVzb3VyY2VzUGF0aCIsImxvYWRpbmciLCJub0RhdGEiLCJvbkl0ZW1DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkRXJyb3JQcm9wcyIsIm9uTG9hZFByb2dyZXNzIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZFN1Y2Nlc3NQcm9wcyIsIm9uUGFzc3dvcmQiLCJvblNvdXJjZUVycm9yIiwib25Tb3VyY2VFcnJvclByb3BzIiwib25Tb3VyY2VTdWNjZXNzIiwib25Tb3VyY2VTdWNjZXNzUHJvcHMiLCJvcHRpb25zIiwicmVuZGVyTW9kZSIsInJvdGF0ZSIsIm90aGVyUHJvcHMiLCJzb3VyY2VTdGF0ZSIsInNvdXJjZURpc3BhdGNoIiwic291cmNlIiwic291cmNlRXJyb3IiLCJwZGZTdGF0ZSIsInBkZkRpc3BhdGNoIiwicGRmIiwicGRmRXJyb3IiLCJsaW5rU2VydmljZSIsInBhZ2VzIiwicHJldkZpbGUiLCJwcmV2T3B0aW9ucyIsImN1cnJlbnQiLCJ2aWV3ZXIiLCJzY3JvbGxQYWdlSW50b1ZpZXciLCJhcmdzIiwiZGVzdCIsInBhZ2VOdW1iZXIiLCJwYWdlSW5kZXgiLCJwYWdlIiwic2Nyb2xsSW50b1ZpZXciLCJ0b1N0cmluZyIsInJlc2V0U291cmNlIiwidHlwZSIsImZpbmREb2N1bWVudFNvdXJjZSIsImZpbGVCeXRlU3RyaW5nIiwiZGF0YSIsInVybCIsInJhbmdlIiwib3RoZXJQYXJhbXMiLCJhc3NpZ24iLCJjYW5jZWxsYWJsZSIsInByb21pc2UiLCJuZXh0U291cmNlIiwiY2F0Y2giLCJBcnJheSIsIm51bVBhZ2VzIiwic2V0RG9jdW1lbnQiLCJyZXNldERvY3VtZW50IiwibG9hZERvY3VtZW50IiwiZG9jdW1lbnRJbml0UGFyYW1zIiwiZGVzdHJveWFibGUiLCJnZXREb2N1bWVudCIsIm9uUHJvZ3Jlc3MiLCJsb2FkaW5nVGFzayIsIm5leHRQZGYiLCJkZXN0cm95ZWQiLCJkZXN0cm95Iiwic2V0dXBMaW5rU2VydmljZSIsInNldFZpZXdlciIsInNldEV4dGVybmFsTGlua1JlbCIsInNldEV4dGVybmFsTGlua1RhcmdldCIsInJlZ2lzdGVyUGFnZSIsInVucmVnaXN0ZXJQYWdlIiwiY2hpbGRDb250ZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJyZW5kZXJDb250ZW50IiwidW5kZWZpbmVkIiwic3R5bGUiLCJpc0Z1bmN0aW9uT3JOb2RlIiwib25lT2ZUeXBlIiwiZnVuYyIsIm5vZGUiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJvbmVPZiIsInNoYXBlIiwiY2FudmFzRmFjdG9yeSIsImFueSIsImNhbnZhc01heEFyZWFJbkJ5dGVzIiwibnVtYmVyIiwiY01hcFBhY2tlZCIsImJvb2wiLCJDTWFwUmVhZGVyRmFjdG9yeSIsImNNYXBVcmwiLCJkaXNhYmxlQXV0b0ZldGNoIiwiZGlzYWJsZUZvbnRGYWNlIiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImRvY0Jhc2VVcmwiLCJlbmFibGVYZmEiLCJmaWx0ZXJGYWN0b3J5IiwiZm9udEV4dHJhUHJvcGVydGllcyIsImh0dHBIZWFkZXJzIiwib2JqZWN0IiwiaXNFdmFsU3VwcG9ydGVkIiwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJtYXhJbWFnZVNpemUiLCJvd25lckRvY3VtZW50IiwicGRmQnVnIiwicmFuZ2VDaHVua1NpemUiLCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJzdG9wQXRFcnJvcnMiLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwidmVyYm9zaXR5Iiwid2l0aENyZWRlbnRpYWxzIiwid29ya2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Document.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/DocumentContext.js":
/*!************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/DocumentContext.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL0RvY3VtZW50Q29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs2REFDc0M7QUFDdEMsOEVBQWVBLG9EQUFhQSxDQUFDLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9Eb2N1bWVudENvbnRleHQuanM/MTAzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQ29udGV4dChudWxsKTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/DocumentContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/LinkService.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/LinkService.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LinkService)\n/* harmony export */ });\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ \nconst DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\nclass LinkService {\n    constructor(){\n        this.externalLinkEnabled = true;\n        this.externalLinkRel = undefined;\n        this.externalLinkTarget = undefined;\n        this.isInPresentationMode = false;\n        this.pdfDocument = undefined;\n        this.pdfViewer = undefined;\n    }\n    setDocument(pdfDocument) {\n        this.pdfDocument = pdfDocument;\n    }\n    setViewer(pdfViewer) {\n        this.pdfViewer = pdfViewer;\n    }\n    setExternalLinkRel(externalLinkRel) {\n        this.externalLinkRel = externalLinkRel;\n    }\n    setExternalLinkTarget(externalLinkTarget) {\n        this.externalLinkTarget = externalLinkTarget;\n    }\n    setHistory() {\n    // Intentionally empty\n    }\n    get pagesCount() {\n        return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n    get page() {\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfViewer, \"PDF viewer is not initialized.\");\n        return this.pdfViewer.currentPageNumber || 0;\n    }\n    set page(value) {\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfViewer, \"PDF viewer is not initialized.\");\n        this.pdfViewer.currentPageNumber = value;\n    }\n    // eslint-disable-next-line @typescript-eslint/class-literal-property-style\n    get rotation() {\n        return 0;\n    }\n    set rotation(value) {\n    // Intentionally empty\n    }\n    goToDestination(dest) {\n        return new Promise((resolve)=>{\n            (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfDocument, \"PDF document not loaded.\");\n            (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(dest, \"Destination is not specified.\");\n            if (typeof dest === \"string\") {\n                this.pdfDocument.getDestination(dest).then(resolve);\n            } else if (Array.isArray(dest)) {\n                resolve(dest);\n            } else {\n                dest.then(resolve);\n            }\n        }).then((explicitDest)=>{\n            (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(Array.isArray(explicitDest), `\"${explicitDest}\" is not a valid destination array.`);\n            const destRef = explicitDest[0];\n            new Promise((resolve)=>{\n                (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfDocument, \"PDF document not loaded.\");\n                if (destRef instanceof Object) {\n                    this.pdfDocument.getPageIndex(destRef).then((pageIndex)=>{\n                        resolve(pageIndex);\n                    }).catch(()=>{\n                        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(false, `\"${destRef}\" is not a valid page reference.`);\n                    });\n                } else if (typeof destRef === \"number\") {\n                    resolve(destRef);\n                } else {\n                    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(false, `\"${destRef}\" is not a valid destination reference.`);\n                }\n            }).then((pageIndex)=>{\n                const pageNumber = pageIndex + 1;\n                (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfViewer, \"PDF viewer is not initialized.\");\n                (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pageNumber >= 1 && pageNumber <= this.pagesCount, `\"${pageNumber}\" is not a valid page number.`);\n                this.pdfViewer.scrollPageIntoView({\n                    dest: explicitDest,\n                    pageIndex,\n                    pageNumber\n                });\n            });\n        });\n    }\n    navigateTo(dest) {\n        this.goToDestination(dest);\n    }\n    goToPage(pageNumber) {\n        const pageIndex = pageNumber - 1;\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.pdfViewer, \"PDF viewer is not initialized.\");\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(pageNumber >= 1 && pageNumber <= this.pagesCount, `\"${pageNumber}\" is not a valid page number.`);\n        this.pdfViewer.scrollPageIntoView({\n            pageIndex,\n            pageNumber\n        });\n    }\n    addLinkAttributes(link, url, newWindow) {\n        link.href = url;\n        link.rel = this.externalLinkRel || DEFAULT_LINK_REL;\n        link.target = newWindow ? \"_blank\" : this.externalLinkTarget || \"\";\n    }\n    getDestinationHash() {\n        return \"#\";\n    }\n    getAnchorUrl() {\n        return \"#\";\n    }\n    setHash() {\n    // Intentionally empty\n    }\n    executeNamedAction() {\n    // Intentionally empty\n    }\n    cachePageRef() {\n    // Intentionally empty\n    }\n    isPageVisible() {\n        return true;\n    }\n    isPageCached() {\n        return true;\n    }\n    executeSetOCGState() {\n    // Intentionally empty\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL0xpbmtTZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNzQztBQUN2QyxNQUFNQyxtQkFBbUI7QUFDVixNQUFNQztJQUNqQkMsYUFBYztRQUNWLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7UUFDM0IsSUFBSSxDQUFDQyxlQUFlLEdBQUdDO1FBQ3ZCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdEO1FBQzFCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxXQUFXLEdBQUdIO1FBQ25CLElBQUksQ0FBQ0ksU0FBUyxHQUFHSjtJQUNyQjtJQUNBSyxZQUFZRixXQUFXLEVBQUU7UUFDckIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3ZCO0lBQ0FHLFVBQVVGLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQUcsbUJBQW1CUixlQUFlLEVBQUU7UUFDaEMsSUFBSSxDQUFDQSxlQUFlLEdBQUdBO0lBQzNCO0lBQ0FTLHNCQUFzQlAsa0JBQWtCLEVBQUU7UUFDdEMsSUFBSSxDQUFDQSxrQkFBa0IsR0FBR0E7SUFDOUI7SUFDQVEsYUFBYTtJQUNULHNCQUFzQjtJQUMxQjtJQUNBLElBQUlDLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ1AsV0FBVyxHQUFHLElBQUksQ0FBQ0EsV0FBVyxDQUFDUSxRQUFRLEdBQUc7SUFDMUQ7SUFDQSxJQUFJQyxPQUFPO1FBQ1BsQiwwREFBU0EsQ0FBQyxJQUFJLENBQUNVLFNBQVMsRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQ0EsU0FBUyxDQUFDUyxpQkFBaUIsSUFBSTtJQUMvQztJQUNBLElBQUlELEtBQUtFLEtBQUssRUFBRTtRQUNacEIsMERBQVNBLENBQUMsSUFBSSxDQUFDVSxTQUFTLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxTQUFTLENBQUNTLGlCQUFpQixHQUFH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c0JBQXNCO0lBQzFCO0lBQ0FDLGdCQUFnQjtRQUNaLE9BQU87SUFDWDtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLHFCQUFxQjtJQUNqQixzQkFBc0I7SUFDMUI7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9MaW5rU2VydmljZS5qcz8yN2UwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAyMDE1IE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5jb25zdCBERUZBVUxUX0xJTktfUkVMID0gJ25vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3cnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV4dGVybmFsTGlua0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmV4dGVybmFsTGlua1JlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5leHRlcm5hbExpbmtUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZGZEb2N1bWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZGZWaWV3ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldERvY3VtZW50KHBkZkRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMucGRmRG9jdW1lbnQgPSBwZGZEb2N1bWVudDtcbiAgICB9XG4gICAgc2V0Vmlld2VyKHBkZlZpZXdlcikge1xuICAgICAgICB0aGlzLnBkZlZpZXdlciA9IHBkZlZpZXdlcjtcbiAgICB9XG4gICAgc2V0RXh0ZXJuYWxMaW5rUmVsKGV4dGVybmFsTGlua1JlbCkge1xuICAgICAgICB0aGlzLmV4dGVybmFsTGlua1JlbCA9IGV4dGVybmFsTGlua1JlbDtcbiAgICB9XG4gICAgc2V0RXh0ZXJuYWxMaW5rVGFyZ2V0KGV4dGVybmFsTGlua1RhcmdldCkge1xuICAgICAgICB0aGlzLmV4dGVybmFsTGlua1RhcmdldCA9IGV4dGVybmFsTGlua1RhcmdldDtcbiAgICB9XG4gICAgc2V0SGlzdG9yeSgpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICBnZXQgcGFnZXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGRmRG9jdW1lbnQgPyB0aGlzLnBkZkRvY3VtZW50Lm51bVBhZ2VzIDogMDtcbiAgICB9XG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLnBkZlZpZXdlciwgJ1BERiB2aWV3ZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5wZGZWaWV3ZXIuY3VycmVudFBhZ2VOdW1iZXIgfHwgMDtcbiAgICB9XG4gICAgc2V0IHBhZ2UodmFsdWUpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMucGRmVmlld2VyLCAnUERGIHZpZXdlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIHRoaXMucGRmVmlld2VyLmN1cnJlbnRQYWdlTnVtYmVyID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2xhc3MtbGl0ZXJhbC1wcm9wZXJ0eS1zdHlsZVxuICAgIGdldCByb3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIGdvVG9EZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaW52YXJpYW50KHRoaXMucGRmRG9jdW1lbnQsICdQREYgZG9jdW1lbnQgbm90IGxvYWRlZC4nKTtcbiAgICAgICAgICAgIGludmFyaWFudChkZXN0LCAnRGVzdGluYXRpb24gaXMgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBkZkRvY3VtZW50LmdldERlc3RpbmF0aW9uKGRlc3QpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3QudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoZXhwbGljaXREZXN0KSA9PiB7XG4gICAgICAgICAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShleHBsaWNpdERlc3QpLCBgXCIke2V4cGxpY2l0RGVzdH1cIiBpcyBub3QgYSB2YWxpZCBkZXN0aW5hdGlvbiBhcnJheS5gKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RSZWYgPSBleHBsaWNpdERlc3RbMF07XG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGludmFyaWFudCh0aGlzLnBkZkRvY3VtZW50LCAnUERGIGRvY3VtZW50IG5vdCBsb2FkZWQuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3RSZWYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZGZEb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFBhZ2VJbmRleChkZXN0UmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHBhZ2VJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYWdlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgYFwiJHtkZXN0UmVmfVwiIGlzIG5vdCBhIHZhbGlkIHBhZ2UgcmVmZXJlbmNlLmApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlc3RSZWYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdFJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsIGBcIiR7ZGVzdFJlZn1cIiBpcyBub3QgYSB2YWxpZCBkZXN0aW5hdGlvbiByZWZlcmVuY2UuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbigocGFnZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50KHRoaXMucGRmVmlld2VyLCAnUERGIHZpZXdlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50KHBhZ2VOdW1iZXIgPj0gMSAmJiBwYWdlTnVtYmVyIDw9IHRoaXMucGFnZXNDb3VudCwgYFwiJHtwYWdlTnVtYmVyfVwiIGlzIG5vdCBhIHZhbGlkIHBhZ2UgbnVtYmVyLmApO1xuICAgICAgICAgICAgICAgIHRoaXMucGRmVmlld2VyLnNjcm9sbFBhZ2VJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Q6IGV4cGxpY2l0RGVzdCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuYXZpZ2F0ZVRvKGRlc3QpIHtcbiAgICAgICAgdGhpcy5nb1RvRGVzdGluYXRpb24oZGVzdCk7XG4gICAgfVxuICAgIGdvVG9QYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gICAgICAgIGludmFyaWFudCh0aGlzLnBkZlZpZXdlciwgJ1BERiB2aWV3ZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgICBpbnZhcmlhbnQocGFnZU51bWJlciA+PSAxICYmIHBhZ2VOdW1iZXIgPD0gdGhpcy5wYWdlc0NvdW50LCBgXCIke3BhZ2VOdW1iZXJ9XCIgaXMgbm90IGEgdmFsaWQgcGFnZSBudW1iZXIuYCk7XG4gICAgICAgIHRoaXMucGRmVmlld2VyLnNjcm9sbFBhZ2VJbnRvVmlldyh7XG4gICAgICAgICAgICBwYWdlSW5kZXgsXG4gICAgICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGlua0F0dHJpYnV0ZXMobGluaywgdXJsLCBuZXdXaW5kb3cpIHtcbiAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICBsaW5rLnJlbCA9IHRoaXMuZXh0ZXJuYWxMaW5rUmVsIHx8IERFRkFVTFRfTElOS19SRUw7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gbmV3V2luZG93ID8gJ19ibGFuaycgOiB0aGlzLmV4dGVybmFsTGlua1RhcmdldCB8fCAnJztcbiAgICB9XG4gICAgZ2V0RGVzdGluYXRpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gJyMnO1xuICAgIH1cbiAgICBnZXRBbmNob3JVcmwoKSB7XG4gICAgICAgIHJldHVybiAnIyc7XG4gICAgfVxuICAgIHNldEhhc2goKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgZXhlY3V0ZU5hbWVkQWN0aW9uKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIGNhY2hlUGFnZVJlZigpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICBpc1BhZ2VWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNQYWdlQ2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZXhlY3V0ZVNldE9DR1N0YXRlKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImludmFyaWFudCIsIkRFRkFVTFRfTElOS19SRUwiLCJMaW5rU2VydmljZSIsImNvbnN0cnVjdG9yIiwiZXh0ZXJuYWxMaW5rRW5hYmxlZCIsImV4dGVybmFsTGlua1JlbCIsInVuZGVmaW5lZCIsImV4dGVybmFsTGlua1RhcmdldCIsImlzSW5QcmVzZW50YXRpb25Nb2RlIiwicGRmRG9jdW1lbnQiLCJwZGZWaWV3ZXIiLCJzZXREb2N1bWVudCIsInNldFZpZXdlciIsInNldEV4dGVybmFsTGlua1JlbCIsInNldEV4dGVybmFsTGlua1RhcmdldCIsInNldEhpc3RvcnkiLCJwYWdlc0NvdW50IiwibnVtUGFnZXMiLCJwYWdlIiwiY3VycmVudFBhZ2VOdW1iZXIiLCJ2YWx1ZSIsInJvdGF0aW9uIiwiZ29Ub0Rlc3RpbmF0aW9uIiwiZGVzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0RGVzdGluYXRpb24iLCJ0aGVuIiwiQXJyYXkiLCJpc0FycmF5IiwiZXhwbGljaXREZXN0IiwiZGVzdFJlZiIsIk9iamVjdCIsImdldFBhZ2VJbmRleCIsInBhZ2VJbmRleCIsImNhdGNoIiwicGFnZU51bWJlciIsInNjcm9sbFBhZ2VJbnRvVmlldyIsIm5hdmlnYXRlVG8iLCJnb1RvUGFnZSIsImFkZExpbmtBdHRyaWJ1dGVzIiwibGluayIsInVybCIsIm5ld1dpbmRvdyIsImhyZWYiLCJyZWwiLCJ0YXJnZXQiLCJnZXREZXN0aW5hdGlvbkhhc2giLCJnZXRBbmNob3JVcmwiLCJzZXRIYXNoIiwiZXhlY3V0ZU5hbWVkQWN0aW9uIiwiY2FjaGVQYWdlUmVmIiwiaXNQYWdlVmlzaWJsZSIsImlzUGFnZUNhY2hlZCIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/LinkService.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Message.js":
/*!****************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Message.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Message)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction Message({ children, type }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: `react-pdf__message react-pdf__message--${type}`\n    }, children);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL01lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDWCxTQUFTQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO0lBQzlDLHFCQUFPSCxnREFBbUIsQ0FBQyxPQUFPO1FBQUVLLFdBQVcsQ0FBQyx1Q0FBdUMsRUFBRUYsS0FBSyxDQUFDO0lBQUMsR0FBR0Q7QUFDdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vTWVzc2FnZS5qcz9kYzZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNZXNzYWdlKHsgY2hpbGRyZW4sIHR5cGUgfSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgcmVhY3QtcGRmX19tZXNzYWdlIHJlYWN0LXBkZl9fbWVzc2FnZS0tJHt0eXBlfWAgfSwgY2hpbGRyZW4pO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiTWVzc2FnZSIsImNoaWxkcmVuIiwidHlwZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Outline.js":
/*!****************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Outline.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var make_event_props__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! make-event-props */ \"(ssr)/./node_modules/make-event-props/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _OutlineContext_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./OutlineContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/OutlineContext.js\");\n/* harmony import */ var _OutlineItem_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./OutlineItem.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/OutlineItem.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* harmony import */ var _shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./shared/propTypes.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/propTypes.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Displays an outline (table of contents).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */ const Outline = function Outline(props) {\n    const documentContext = (0,_shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest(mergedProps, [\n        \"className\",\n        \"inputRef\",\n        \"onItemClick\",\n        \"onLoadError\",\n        \"onLoadSuccess\",\n        \"pdf\"\n    ]);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pdf, \"Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.\");\n    const [outlineState, outlineDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n    const { value: outline, error: outlineError } = outlineState;\n    /**\n     * Called when an outline is read successfully\n     */ function onLoadSuccess() {\n        if (typeof outline === \"undefined\" || outline === false) {\n            return;\n        }\n        if (onLoadSuccessProps) {\n            onLoadSuccessProps(outline);\n        }\n    }\n    /**\n     * Called when an outline failed to read successfully\n     */ function onLoadError() {\n        if (!outlineError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, outlineError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(outlineError);\n        }\n    }\n    function resetOutline() {\n        outlineDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetOutline, [\n        outlineDispatch,\n        pdf\n    ]);\n    function loadOutline() {\n        if (!pdf) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(pdf.getOutline());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextOutline)=>{\n            outlineDispatch({\n                type: \"RESOLVE\",\n                value: nextOutline\n            });\n        }).catch((error)=>{\n            outlineDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_7__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadOutline, [\n        outlineDispatch,\n        pdf\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (outline === undefined) {\n            return;\n        }\n        if (outline === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        outline\n    ]);\n    const childContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            onItemClick\n        }), [\n        onItemClick\n    ]);\n    const eventProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,make_event_props__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(otherProps, ()=>outline), [\n        otherProps,\n        outline\n    ]);\n    if (!outline) {\n        return null;\n    }\n    function renderOutline() {\n        if (!outline) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", null, outline.map((item, itemIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_OutlineItem_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                key: typeof item.dest === \"string\" ? item.dest : itemIndex,\n                item: item,\n                pdf: pdf\n            })));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"react-pdf__Outline\", className),\n        ref: inputRef\n    }, eventProps), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_OutlineContext_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].Provider, {\n        value: childContext\n    }, renderOutline()));\n};\nOutline.propTypes = Object.assign(Object.assign({}, _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_11__.eventProps), {\n    className: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_11__.isClassName,\n    inputRef: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_11__.isRef,\n    onItemClick: prop_types__WEBPACK_IMPORTED_MODULE_12__.func,\n    onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_12__.func,\n    onLoadSuccess: prop_types__WEBPACK_IMPORTED_MODULE_12__.func,\n    pdf: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_11__.isPdf\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Outline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL091dGxpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7NkRBQ0EsSUFBSUEsU0FBUyxTQUFLLElBQUksU0FBSSxDQUFDQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUNrRDtBQUNmO0FBQ29CO0FBQ1Q7QUFDdEI7QUFDZTtBQUNUO0FBQ21CO0FBQ047QUFDVztBQUNnQjtBQUNkO0FBQ3NCO0FBQzlFOzs7O0NBSUMsR0FDRCxNQUFNNkIsVUFBVSxTQUFTQSxRQUFRQyxLQUFLO0lBQ2xDLE1BQU1DLGtCQUFrQlIsK0VBQWtCQTtJQUMxQyxNQUFNUyxjQUFjOUIsT0FBTytCLE1BQU0sQ0FBQy9CLE9BQU8rQixNQUFNLENBQUMsQ0FB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QixNQUFNLENBQUMvQixPQUFPK0IsTUFBTSxDQUFDLENBQUMsR0FBR1IsNkRBQVVBLEdBQUc7SUFBRVMsV0FBV1IsOERBQVdBO0lBQUVTLFVBQVVQLHdEQUFLQTtJQUFFUSxhQUFhdEIsNkNBQWM7SUFBRXVCLGFBQWF2Qiw2Q0FBYztJQUFFeUIsZUFBZXpCLDZDQUFjO0lBQUUyQixLQUFLZCx3REFBS0E7QUFBQztBQUNoTixpRUFBZUUsT0FBT0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9PdXRsaW5lLmpzP2M3ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbWFrZUNhbmNlbGxhYmxlIGZyb20gJ21ha2UtY2FuY2VsbGFibGUtcHJvbWlzZSc7XG5pbXBvcnQgbWFrZUV2ZW50UHJvcHMgZnJvbSAnbWFrZS1ldmVudC1wcm9wcyc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgT3V0bGluZUNvbnRleHQgZnJvbSAnLi9PdXRsaW5lQ29udGV4dC5qcyc7XG5pbXBvcnQgT3V0bGluZUl0ZW0gZnJvbSAnLi9PdXRsaW5lSXRlbS5qcyc7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzayB9IGZyb20gJy4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB1c2VEb2N1bWVudENvbnRleHQgZnJvbSAnLi9zaGFyZWQvaG9va3MvdXNlRG9jdW1lbnRDb250ZXh0LmpzJztcbmltcG9ydCB1c2VSZXNvbHZlciBmcm9tICcuL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qcyc7XG5pbXBvcnQgeyBldmVudFByb3BzLCBpc0NsYXNzTmFtZSwgaXNQZGYsIGlzUmVmIH0gZnJvbSAnLi9zaGFyZWQvcHJvcFR5cGVzLmpzJztcbi8qKlxuICogRGlzcGxheXMgYW4gb3V0bGluZSAodGFibGUgb2YgY29udGVudHMpLlxuICpcbiAqIFNob3VsZCBiZSBwbGFjZWQgaW5zaWRlIGA8RG9jdW1lbnQgLz5gLiBBbHRlcm5hdGl2ZWx5LCBpdCBjYW4gaGF2ZSBgcGRmYCBwcm9wIHBhc3NlZCwgd2hpY2ggY2FuIGJlIG9idGFpbmVkIGZyb20gYDxEb2N1bWVudCAvPmAncyBgb25Mb2FkU3VjY2Vzc2AgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IE91dGxpbmUgPSBmdW5jdGlvbiBPdXRsaW5lKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gdXNlRG9jdW1lbnRDb250ZXh0KCk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgaW5wdXRSZWYsIG9uSXRlbUNsaWNrLCBvbkxvYWRFcnJvcjogb25Mb2FkRXJyb3JQcm9wcywgb25Mb2FkU3VjY2Vzczogb25Mb2FkU3VjY2Vzc1Byb3BzLCBwZGYgfSA9IG1lcmdlZFByb3BzLCBvdGhlclByb3BzID0gX19yZXN0KG1lcmdlZFByb3BzLCBbXCJjbGFzc05hbWVcIiwgXCJpbnB1dFJlZlwiLCBcIm9uSXRlbUNsaWNrXCIsIFwib25Mb2FkRXJyb3JcIiwgXCJvbkxvYWRTdWNjZXNzXCIsIFwicGRmXCJdKTtcbiAgICBpbnZhcmlhbnQocGRmLCAnQXR0ZW1wdGVkIHRvIGxvYWQgYW4gb3V0bGluZSwgYnV0IG5vIGRvY3VtZW50IHdhcyBzcGVjaWZpZWQuIFdyYXAgPE91dGxpbmUgLz4gaW4gYSA8RG9jdW1lbnQgLz4gb3IgcGFzcyBleHBsaWNpdCBgcGRmYCBwcm9wLicpO1xuICAgIGNvbnN0IFtvdXRsaW5lU3RhdGUsIG91dGxpbmVEaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IG91dGxpbmUsIGVycm9yOiBvdXRsaW5lRXJyb3IgfSA9IG91dGxpbmVTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhbiBvdXRsaW5lIGlzIHJlYWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Mb2FkU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvdXRsaW5lID09PSAndW5kZWZpbmVkJyB8fCBvdXRsaW5lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRTdWNjZXNzUHJvcHMpIHtcbiAgICAgICAgICAgIG9uTG9hZFN1Y2Nlc3NQcm9wcyhvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhbiBvdXRsaW5lIGZhaWxlZCB0byByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZEVycm9yKCkge1xuICAgICAgICBpZiAoIW91dGxpbmVFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBvdXRsaW5lRXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvbkxvYWRFcnJvclByb3BzKSB7XG4gICAgICAgICAgICBvbkxvYWRFcnJvclByb3BzKG91dGxpbmVFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRPdXRsaW5lKCkge1xuICAgICAgICBvdXRsaW5lRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVzZXRPdXRsaW5lLCBbb3V0bGluZURpc3BhdGNoLCBwZGZdKTtcbiAgICBmdW5jdGlvbiBsb2FkT3V0bGluZSgpIHtcbiAgICAgICAgaWYgKCFwZGYpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuY2VsbGFibGUgPSBtYWtlQ2FuY2VsbGFibGUocGRmLmdldE91dGxpbmUoKSk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0T3V0bGluZSkgPT4ge1xuICAgICAgICAgICAgb3V0bGluZURpc3BhdGNoKHsgdHlwZTogJ1JFU09MVkUnLCB2YWx1ZTogbmV4dE91dGxpbmUgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBvdXRsaW5lRGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUnVubmluZ1Rhc2socnVubmluZ1Rhc2spO1xuICAgIH1cbiAgICB1c2VFZmZlY3QobG9hZE91dGxpbmUsIFtvdXRsaW5lRGlzcGF0Y2gsIHBkZl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChvdXRsaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0bGluZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9uTG9hZEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25Mb2FkU3VjY2VzcygpO1xuICAgIH0sIFxuICAgIC8vIE9tbWl0dGVkIGNhbGxiYWNrcyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhleSBjaGFuZ2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW291dGxpbmVdKTtcbiAgICBjb25zdCBjaGlsZENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIG9uSXRlbUNsaWNrLFxuICAgIH0pLCBbb25JdGVtQ2xpY2tdKTtcbiAgICBjb25zdCBldmVudFByb3BzID0gdXNlTWVtbygoKSA9PiBtYWtlRXZlbnRQcm9wcyhvdGhlclByb3BzLCAoKSA9PiBvdXRsaW5lKSwgW290aGVyUHJvcHMsIG91dGxpbmVdKTtcbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck91dGxpbmUoKSB7XG4gICAgICAgIGlmICghb3V0bGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgb3V0bGluZS5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZUl0ZW0sIHsga2V5OiB0eXBlb2YgaXRlbS5kZXN0ID09PSAnc3RyaW5nJyA/IGl0ZW0uZGVzdCA6IGl0ZW1JbmRleCwgaXRlbTogaXRlbSwgcGRmOiBwZGYgfSkpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xzeCgncmVhY3QtcGRmX19PdXRsaW5lJywgY2xhc3NOYW1lKSwgcmVmOiBpbnB1dFJlZiB9LCBldmVudFByb3BzKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsaW5lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2hpbGRDb250ZXh0IH0sIHJlbmRlck91dGxpbmUoKSkpKTtcbn07XG5PdXRsaW5lLnByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRQcm9wcyksIHsgY2xhc3NOYW1lOiBpc0NsYXNzTmFtZSwgaW5wdXRSZWY6IGlzUmVmLCBvbkl0ZW1DbGljazogUHJvcFR5cGVzLmZ1bmMsIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYywgb25Mb2FkU3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsIHBkZjogaXNQZGYgfSk7XG5leHBvcnQgZGVmYXVsdCBPdXRsaW5lO1xuIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwiUHJvcFR5cGVzIiwibWFrZUNhbmNlbGxhYmxlIiwibWFrZUV2ZW50UHJvcHMiLCJjbHN4IiwiaW52YXJpYW50Iiwid2FybmluZyIsIk91dGxpbmVDb250ZXh0IiwiT3V0bGluZUl0ZW0iLCJjYW5jZWxSdW5uaW5nVGFzayIsInVzZURvY3VtZW50Q29udGV4dCIsInVzZVJlc29sdmVyIiwiZXZlbnRQcm9wcyIsImlzQ2xhc3NOYW1lIiwiaXNQZGYiLCJpc1JlZiIsIk91dGxpbmUiLCJwcm9wcyIsImRvY3VtZW50Q29udGV4dCIsIm1lcmdlZFByb3BzIiwiYXNzaWduIiwiY2xhc3NOYW1lIiwiaW5wdXRSZWYiLCJvbkl0ZW1DbGljayIsIm9uTG9hZEVycm9yIiwib25Mb2FkRXJyb3JQcm9wcyIsIm9uTG9hZFN1Y2Nlc3MiLCJvbkxvYWRTdWNjZXNzUHJvcHMiLCJwZGYiLCJvdGhlclByb3BzIiwib3V0bGluZVN0YXRlIiwib3V0bGluZURpc3BhdGNoIiwidmFsdWUiLCJvdXRsaW5lIiwiZXJyb3IiLCJvdXRsaW5lRXJyb3IiLCJ0b1N0cmluZyIsInJlc2V0T3V0bGluZSIsInR5cGUiLCJsb2FkT3V0bGluZSIsImNhbmNlbGxhYmxlIiwiZ2V0T3V0bGluZSIsInJ1bm5pbmdUYXNrIiwicHJvbWlzZSIsInRoZW4iLCJuZXh0T3V0bGluZSIsImNhdGNoIiwidW5kZWZpbmVkIiwiY2hpbGRDb250ZXh0IiwicmVuZGVyT3V0bGluZSIsImNyZWF0ZUVsZW1lbnQiLCJtYXAiLCJpdGVtIiwiaXRlbUluZGV4Iiwia2V5IiwiZGVzdCIsInJlZiIsIlByb3ZpZGVyIiwicHJvcFR5cGVzIiwiZnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Outline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/OutlineContext.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/OutlineContext.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL091dGxpbmVDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OzZEQUNzQztBQUN0Qyw4RUFBZUEsb0RBQWFBLENBQUMsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL091dGxpbmVDb250ZXh0LmpzPzFjMDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/OutlineContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/OutlineItem.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/OutlineItem.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OutlineItem)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _Ref_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Ref.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Ref.js\");\n/* harmony import */ var _shared_hooks_useCachedValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/hooks/useCachedValue.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useCachedValue.js\");\n/* harmony import */ var _shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\");\n/* harmony import */ var _shared_hooks_useOutlineContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/hooks/useOutlineContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useOutlineContext.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\nfunction OutlineItem(props) {\n    const documentContext = (0,_shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n    const outlineContext = (0,_shared_hooks_useOutlineContext_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(outlineContext, \"Unable to find Outline context.\");\n    const mergedProps = Object.assign(Object.assign(Object.assign({}, documentContext), outlineContext), props);\n    const { item, linkService, onItemClick, pdf } = mergedProps, otherProps = __rest(mergedProps, [\n        \"item\",\n        \"linkService\",\n        \"onItemClick\",\n        \"pdf\"\n    ]);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pdf, \"Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.\");\n    const getDestination = (0,_shared_hooks_useCachedValue_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(()=>{\n        if (typeof item.dest === \"string\") {\n            return pdf.getDestination(item.dest);\n        }\n        return item.dest;\n    });\n    const getPageIndex = (0,_shared_hooks_useCachedValue_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(()=>__awaiter(this, void 0, void 0, function*() {\n            const destination = yield getDestination();\n            if (!destination) {\n                throw new Error(\"Destination not found.\");\n            }\n            const [ref] = destination;\n            return pdf.getPageIndex(new _Ref_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](ref));\n        }));\n    const getPageNumber = (0,_shared_hooks_useCachedValue_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(()=>__awaiter(this, void 0, void 0, function*() {\n            const pageIndex = yield getPageIndex();\n            return pageIndex + 1;\n        }));\n    function onClick(event) {\n        event.preventDefault();\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(onItemClick || linkService, \"Either onItemClick callback or linkService must be defined in order to navigate to an outline item.\");\n        if (onItemClick) {\n            Promise.all([\n                getDestination(),\n                getPageIndex(),\n                getPageNumber()\n            ]).then(([dest, pageIndex, pageNumber])=>{\n                onItemClick({\n                    dest,\n                    pageIndex,\n                    pageNumber\n                });\n            });\n        } else if (linkService) {\n            linkService.goToDestination(item.dest);\n        }\n    }\n    function renderSubitems() {\n        if (!item.items || !item.items.length) {\n            return null;\n        }\n        const { items: subitems } = item;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", null, subitems.map((subitem, subitemIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutlineItem, Object.assign({\n                key: typeof subitem.dest === \"string\" ? subitem.dest : subitemIndex,\n                item: subitem,\n                pdf: pdf\n            }, otherProps))));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        href: \"#\",\n        onClick: onClick\n    }, item.title), renderSubitems());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL091dGxpbmVJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxTQUFTLFNBQUssSUFBSSxTQUFJLENBQUNBLE1BQU0sSUFBSyxTQUFVQyxDQUFDLEVBQUVQLENBQUM7SUFDaEQsSUFBSVEsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLRixFQUFHLElBQUlH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QixDQUFDLE1BQU0sTUFBTWlDLFNBQVNFLEdBQUcsQ0FBQyxDQUFDQyxTQUFTQyw2QkFBa0JyQyxnREFBbUIsQ0FBQ00sYUFBYWYsT0FBT29CLE1BQU0sQ0FBQztnQkFBRTJCLEtBQUssT0FBT0YsUUFBUWxCLElBQUksS0FBSyxXQUFXa0IsUUFBUWxCLElBQUksR0FBR21CO2dCQUFjekIsTUFBTXdCO2dCQUFTckIsS0FBS0E7WUFBSSxHQUFHQztJQUN0TztJQUNBLHFCQUFRaEIsZ0RBQW1CLENBQUMsTUFBTSxvQkFDOUJBLGdEQUFtQixDQUFDLEtBQUs7UUFBRXVDLE1BQU07UUFBS2QsU0FBU0E7SUFBUSxHQUFHYixLQUFLNEIsS0FBSyxHQUNwRVQ7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9PdXRsaW5lSXRlbS5qcz9jYThjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IFJlZiBmcm9tICcuL1JlZi5qcyc7XG5pbXBvcnQgdXNlQ2FjaGVkVmFsdWUgZnJvbSAnLi9zaGFyZWQvaG9va3MvdXNlQ2FjaGVkVmFsdWUuanMnO1xuaW1wb3J0IHVzZURvY3VtZW50Q29udGV4dCBmcm9tICcuL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanMnO1xuaW1wb3J0IHVzZU91dGxpbmVDb250ZXh0IGZyb20gJy4vc2hhcmVkL2hvb2tzL3VzZU91dGxpbmVDb250ZXh0LmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE91dGxpbmVJdGVtKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gdXNlRG9jdW1lbnRDb250ZXh0KCk7XG4gICAgY29uc3Qgb3V0bGluZUNvbnRleHQgPSB1c2VPdXRsaW5lQ29udGV4dCgpO1xuICAgIGludmFyaWFudChvdXRsaW5lQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIE91dGxpbmUgY29udGV4dC4nKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkb2N1bWVudENvbnRleHQpLCBvdXRsaW5lQ29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IGl0ZW0sIGxpbmtTZXJ2aWNlLCBvbkl0ZW1DbGljaywgcGRmIH0gPSBtZXJnZWRQcm9wcywgb3RoZXJQcm9wcyA9IF9fcmVzdChtZXJnZWRQcm9wcywgW1wiaXRlbVwiLCBcImxpbmtTZXJ2aWNlXCIsIFwib25JdGVtQ2xpY2tcIiwgXCJwZGZcIl0pO1xuICAgIGludmFyaWFudChwZGYsICdBdHRlbXB0ZWQgdG8gbG9hZCBhbiBvdXRsaW5lLCBidXQgbm8gZG9jdW1lbnQgd2FzIHNwZWNpZmllZC4gV3JhcCA8T3V0bGluZSAvPiBpbiBhIDxEb2N1bWVudCAvPiBvciBwYXNzIGV4cGxpY2l0IGBwZGZgIHByb3AuJyk7XG4gICAgY29uc3QgZ2V0RGVzdGluYXRpb24gPSB1c2VDYWNoZWRWYWx1ZSgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5kZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHBkZi5nZXREZXN0aW5hdGlvbihpdGVtLmRlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmRlc3Q7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0UGFnZUluZGV4ID0gdXNlQ2FjaGVkVmFsdWUoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHlpZWxkIGdldERlc3RpbmF0aW9uKCk7XG4gICAgICAgIGlmICghZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVzdGluYXRpb24gbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtyZWZdID0gZGVzdGluYXRpb247XG4gICAgICAgIHJldHVybiBwZGYuZ2V0UGFnZUluZGV4KG5ldyBSZWYocmVmKSk7XG4gICAgfSkpO1xuICAgIGNvbnN0IGdldFBhZ2VOdW1iZXIgPSB1c2VDYWNoZWRWYWx1ZSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IHlpZWxkIGdldFBhZ2VJbmRleCgpO1xuICAgICAgICByZXR1cm4gcGFnZUluZGV4ICsgMTtcbiAgICB9KSk7XG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpbnZhcmlhbnQob25JdGVtQ2xpY2sgfHwgbGlua1NlcnZpY2UsICdFaXRoZXIgb25JdGVtQ2xpY2sgY2FsbGJhY2sgb3IgbGlua1NlcnZpY2UgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIG5hdmlnYXRlIHRvIGFuIG91dGxpbmUgaXRlbS4nKTtcbiAgICAgICAgaWYgKG9uSXRlbUNsaWNrKSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChbZ2V0RGVzdGluYXRpb24oKSwgZ2V0UGFnZUluZGV4KCksIGdldFBhZ2VOdW1iZXIoKV0pLnRoZW4oKFtkZXN0LCBwYWdlSW5kZXgsIHBhZ2VOdW1iZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgb25JdGVtQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5rU2VydmljZSkge1xuICAgICAgICAgICAgbGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGl0ZW0uZGVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyU3ViaXRlbXMoKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtcyB8fCAhaXRlbS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXRlbXM6IHN1Yml0ZW1zIH0gPSBpdGVtO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCBudWxsLCBzdWJpdGVtcy5tYXAoKHN1Yml0ZW0sIHN1Yml0ZW1JbmRleCkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZUl0ZW0sIE9iamVjdC5hc3NpZ24oeyBrZXk6IHR5cGVvZiBzdWJpdGVtLmRlc3QgPT09ICdzdHJpbmcnID8gc3ViaXRlbS5kZXN0IDogc3ViaXRlbUluZGV4LCBpdGVtOiBzdWJpdGVtLCBwZGY6IHBkZiB9LCBvdGhlclByb3BzKSkpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGhyZWY6IFwiI1wiLCBvbkNsaWNrOiBvbkNsaWNrIH0sIGl0ZW0udGl0bGUpLFxuICAgICAgICByZW5kZXJTdWJpdGVtcygpKSk7XG59XG4iXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19yZXN0IiwicyIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIlJlYWN0IiwiaW52YXJpYW50IiwiUmVmIiwidXNlQ2FjaGVkVmFsdWUiLCJ1c2VEb2N1bWVudENvbnRleHQiLCJ1c2VPdXRsaW5lQ29udGV4dCIsIk91dGxpbmVJdGVtIiwicHJvcHMiLCJkb2N1bWVudENvbnRleHQiLCJvdXRsaW5lQ29udGV4dCIsIm1lcmdlZFByb3BzIiwiYXNzaWduIiwiaXRlbSIsImxpbmtTZXJ2aWNlIiwib25JdGVtQ2xpY2siLCJwZGYiLCJvdGhlclByb3BzIiwiZ2V0RGVzdGluYXRpb24iLCJkZXN0IiwiZ2V0UGFnZUluZGV4IiwiZGVzdGluYXRpb24iLCJFcnJvciIsInJlZiIsImdldFBhZ2VOdW1iZXIiLCJwYWdlSW5kZXgiLCJvbkNsaWNrIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImFsbCIsInBhZ2VOdW1iZXIiLCJnb1RvRGVzdGluYXRpb24iLCJyZW5kZXJTdWJpdGVtcyIsIml0ZW1zIiwic3ViaXRlbXMiLCJjcmVhdGVFbGVtZW50IiwibWFwIiwic3ViaXRlbSIsInN1Yml0ZW1JbmRleCIsImtleSIsImhyZWYiLCJ0aXRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/OutlineItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page.js":
/*!*************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var make_event_props__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! make-event-props */ \"(ssr)/./node_modules/make-event-props/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var merge_refs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! merge-refs */ \"(ssr)/./node_modules/merge-refs/dist/esm/index.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _PageContext_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./PageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/PageContext.js\");\n/* harmony import */ var _Message_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Message.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Message.js\");\n/* harmony import */ var _Page_PageCanvas_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Page/PageCanvas.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Page/PageCanvas.js\");\n/* harmony import */ var _Page_PageSVG_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Page/PageSVG.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Page/PageSVG.js\");\n/* harmony import */ var _Page_TextLayer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Page/TextLayer.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Page/TextLayer.js\");\n/* harmony import */ var _Page_AnnotationLayer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Page/AnnotationLayer.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* harmony import */ var _shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./shared/propTypes.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/propTypes.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst defaultScale = 1;\n/**\n * Displays a page.\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function, however some advanced functions like linking between pages inside a document may not be working correctly.\n */ const Page = function Page(props) {\n    const documentContext = (0,_shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { _className = \"react-pdf__Page\", _enableRegisterUnregisterPage = true, canvasBackground, canvasRef, children, className, customRenderer: CustomRenderer, customTextRenderer, devicePixelRatio, error = \"Failed to load the page.\", height, inputRef, loading = \"Loading page…\", noData = \"No page specified.\", onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, onGetTextError: onGetTextErrorProps, onGetTextSuccess: onGetTextSuccessProps, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, onRenderTextLayerError: onRenderTextLayerErrorProps, onRenderTextLayerSuccess: onRenderTextLayerSuccessProps, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf, registerPage, renderAnnotationLayer: renderAnnotationLayerProps = true, renderForms = false, renderMode = \"canvas\", renderTextLayer: renderTextLayerProps = true, rotate: rotateProps, scale: scaleProps = defaultScale, unregisterPage, width } = mergedProps, otherProps = __rest(mergedProps, [\n        \"_className\",\n        \"_enableRegisterUnregisterPage\",\n        \"canvasBackground\",\n        \"canvasRef\",\n        \"children\",\n        \"className\",\n        \"customRenderer\",\n        \"customTextRenderer\",\n        \"devicePixelRatio\",\n        \"error\",\n        \"height\",\n        \"inputRef\",\n        \"loading\",\n        \"noData\",\n        \"onGetAnnotationsError\",\n        \"onGetAnnotationsSuccess\",\n        \"onGetStructTreeError\",\n        \"onGetStructTreeSuccess\",\n        \"onGetTextError\",\n        \"onGetTextSuccess\",\n        \"onLoadError\",\n        \"onLoadSuccess\",\n        \"onRenderAnnotationLayerError\",\n        \"onRenderAnnotationLayerSuccess\",\n        \"onRenderError\",\n        \"onRenderSuccess\",\n        \"onRenderTextLayerError\",\n        \"onRenderTextLayerSuccess\",\n        \"pageIndex\",\n        \"pageNumber\",\n        \"pdf\",\n        \"registerPage\",\n        \"renderAnnotationLayer\",\n        \"renderForms\",\n        \"renderMode\",\n        \"renderTextLayer\",\n        \"rotate\",\n        \"scale\",\n        \"unregisterPage\",\n        \"width\"\n    ]);\n    const [pageState, pageDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n    const { value: page, error: pageError } = pageState;\n    const pageElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pdf, \"Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.\");\n    const pageIndex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n    const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;\n    const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;\n    const scale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!page) {\n            return null;\n        }\n        // Be default, we'll render page at 100% * scale width.\n        let pageScale = 1;\n        // Passing scale explicitly null would cause the page not to render\n        const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;\n        // If width/height is defined, calculate the scale of the page so it could be of desired width.\n        if (width || height) {\n            const viewport = page.getViewport({\n                scale: 1,\n                rotation: rotate\n            });\n            if (width) {\n                pageScale = width / viewport.width;\n            } else if (height) {\n                pageScale = height / viewport.height;\n            }\n        }\n        return scaleWithDefault * pageScale;\n    }, [\n        height,\n        page,\n        rotate,\n        scaleProps,\n        width\n    ]);\n    function hook() {\n        return ()=>{\n            if (!(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(pageIndex)) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            if (_enableRegisterUnregisterPage && unregisterPage) {\n                unregisterPage(pageIndex);\n            }\n        };\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(hook, [\n        _enableRegisterUnregisterPage,\n        pdf,\n        pageIndex,\n        unregisterPage\n    ]);\n    /**\n     * Called when a page is loaded successfully\n     */ function onLoadSuccess() {\n        if (onLoadSuccessProps) {\n            if (!page || !scale) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            onLoadSuccessProps((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.makePageCallback)(page, scale));\n        }\n        if (_enableRegisterUnregisterPage && registerPage) {\n            if (!(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(pageIndex) || !pageElement.current) {\n                // Impossible, but TypeScript doesn't know that\n                return;\n            }\n            registerPage(pageIndex, pageElement.current);\n        }\n    }\n    /**\n     * Called when a page failed to load\n     */ function onLoadError() {\n        if (!pageError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, pageError.toString());\n        if (onLoadErrorProps) {\n            onLoadErrorProps(pageError);\n        }\n    }\n    function resetPage() {\n        pageDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetPage, [\n        pageDispatch,\n        pdf,\n        pageIndex\n    ]);\n    function loadPage() {\n        if (!pdf || !pageNumber) {\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(pdf.getPage(pageNumber));\n        const runningTask = cancellable;\n        cancellable.promise.then((nextPage)=>{\n            pageDispatch({\n                type: \"RESOLVE\",\n                value: nextPage\n            });\n        }).catch((error)=>{\n            pageDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadPage, [\n        pageDispatch,\n        pdf,\n        pageIndex,\n        pageNumber,\n        registerPage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (page === undefined) {\n            return;\n        }\n        if (page === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        page,\n        scale\n    ]);\n    const childContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>// Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that\n        page && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(pageIndex) && pageNumber && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(rotate) && (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.isProvided)(scale) ? {\n            _className,\n            canvasBackground,\n            customTextRenderer,\n            devicePixelRatio,\n            onGetAnnotationsError: onGetAnnotationsErrorProps,\n            onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,\n            onGetStructTreeError: onGetStructTreeErrorProps,\n            onGetStructTreeSuccess: onGetStructTreeSuccessProps,\n            onGetTextError: onGetTextErrorProps,\n            onGetTextSuccess: onGetTextSuccessProps,\n            onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,\n            onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,\n            onRenderError: onRenderErrorProps,\n            onRenderSuccess: onRenderSuccessProps,\n            onRenderTextLayerError: onRenderTextLayerErrorProps,\n            onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,\n            page,\n            pageIndex,\n            pageNumber,\n            renderForms,\n            renderTextLayer: renderTextLayerProps,\n            rotate,\n            scale\n        } : null, [\n        _className,\n        canvasBackground,\n        customTextRenderer,\n        devicePixelRatio,\n        onGetAnnotationsErrorProps,\n        onGetAnnotationsSuccessProps,\n        onGetStructTreeErrorProps,\n        onGetStructTreeSuccessProps,\n        onGetTextErrorProps,\n        onGetTextSuccessProps,\n        onRenderAnnotationLayerErrorProps,\n        onRenderAnnotationLayerSuccessProps,\n        onRenderErrorProps,\n        onRenderSuccessProps,\n        onRenderTextLayerErrorProps,\n        onRenderTextLayerSuccessProps,\n        page,\n        pageIndex,\n        pageNumber,\n        renderForms,\n        renderTextLayerProps,\n        rotate,\n        scale\n    ]);\n    const eventProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,make_event_props__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(otherProps, ()=>page ? scale ? (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.makePageCallback)(page, scale) : undefined : page), [\n        otherProps,\n        page,\n        scale\n    ]);\n    const pageKey = `${pageIndex}@${scale}/${rotate}`;\n    const pageKeyNoScale = `${pageIndex}/${rotate}`;\n    function renderMainLayer() {\n        switch(renderMode){\n            case \"custom\":\n                {\n                    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(CustomRenderer, `renderMode was set to \"custom\", but no customRenderer was passed.`);\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomRenderer, {\n                        key: `${pageKey}_custom`\n                    });\n                }\n            case \"none\":\n                return null;\n            case \"svg\":\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Page_PageSVG_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                    key: `${pageKeyNoScale}_svg`\n                });\n            case \"canvas\":\n            default:\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Page_PageCanvas_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                    key: `${pageKey}_canvas`,\n                    canvasRef: canvasRef\n                });\n        }\n    }\n    function renderTextLayer() {\n        if (!renderTextLayerProps) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Page_TextLayer_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n            key: `${pageKey}_text`\n        });\n    }\n    function renderAnnotationLayer() {\n        if (!renderAnnotationLayerProps) {\n            return null;\n        }\n        /**\n         * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.\n         * Therefore, as a fallback, we render \"traditional\" AnnotationLayer component.\n         */ return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Page_AnnotationLayer_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n            key: `${pageKey}_annotations`\n        });\n    }\n    function renderChildren() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_PageContext_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"].Provider, {\n            value: childContext\n        }, renderMainLayer(), renderTextLayer(), renderAnnotationLayer(), children);\n    }\n    function renderContent() {\n        if (!pageNumber) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                type: \"no-data\"\n            }, typeof noData === \"function\" ? noData() : noData);\n        }\n        if (pdf === null || page === undefined || page === null) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                type: \"loading\"\n            }, typeof loading === \"function\" ? loading() : loading);\n        }\n        if (pdf === false || page === false) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Message_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"], {\n                type: \"error\"\n            }, typeof error === \"function\" ? error() : error);\n        }\n        return renderChildren();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_className, className),\n        \"data-page-number\": pageNumber,\n        ref: (0,merge_refs__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(inputRef, pageElement),\n        style: {\n            [\"--scale-factor\"]: `${scale}`,\n            backgroundColor: canvasBackground || \"white\",\n            position: \"relative\",\n            minWidth: \"min-content\",\n            minHeight: \"min-content\"\n        }\n    }, eventProps), renderContent());\n};\nconst isFunctionOrNode = prop_types__WEBPACK_IMPORTED_MODULE_16__.oneOfType([\n    prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    prop_types__WEBPACK_IMPORTED_MODULE_16__.node\n]);\nPage.propTypes = Object.assign(Object.assign({}, _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.eventProps), {\n    canvasBackground: prop_types__WEBPACK_IMPORTED_MODULE_16__.string,\n    canvasRef: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isRef,\n    children: prop_types__WEBPACK_IMPORTED_MODULE_16__.node,\n    className: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isClassName,\n    customRenderer: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    customTextRenderer: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    devicePixelRatio: prop_types__WEBPACK_IMPORTED_MODULE_16__.number,\n    error: isFunctionOrNode,\n    height: prop_types__WEBPACK_IMPORTED_MODULE_16__.number,\n    imageResourcesPath: prop_types__WEBPACK_IMPORTED_MODULE_16__.string,\n    inputRef: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isRef,\n    loading: isFunctionOrNode,\n    noData: isFunctionOrNode,\n    onGetTextError: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onGetTextSuccess: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onLoadSuccess: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onRenderError: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onRenderSuccess: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onRenderTextLayerError: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    onRenderTextLayerSuccess: prop_types__WEBPACK_IMPORTED_MODULE_16__.func,\n    pageIndex: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isPageIndex,\n    pageNumber: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isPageNumber,\n    pdf: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isPdf,\n    renderAnnotationLayer: prop_types__WEBPACK_IMPORTED_MODULE_16__.bool,\n    renderForms: prop_types__WEBPACK_IMPORTED_MODULE_16__.bool,\n    renderMode: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isRenderMode,\n    renderTextLayer: prop_types__WEBPACK_IMPORTED_MODULE_16__.bool,\n    rotate: _shared_propTypes_js__WEBPACK_IMPORTED_MODULE_17__.isRotate,\n    scale: prop_types__WEBPACK_IMPORTED_MODULE_16__.number,\n    width: prop_types__WEBPACK_IMPORTED_MODULE_16__.number\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Page);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2REFDQSxJQUFJQSxTQUFTLFNBQUssSUFBSSxTQUFJLENBQUNBLE1BQU0sSUFBSyxTQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDaEQsSUFBSUMsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJQyxLQUFLSCxFQUFHLElBQUlJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNQLEdBQUdHLE1BQU1GLEVBQUVPLE9BQU8sQ0FBQ0wsS0FBSyxHQUM5RUQsQ0FBQyxDQUFDQyxFQUFFLEdBQUdILENBQUMsQ0FBQ0csRUFBRTtJQUNmLElBQUlILEtBQUssUUFBUSxPQUFPSSxPQUFPSyxxQkFBcUIsS0FBSyxZQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR1AsSUFBSUMsT0FBT0sscUJBQXFCLENBQUNULElBQUlVLElBQUlQLEVBQUVRLE1BQU0sRUFBRUQsSUFBSztRQUNwRSxJQUFJVCxFQUFFTyxPQUFPLENBQUNMLENBQUMsQ0FBQ08sRUFBRSxJQUFJLEtBQUtOLE9BQU9DLFNBQVMsQ0FBQ08sb0JBQW9CLENBQUNMLElBQUksQ0FBQ1AsR0FBR0csQ0FBQyxDQUFDTyxFQUFFLEdBQ3pFUixDQUFDLENBQUNDLENBQUMsQ0FBQ08sRUFBRSxDQUFDLEdBQUdWLENBQUMsQ0FBQ0csQ0FBQyxDQUFDTyxFQUFFLENBQUM7SUFDekI7SUFDSixPQUFPUjtBQUNYO0FBQzBEO0FBQ3ZCO0FBQ29CO0FBQ1Q7QUFDdEI7QUFDVztBQUNJO0FBQ1Q7QUFDYTtBQUNSO0FBQ1c7QUFDTjtBQUNJO0FBQ1k7QUFDNEI7QUFDZDtBQUNkO0FBQzBFO0FBQ2xJLE1BQU15QyxlQUFlO0FBQ3JCOzs7O0NBSUMsR0FDRCxNQUFNQyxPQUFPLFNBQVNBLEtBQUtDLEtBQUs7SUFDNUIsTUFBTUMsa0JBQWtCYiwrRUFBa0JBO0lBQzFDLE1BQU1jLGNB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aUVBQWUyQixJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UuanM/NzFiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1ha2VDYW5jZWxsYWJsZSBmcm9tICdtYWtlLWNhbmNlbGxhYmxlLXByb21pc2UnO1xuaW1wb3J0IG1ha2VFdmVudFByb3BzIGZyb20gJ21ha2UtZXZlbnQtcHJvcHMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgbWVyZ2VSZWZzIGZyb20gJ21lcmdlLXJlZnMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBQYWdlQ29udGV4dCBmcm9tICcuL1BhZ2VDb250ZXh0LmpzJztcbmltcG9ydCBNZXNzYWdlIGZyb20gJy4vTWVzc2FnZS5qcyc7XG5pbXBvcnQgUGFnZUNhbnZhcyBmcm9tICcuL1BhZ2UvUGFnZUNhbnZhcy5qcyc7XG5pbXBvcnQgUGFnZVNWRyBmcm9tICcuL1BhZ2UvUGFnZVNWRy5qcyc7XG5pbXBvcnQgVGV4dExheWVyIGZyb20gJy4vUGFnZS9UZXh0TGF5ZXIuanMnO1xuaW1wb3J0IEFubm90YXRpb25MYXllciBmcm9tICcuL1BhZ2UvQW5ub3RhdGlvbkxheWVyLmpzJztcbmltcG9ydCB7IGNhbmNlbFJ1bm5pbmdUYXNrLCBpc1Byb3ZpZGVkLCBtYWtlUGFnZUNhbGxiYWNrIH0gZnJvbSAnLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHVzZURvY3VtZW50Q29udGV4dCBmcm9tICcuL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanMnO1xuaW1wb3J0IHVzZVJlc29sdmVyIGZyb20gJy4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzJztcbmltcG9ydCB7IGV2ZW50UHJvcHMsIGlzQ2xhc3NOYW1lLCBpc1BhZ2VJbmRleCwgaXNQYWdlTnVtYmVyLCBpc1BkZiwgaXNSZWYsIGlzUmVuZGVyTW9kZSwgaXNSb3RhdGUsIH0gZnJvbSAnLi9zaGFyZWQvcHJvcFR5cGVzLmpzJztcbmNvbnN0IGRlZmF1bHRTY2FsZSA9IDE7XG4vKipcbiAqIERpc3BsYXlzIGEgcGFnZS5cbiAqXG4gKiBTaG91bGQgYmUgcGxhY2VkIGluc2lkZSBgPERvY3VtZW50IC8+YC4gQWx0ZXJuYXRpdmVseSwgaXQgY2FuIGhhdmUgYHBkZmAgcHJvcCBwYXNzZWQsIHdoaWNoIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGA8RG9jdW1lbnQgLz5gJ3MgYG9uTG9hZFN1Y2Nlc3NgIGNhbGxiYWNrIGZ1bmN0aW9uLCBob3dldmVyIHNvbWUgYWR2YW5jZWQgZnVuY3Rpb25zIGxpa2UgbGlua2luZyBiZXR3ZWVuIHBhZ2VzIGluc2lkZSBhIGRvY3VtZW50IG1heSBub3QgYmUgd29ya2luZyBjb3JyZWN0bHkuXG4gKi9cbmNvbnN0IFBhZ2UgPSBmdW5jdGlvbiBQYWdlKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gdXNlRG9jdW1lbnRDb250ZXh0KCk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IF9jbGFzc05hbWUgPSAncmVhY3QtcGRmX19QYWdlJywgX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2UgPSB0cnVlLCBjYW52YXNCYWNrZ3JvdW5kLCBjYW52YXNSZWYsIGNoaWxkcmVuLCBjbGFzc05hbWUsIGN1c3RvbVJlbmRlcmVyOiBDdXN0b21SZW5kZXJlciwgY3VzdG9tVGV4dFJlbmRlcmVyLCBkZXZpY2VQaXhlbFJhdGlvLCBlcnJvciA9ICdGYWlsZWQgdG8gbG9hZCB0aGUgcGFnZS4nLCBoZWlnaHQsIGlucHV0UmVmLCBsb2FkaW5nID0gJ0xvYWRpbmcgcGFnZeKApicsIG5vRGF0YSA9ICdObyBwYWdlIHNwZWNpZmllZC4nLCBvbkdldEFubm90YXRpb25zRXJyb3I6IG9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzLCBvbkdldEFubm90YXRpb25zU3VjY2Vzczogb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcywgb25HZXRTdHJ1Y3RUcmVlRXJyb3I6IG9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMsIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3M6IG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcywgb25HZXRUZXh0RXJyb3I6IG9uR2V0VGV4dEVycm9yUHJvcHMsIG9uR2V0VGV4dFN1Y2Nlc3M6IG9uR2V0VGV4dFN1Y2Nlc3NQcm9wcywgb25Mb2FkRXJyb3I6IG9uTG9hZEVycm9yUHJvcHMsIG9uTG9hZFN1Y2Nlc3M6IG9uTG9hZFN1Y2Nlc3NQcm9wcywgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcjogb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclByb3BzLCBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3M6IG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1Byb3BzLCBvblJlbmRlckVycm9yOiBvblJlbmRlckVycm9yUHJvcHMsIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsIG9uUmVuZGVyVGV4dExheWVyRXJyb3I6IG9uUmVuZGVyVGV4dExheWVyRXJyb3JQcm9wcywgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzOiBvblJlbmRlclRleHRMYXllclN1Y2Nlc3NQcm9wcywgcGFnZUluZGV4OiBwYWdlSW5kZXhQcm9wcywgcGFnZU51bWJlcjogcGFnZU51bWJlclByb3BzLCBwZGYsIHJlZ2lzdGVyUGFnZSwgcmVuZGVyQW5ub3RhdGlvbkxheWVyOiByZW5kZXJBbm5vdGF0aW9uTGF5ZXJQcm9wcyA9IHRydWUsIHJlbmRlckZvcm1zID0gZmFsc2UsIHJlbmRlck1vZGUgPSAnY2FudmFzJywgcmVuZGVyVGV4dExheWVyOiByZW5kZXJUZXh0TGF5ZXJQcm9wcyA9IHRydWUsIHJvdGF0ZTogcm90YXRlUHJvcHMsIHNjYWxlOiBzY2FsZVByb3BzID0gZGVmYXVsdFNjYWxlLCB1bnJlZ2lzdGVyUGFnZSwgd2lkdGggfSA9IG1lcmdlZFByb3BzLCBvdGhlclByb3BzID0gX19yZXN0KG1lcmdlZFByb3BzLCBbXCJfY2xhc3NOYW1lXCIsIFwiX2VuYWJsZVJlZ2lzdGVyVW5yZWdpc3RlclBhZ2VcIiwgXCJjYW52YXNCYWNrZ3JvdW5kXCIsIFwiY2FudmFzUmVmXCIsIFwiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJjdXN0b21SZW5kZXJlclwiLCBcImN1c3RvbVRleHRSZW5kZXJlclwiLCBcImRldmljZVBpeGVsUmF0aW9cIiwgXCJlcnJvclwiLCBcImhlaWdodFwiLCBcImlucHV0UmVmXCIsIFwibG9hZGluZ1wiLCBcIm5vRGF0YVwiLCBcIm9uR2V0QW5ub3RhdGlvbnNFcnJvclwiLCBcIm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzXCIsIFwib25HZXRTdHJ1Y3RUcmVlRXJyb3JcIiwgXCJvbkdldFN0cnVjdFRyZWVTdWNjZXNzXCIsIFwib25HZXRUZXh0RXJyb3JcIiwgXCJvbkdldFRleHRTdWNjZXNzXCIsIFwib25Mb2FkRXJyb3JcIiwgXCJvbkxvYWRTdWNjZXNzXCIsIFwib25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclwiLCBcIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1wiLCBcIm9uUmVuZGVyRXJyb3JcIiwgXCJvblJlbmRlclN1Y2Nlc3NcIiwgXCJvblJlbmRlclRleHRMYXllckVycm9yXCIsIFwib25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzXCIsIFwicGFnZUluZGV4XCIsIFwicGFnZU51bWJlclwiLCBcInBkZlwiLCBcInJlZ2lzdGVyUGFnZVwiLCBcInJlbmRlckFubm90YXRpb25MYXllclwiLCBcInJlbmRlckZvcm1zXCIsIFwicmVuZGVyTW9kZVwiLCBcInJlbmRlclRleHRMYXllclwiLCBcInJvdGF0ZVwiLCBcInNjYWxlXCIsIFwidW5yZWdpc3RlclBhZ2VcIiwgXCJ3aWR0aFwiXSk7XG4gICAgY29uc3QgW3BhZ2VTdGF0ZSwgcGFnZURpc3BhdGNoXSA9IHVzZVJlc29sdmVyKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogcGFnZSwgZXJyb3I6IHBhZ2VFcnJvciB9ID0gcGFnZVN0YXRlO1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXNlUmVmKG51bGwpO1xuICAgIGludmFyaWFudChwZGYsICdBdHRlbXB0ZWQgdG8gbG9hZCBhIHBhZ2UsIGJ1dCBubyBkb2N1bWVudCB3YXMgc3BlY2lmaWVkLiBXcmFwIDxQYWdlIC8+IGluIGEgPERvY3VtZW50IC8+IG9yIHBhc3MgZXhwbGljaXQgYHBkZmAgcHJvcC4nKTtcbiAgICBjb25zdCBwYWdlSW5kZXggPSBpc1Byb3ZpZGVkKHBhZ2VOdW1iZXJQcm9wcykgPyBwYWdlTnVtYmVyUHJvcHMgLSAxIDogcGFnZUluZGV4UHJvcHMgIT09IG51bGwgJiYgcGFnZUluZGV4UHJvcHMgIT09IHZvaWQgMCA/IHBhZ2VJbmRleFByb3BzIDogbnVsbDtcbiAgICBjb25zdCBwYWdlTnVtYmVyID0gcGFnZU51bWJlclByb3BzICE9PSBudWxsICYmIHBhZ2VOdW1iZXJQcm9wcyAhPT0gdm9pZCAwID8gcGFnZU51bWJlclByb3BzIDogKGlzUHJvdmlkZWQocGFnZUluZGV4UHJvcHMpID8gcGFnZUluZGV4UHJvcHMgKyAxIDogbnVsbCk7XG4gICAgY29uc3Qgcm90YXRlID0gcm90YXRlUHJvcHMgIT09IG51bGwgJiYgcm90YXRlUHJvcHMgIT09IHZvaWQgMCA/IHJvdGF0ZVByb3BzIDogKHBhZ2UgPyBwYWdlLnJvdGF0ZSA6IG51bGwpO1xuICAgIGNvbnN0IHNjYWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmUgZGVmYXVsdCwgd2UnbGwgcmVuZGVyIHBhZ2UgYXQgMTAwJSAqIHNjYWxlIHdpZHRoLlxuICAgICAgICBsZXQgcGFnZVNjYWxlID0gMTtcbiAgICAgICAgLy8gUGFzc2luZyBzY2FsZSBleHBsaWNpdGx5IG51bGwgd291bGQgY2F1c2UgdGhlIHBhZ2Ugbm90IHRvIHJlbmRlclxuICAgICAgICBjb25zdCBzY2FsZVdpdGhEZWZhdWx0ID0gc2NhbGVQcm9wcyAhPT0gbnVsbCAmJiBzY2FsZVByb3BzICE9PSB2b2lkIDAgPyBzY2FsZVByb3BzIDogZGVmYXVsdFNjYWxlO1xuICAgICAgICAvLyBJZiB3aWR0aC9oZWlnaHQgaXMgZGVmaW5lZCwgY2FsY3VsYXRlIHRoZSBzY2FsZSBvZiB0aGUgcGFnZSBzbyBpdCBjb3VsZCBiZSBvZiBkZXNpcmVkIHdpZHRoLlxuICAgICAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMSwgcm90YXRpb246IHJvdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgICAgIHBhZ2VTY2FsZSA9IHdpZHRoIC8gdmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBwYWdlU2NhbGUgPSBoZWlnaHQgLyB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlV2l0aERlZmF1bHQgKiBwYWdlU2NhbGU7XG4gICAgfSwgW2hlaWdodCwgcGFnZSwgcm90YXRlLCBzY2FsZVByb3BzLCB3aWR0aF0pO1xuICAgIGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUHJvdmlkZWQocGFnZUluZGV4KSkge1xuICAgICAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9lbmFibGVSZWdpc3RlclVucmVnaXN0ZXJQYWdlICYmIHVucmVnaXN0ZXJQYWdlKSB7XG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlclBhZ2UocGFnZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KGhvb2ssIFtfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSwgcGRmLCBwYWdlSW5kZXgsIHVucmVnaXN0ZXJQYWdlXSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIGlzIGxvYWRlZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRTdWNjZXNzKCkge1xuICAgICAgICBpZiAob25Mb2FkU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXBhZ2UgfHwgIXNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkxvYWRTdWNjZXNzUHJvcHMobWFrZVBhZ2VDYWxsYmFjayhwYWdlLCBzY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSAmJiByZWdpc3RlclBhZ2UpIHtcbiAgICAgICAgICAgIGlmICghaXNQcm92aWRlZChwYWdlSW5kZXgpIHx8ICFwYWdlRWxlbWVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWdpc3RlclBhZ2UocGFnZUluZGV4LCBwYWdlRWxlbWVudC5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgZmFpbGVkIHRvIGxvYWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkxvYWRFcnJvcigpIHtcbiAgICAgICAgaWYgKCFwYWdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgcGFnZUVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25Mb2FkRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3JQcm9wcyhwYWdlRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0UGFnZSgpIHtcbiAgICAgICAgcGFnZURpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KHJlc2V0UGFnZSwgW3BhZ2VEaXNwYXRjaCwgcGRmLCBwYWdlSW5kZXhdKTtcbiAgICBmdW5jdGlvbiBsb2FkUGFnZSgpIHtcbiAgICAgICAgaWYgKCFwZGYgfHwgIXBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9IG1ha2VDYW5jZWxsYWJsZShwZGYuZ2V0UGFnZShwYWdlTnVtYmVyKSk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0UGFnZSkgPT4ge1xuICAgICAgICAgICAgcGFnZURpc3BhdGNoKHsgdHlwZTogJ1JFU09MVkUnLCB2YWx1ZTogbmV4dFBhZ2UgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBwYWdlRGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUnVubmluZ1Rhc2socnVubmluZ1Rhc2spO1xuICAgIH1cbiAgICB1c2VFZmZlY3QobG9hZFBhZ2UsIFtwYWdlRGlzcGF0Y2gsIHBkZiwgcGFnZUluZGV4LCBwYWdlTnVtYmVyLCByZWdpc3RlclBhZ2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocGFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvbkxvYWRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZFN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtwYWdlLCBzY2FsZV0pO1xuICAgIGNvbnN0IGNoaWxkQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhlcmUgY2Fubm90IGJlIHBhZ2Ugd2l0aG91dCBwYWdlSW5kZXgsIHBhZ2VOdW1iZXIsIHJvdGF0ZSBhbmQgc2NhbGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgcGFnZSAmJiBpc1Byb3ZpZGVkKHBhZ2VJbmRleCkgJiYgcGFnZU51bWJlciAmJiBpc1Byb3ZpZGVkKHJvdGF0ZSkgJiYgaXNQcm92aWRlZChzY2FsZSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lLFxuICAgICAgICAgICAgY2FudmFzQmFja2dyb3VuZCxcbiAgICAgICAgICAgIGN1c3RvbVRleHRSZW5kZXJlcixcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICBvbkdldEFubm90YXRpb25zRXJyb3I6IG9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzLFxuICAgICAgICAgICAgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3M6IG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzUHJvcHMsXG4gICAgICAgICAgICBvbkdldFN0cnVjdFRyZWVFcnJvcjogb25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyxcbiAgICAgICAgICAgIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3M6IG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcyxcbiAgICAgICAgICAgIG9uR2V0VGV4dEVycm9yOiBvbkdldFRleHRFcnJvclByb3BzLFxuICAgICAgICAgICAgb25HZXRUZXh0U3VjY2Vzczogb25HZXRUZXh0U3VjY2Vzc1Byb3BzLFxuICAgICAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcjogb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvclByb3BzLFxuICAgICAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzOiBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcyxcbiAgICAgICAgICAgIG9uUmVuZGVyRXJyb3I6IG9uUmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICAgIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgICAgICBvblJlbmRlclRleHRMYXllckVycm9yOiBvblJlbmRlclRleHRMYXllckVycm9yUHJvcHMsXG4gICAgICAgICAgICBvblJlbmRlclRleHRMYXllclN1Y2Nlc3M6IG9uUmVuZGVyVGV4dExheWVyU3VjY2Vzc1Byb3BzLFxuICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgICAgICByZW5kZXJGb3JtcyxcbiAgICAgICAgICAgIHJlbmRlclRleHRMYXllcjogcmVuZGVyVGV4dExheWVyUHJvcHMsXG4gICAgICAgICAgICByb3RhdGUsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgfVxuICAgICAgICA6IG51bGwsIFtcbiAgICAgICAgX2NsYXNzTmFtZSxcbiAgICAgICAgY2FudmFzQmFja2dyb3VuZCxcbiAgICAgICAgY3VzdG9tVGV4dFJlbmRlcmVyLFxuICAgICAgICBkZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgICBvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcyxcbiAgICAgICAgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyxcbiAgICAgICAgb25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyxcbiAgICAgICAgb25HZXRTdHJ1Y3RUcmVlU3VjY2Vzc1Byb3BzLFxuICAgICAgICBvbkdldFRleHRFcnJvclByb3BzLFxuICAgICAgICBvbkdldFRleHRTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIG9uUmVuZGVyVGV4dExheWVyRXJyb3JQcm9wcyxcbiAgICAgICAgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzUHJvcHMsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgcGFnZU51bWJlcixcbiAgICAgICAgcmVuZGVyRm9ybXMsXG4gICAgICAgIHJlbmRlclRleHRMYXllclByb3BzLFxuICAgICAgICByb3RhdGUsXG4gICAgICAgIHNjYWxlLFxuICAgIF0pO1xuICAgIGNvbnN0IGV2ZW50UHJvcHMgPSB1c2VNZW1vKCgpID0+IG1ha2VFdmVudFByb3BzKG90aGVyUHJvcHMsICgpID0+IHBhZ2UgPyAoc2NhbGUgPyBtYWtlUGFnZUNhbGxiYWNrKHBhZ2UsIHNjYWxlKSA6IHVuZGVmaW5lZCkgOiBwYWdlKSwgW290aGVyUHJvcHMsIHBhZ2UsIHNjYWxlXSk7XG4gICAgY29uc3QgcGFnZUtleSA9IGAke3BhZ2VJbmRleH1AJHtzY2FsZX0vJHtyb3RhdGV9YDtcbiAgICBjb25zdCBwYWdlS2V5Tm9TY2FsZSA9IGAke3BhZ2VJbmRleH0vJHtyb3RhdGV9YDtcbiAgICBmdW5jdGlvbiByZW5kZXJNYWluTGF5ZXIoKSB7XG4gICAgICAgIHN3aXRjaCAocmVuZGVyTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnY3VzdG9tJzoge1xuICAgICAgICAgICAgICAgIGludmFyaWFudChDdXN0b21SZW5kZXJlciwgYHJlbmRlck1vZGUgd2FzIHNldCB0byBcImN1c3RvbVwiLCBidXQgbm8gY3VzdG9tUmVuZGVyZXIgd2FzIHBhc3NlZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21SZW5kZXJlciwgeyBrZXk6IGAke3BhZ2VLZXl9X2N1c3RvbWAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ3N2Zyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZVNWRywgeyBrZXk6IGAke3BhZ2VLZXlOb1NjYWxlfV9zdmdgIH0pO1xuICAgICAgICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZUNhbnZhcywgeyBrZXk6IGAke3BhZ2VLZXl9X2NhbnZhc2AsIGNhbnZhc1JlZjogY2FudmFzUmVmIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclRleHRMYXllcigpIHtcbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0TGF5ZXJQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dExheWVyLCB7IGtleTogYCR7cGFnZUtleX1fdGV4dGAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckFubm90YXRpb25MYXllcigpIHtcbiAgICAgICAgaWYgKCFyZW5kZXJBbm5vdGF0aW9uTGF5ZXJQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzIG9mIG5vdywgUERGLmpzIDIuMC45NDMgcmV0dXJucyB3YXJuaW5ncyBvbiB1bmltcGxlbWVudGVkIGFubm90YXRpb25zIGluIFNWRyBtb2RlLlxuICAgICAgICAgKiBUaGVyZWZvcmUsIGFzIGEgZmFsbGJhY2ssIHdlIHJlbmRlciBcInRyYWRpdGlvbmFsXCIgQW5ub3RhdGlvbkxheWVyIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEFubm90YXRpb25MYXllciwgeyBrZXk6IGAke3BhZ2VLZXl9X2Fubm90YXRpb25zYCB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY2hpbGRDb250ZXh0IH0sXG4gICAgICAgICAgICByZW5kZXJNYWluTGF5ZXIoKSxcbiAgICAgICAgICAgIHJlbmRlclRleHRMYXllcigpLFxuICAgICAgICAgICAgcmVuZGVyQW5ub3RhdGlvbkxheWVyKCksXG4gICAgICAgICAgICBjaGlsZHJlbikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJDb250ZW50KCkge1xuICAgICAgICBpZiAoIXBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2UsIHsgdHlwZTogXCJuby1kYXRhXCIgfSwgdHlwZW9mIG5vRGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IG5vRGF0YSgpIDogbm9EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBudWxsIHx8IHBhZ2UgPT09IHVuZGVmaW5lZCB8fCBwYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVzc2FnZSwgeyB0eXBlOiBcImxvYWRpbmdcIiB9LCB0eXBlb2YgbG9hZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IGxvYWRpbmcoKSA6IGxvYWRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGRmID09PSBmYWxzZSB8fCBwYWdlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVzc2FnZSwgeyB0eXBlOiBcImVycm9yXCIgfSwgdHlwZW9mIGVycm9yID09PSAnZnVuY3Rpb24nID8gZXJyb3IoKSA6IGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNsc3goX2NsYXNzTmFtZSwgY2xhc3NOYW1lKSwgXCJkYXRhLXBhZ2UtbnVtYmVyXCI6IHBhZ2VOdW1iZXIsIHJlZjogbWVyZ2VSZWZzKGlucHV0UmVmLCBwYWdlRWxlbWVudCksIHN0eWxlOiB7XG4gICAgICAgICAgICBbJy0tc2NhbGUtZmFjdG9yJ106IGAke3NjYWxlfWAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNhbnZhc0JhY2tncm91bmQgfHwgJ3doaXRlJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgbWluV2lkdGg6ICdtaW4tY29udGVudCcsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6ICdtaW4tY29udGVudCcsXG4gICAgICAgIH0gfSwgZXZlbnRQcm9wcyksIHJlbmRlckNvbnRlbnQoKSkpO1xufTtcbmNvbnN0IGlzRnVuY3Rpb25Pck5vZGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKTtcblBhZ2UucHJvcFR5cGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFByb3BzKSwgeyBjYW52YXNCYWNrZ3JvdW5kOiBQcm9wVHlwZXMuc3RyaW5nLCBjYW52YXNSZWY6IGlzUmVmLCBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsIGNsYXNzTmFtZTogaXNDbGFzc05hbWUsIGN1c3RvbVJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYywgY3VzdG9tVGV4dFJlbmRlcmVyOiBQcm9wVHlwZXMuZnVuYywgZGV2aWNlUGl4ZWxSYXRpbzogUHJvcFR5cGVzLm51bWJlciwgZXJyb3I6IGlzRnVuY3Rpb25Pck5vZGUsIGhlaWdodDogUHJvcFR5cGVzLm51bWJlciwgaW1hZ2VSZXNvdXJjZXNQYXRoOiBQcm9wVHlwZXMuc3RyaW5nLCBpbnB1dFJlZjogaXNSZWYsIGxvYWRpbmc6IGlzRnVuY3Rpb25Pck5vZGUsIG5vRGF0YTogaXNGdW5jdGlvbk9yTm9kZSwgb25HZXRUZXh0RXJyb3I6IFByb3BUeXBlcy5mdW5jLCBvbkdldFRleHRTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYywgb25Mb2FkRXJyb3I6IFByb3BUeXBlcy5mdW5jLCBvbkxvYWRTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYywgb25SZW5kZXJFcnJvcjogUHJvcFR5cGVzLmZ1bmMsIG9uUmVuZGVyU3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsIG9uUmVuZGVyVGV4dExheWVyRXJyb3I6IFByb3BUeXBlcy5mdW5jLCBvblJlbmRlclRleHRMYXllclN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLCBwYWdlSW5kZXg6IGlzUGFnZUluZGV4LCBwYWdlTnVtYmVyOiBpc1BhZ2VOdW1iZXIsIHBkZjogaXNQZGYsIHJlbmRlckFubm90YXRpb25MYXllcjogUHJvcFR5cGVzLmJvb2wsIHJlbmRlckZvcm1zOiBQcm9wVHlwZXMuYm9vbCwgcmVuZGVyTW9kZTogaXNSZW5kZXJNb2RlLCByZW5kZXJUZXh0TGF5ZXI6IFByb3BUeXBlcy5ib29sLCByb3RhdGU6IGlzUm90YXRlLCBzY2FsZTogUHJvcFR5cGVzLm51bWJlciwgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIgfSk7XG5leHBvcnQgZGVmYXVsdCBQYWdlO1xuIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwiUHJvcFR5cGVzIiwibWFrZUNhbmNlbGxhYmxlIiwibWFrZUV2ZW50UHJvcHMiLCJjbHN4IiwibWVyZ2VSZWZzIiwiaW52YXJpYW50Iiwid2FybmluZyIsIlBhZ2VDb250ZXh0IiwiTWVzc2FnZSIsIlBhZ2VDYW52YXMiLCJQYWdlU1ZHIiwiVGV4dExheWVyIiwiQW5ub3RhdGlvbkxheWVyIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJpc1Byb3ZpZGVkIiwibWFrZVBhZ2VDYWxsYmFjayIsInVzZURvY3VtZW50Q29udGV4dCIsInVzZVJlc29sdmVyIiwiZXZlbnRQcm9wcyIsImlzQ2xhc3NOYW1lIiwiaXNQYWdlSW5kZXgiLCJpc1BhZ2VOdW1iZXIiLCJpc1BkZiIsImlzUmVmIiwiaXNSZW5kZXJNb2RlIiwiaXNSb3RhdGUiLCJkZWZhdWx0U2NhbGUiLCJQYWdlIiwicHJvcHMiLCJkb2N1bWVudENvbnRleHQiLCJtZXJnZWRQcm9wcyIsImFzc2lnbiIsIl9jbGFzc05hbWUiLCJfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSIsImNhbnZhc0JhY2tncm91bmQiLCJjYW52YXNSZWYiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImN1c3RvbVJlbmRlcmVyIiwiQ3VzdG9tUmVuZGVyZXIiLCJjdXN0b21UZXh0UmVuZGVyZXIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiZXJyb3IiLCJoZWlnaHQiLCJpbnB1dFJlZiIsImxvYWRpbmciLCJub0RhdGEiLCJvbkdldEFubm90YXRpb25zRXJyb3IiLCJvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcyIsIm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzIiwib25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyIsIm9uR2V0U3RydWN0VHJlZUVycm9yIiwib25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyIsIm9uR2V0U3RydWN0VHJlZVN1Y2Nlc3MiLCJvbkdldFN0cnVjdFRyZWVTdWNjZXNzUHJvcHMiLCJvbkdldFRleHRFcnJvciIsIm9uR2V0VGV4dEVycm9yUHJvcHMiLCJvbkdldFRleHRTdWNjZXNzIiwib25HZXRUZXh0U3VjY2Vzc1Byb3BzIiwib25Mb2FkRXJyb3IiLCJvbkxvYWRFcnJvclByb3BzIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZFN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3IiLCJvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3MiLCJvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyRXJyb3IiLCJvblJlbmRlckVycm9yUHJvcHMiLCJvblJlbmRlclN1Y2Nlc3MiLCJvblJlbmRlclN1Y2Nlc3NQcm9wcyIsIm9uUmVuZGVyVGV4dExheWVyRXJyb3IiLCJvblJlbmRlclRleHRMYXllckVycm9yUHJvcHMiLCJvblJlbmRlclRleHRMYXllclN1Y2Nlc3MiLCJvblJlbmRlclRleHRMYXllclN1Y2Nlc3NQcm9wcyIsInBhZ2VJbmRleCIsInBhZ2VJbmRleFByb3BzIiwicGFnZU51bWJlciIsInBhZ2VOdW1iZXJQcm9wcyIsInBkZiIsInJlZ2lzdGVyUGFnZSIsInJlbmRlckFubm90YXRpb25MYXllciIsInJlbmRlckFubm90YXRpb25MYXllclByb3BzIiwicmVuZGVyRm9ybXMiLCJyZW5kZXJNb2RlIiwicmVuZGVyVGV4dExheWVyIiwicmVuZGVyVGV4dExheWVyUHJvcHMiLCJyb3RhdGUiLCJyb3RhdGVQcm9wcyIsInNjYWxlIiwic2NhbGVQcm9wcyIsInVucmVnaXN0ZXJQYWdlIiwid2lkdGgiLCJvdGhlclByb3BzIiwicGFnZVN0YXRlIiwicGFnZURpc3BhdGNoIiwidmFsdWUiLCJwYWdlIiwicGFnZUVycm9yIiwicGFnZUVsZW1lbnQiLCJwYWdlU2NhbGUiLCJzY2FsZVdpdGhEZWZhdWx0Iiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInJvdGF0aW9uIiwiaG9vayIsImN1cnJlbnQiLCJ0b1N0cmluZyIsInJlc2V0UGFnZSIsInR5cGUiLCJsb2FkUGFnZSIsImNhbmNlbGxhYmxlIiwiZ2V0UGFnZSIsInJ1bm5pbmdUYXNrIiwicHJvbWlzZSIsInRoZW4iLCJuZXh0UGFnZSIsImNhdGNoIiwidW5kZWZpbmVkIiwiY2hpbGRDb250ZXh0IiwicGFnZUtleSIsInBhZ2VLZXlOb1NjYWxlIiwicmVuZGVyTWFpbkxheWVyIiwiY3JlYXRlRWxlbWVudCIsImtleSIsInJlbmRlckNoaWxkcmVuIiwiUHJvdmlkZXIiLCJyZW5kZXJDb250ZW50IiwicmVmIiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwb3NpdGlvbiIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwiaXNGdW5jdGlvbk9yTm9kZSIsIm9uZU9mVHlwZSIsImZ1bmMiLCJub2RlIiwicHJvcFR5cGVzIiwic3RyaW5nIiwibnVtYmVyIiwiaW1hZ2VSZXNvdXJjZXNQYXRoIiwiYm9vbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/PageContext.js":
/*!********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/PageContext.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2VDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OzZEQUNzQztBQUN0Qyw4RUFBZUEsb0RBQWFBLENBQUMsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2VDb250ZXh0LmpzP2E0Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/PageContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AnnotationLayer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/hooks/useDocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\");\n/* harmony import */ var _shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\n\n\nfunction AnnotationLayer() {\n    const documentContext = (0,_shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const pageContext = (0,_shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pageContext, \"Unable to find Page context.\");\n    const mergedProps = Object.assign(Object.assign({}, documentContext), pageContext);\n    const { imageResourcesPath, linkService, onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, page, pdf, renderForms, rotate, scale = 1 } = mergedProps;\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pdf, \"Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.\");\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(page, \"Attempted to load page annotations, but no page was specified.\");\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(linkService, \"Attempted to load page annotations, but no linkService was specified.\");\n    const [annotationsState, annotationsDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n    const { value: annotations, error: annotationsError } = annotationsState;\n    const layerElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    warning__WEBPACK_IMPORTED_MODULE_3__(parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--react-pdf-annotation-layer\"), 10) === 1, \"AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations\");\n    function onLoadSuccess() {\n        if (!annotations) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetAnnotationsSuccessProps) {\n            onGetAnnotationsSuccessProps(annotations);\n        }\n    }\n    function onLoadError() {\n        if (!annotationsError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, annotationsError.toString());\n        if (onGetAnnotationsErrorProps) {\n            onGetAnnotationsErrorProps(annotationsError);\n        }\n    }\n    function resetAnnotations() {\n        annotationsDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetAnnotations, [\n        annotationsDispatch,\n        page\n    ]);\n    function loadAnnotations() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(page.getAnnotations());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextAnnotations)=>{\n            annotationsDispatch({\n                type: \"RESOLVE\",\n                value: nextAnnotations\n            });\n        }).catch((error)=>{\n            annotationsDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>{\n            (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_8__.cancelRunningTask)(runningTask);\n        };\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadAnnotations, [\n        annotationsDispatch,\n        page,\n        renderForms\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (annotations === undefined) {\n            return;\n        }\n        if (annotations === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        annotations\n    ]);\n    function onRenderSuccess() {\n        if (onRenderAnnotationLayerSuccessProps) {\n            onRenderAnnotationLayerSuccessProps();\n        }\n    }\n    function onRenderError(error) {\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, `${error}`);\n        if (onRenderAnnotationLayerErrorProps) {\n            onRenderAnnotationLayerErrorProps(error);\n        }\n    }\n    const viewport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function renderAnnotationLayer() {\n        if (!pdf || !page || !linkService || !annotations) {\n            return;\n        }\n        const { current: layer } = layerElement;\n        if (!layer) {\n            return;\n        }\n        const clonedViewport = viewport.clone({\n            dontFlip: true\n        });\n        const annotationLayerParameters = {\n            accessibilityManager: null,\n            annotationCanvasMap: null,\n            div: layer,\n            l10n: null,\n            page,\n            viewport: clonedViewport\n        };\n        const renderParameters = {\n            annotations,\n            annotationStorage: pdf.annotationStorage,\n            div: layer,\n            // See https://github.com/mozilla/pdf.js/issues/17029\n            downloadManager: null,\n            imageResourcesPath,\n            linkService,\n            page,\n            renderForms,\n            viewport: clonedViewport\n        };\n        layer.innerHTML = \"\";\n        try {\n            new _pdfjs_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].AnnotationLayer(annotationLayerParameters).render(renderParameters);\n            // Intentional immediate callback\n            onRenderSuccess();\n        } catch (error) {\n            onRenderError(error);\n        }\n        return ()=>{\n        // TODO: Cancel running task?\n        };\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(renderAnnotationLayer, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        annotations,\n        imageResourcesPath,\n        linkService,\n        page,\n        renderForms,\n        viewport\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"react-pdf__Page__annotations\", \"annotationLayer\"),\n        ref: layerElement\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvQW5ub3RhdGlvbkxheWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OzZEQUMwRDtBQUNIO0FBQy9CO0FBQ2U7QUFDVDtBQUNFO0FBQ3VDO0FBQ1I7QUFDTjtBQUNGO0FBQ3hDLFNBQVNhO0lBQ3BCLE1BQU1DLGtCQUFrQkwsK0VBQWtCQTtJQUMxQyxNQUFNTSxjQUFjTCwyRUFBY0E7SUFDbENKLDBEQUFTQSxDQUFDUyxhQUFhO0lBQ3ZCLE1BQU1DLGNBQWNDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0osa0JBQWtCQztJQUN0RSxNQUFNLEVBQUVJLGtCQUFrQixFQUFFQyxXQUFXLEVBQUVDLHVCQUF1QkMsMEJBQTBCLEVBQUVDLHlCQUF5QkMsNEJBQTRCLEVBQUVDLDhCQUE4QkMsaUNBQWlDLEVBQUVDLGdDQUFnQ0MsbUNBQW1DLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxXQUFXLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxDQUFDLEVBQUcsR0FBR2pCO0lBQ3hVViwwREFBU0EsQ0FBQ3dCLEtBQUs7SUFDZnhCLDBEQUFTQSxDQUFDdUIsTUFBTTtJQUNoQnZCLDBEQUFTQSxDQUFDYyxhQUFhO0lBQ3ZCLE1BQU0sQ0FBQ2Msa0JBQWtCQyxvQkFBb0IsR0FBR3hCLHdFQUFXQTtJQUMzRCxNQUFNLEVBQUV5QixPQUFPQyxXQUFXLEVBQUVDLE9BQU9DLGdCQUFnQixFQUFFLEdBQUdMO0lBQ3hELE1BQU1NLGVBQWVyQyw2Q0FBTUEsQ0FBQztJQUM1Qkksb0NBQU9BLENBQUNrQyxTQUFTQyxPQUFPQyxnQkFBZ0IsQ0FBQ0MsU0FBU0MsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQyxpQ0FBaUMsUUFBUSxHQUFHO0lBQ3JILFNBQVNDO1FBQ0wsSUFBSSxDQUFDVixhQUFhO1lBQ2QsK0NBQStDO1lBQy9DO1FBQ0o7UUFDQSxJQUFJYiw4QkFBOEI7WUFD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O1FBQUVtRixXQUFXOUUsZ0RBQUlBLENBQUMsZ0NBQWdDO1FBQW9CK0UsS0FBSzVDO0lBQWE7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFnZS9Bbm5vdGF0aW9uTGF5ZXIuanM/N2RjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgbWFrZUNhbmNlbGxhYmxlIGZyb20gJ21ha2UtY2FuY2VsbGFibGUtcHJvbWlzZSc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgcGRmanMgZnJvbSAnLi4vcGRmanMuanMnO1xuaW1wb3J0IHVzZURvY3VtZW50Q29udGV4dCBmcm9tICcuLi9zaGFyZWQvaG9va3MvdXNlRG9jdW1lbnRDb250ZXh0LmpzJztcbmltcG9ydCB1c2VQYWdlQ29udGV4dCBmcm9tICcuLi9zaGFyZWQvaG9va3MvdXNlUGFnZUNvbnRleHQuanMnO1xuaW1wb3J0IHVzZVJlc29sdmVyIGZyb20gJy4uL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qcyc7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzayB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbm5vdGF0aW9uTGF5ZXIoKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gdXNlRG9jdW1lbnRDb250ZXh0KCk7XG4gICAgY29uc3QgcGFnZUNvbnRleHQgPSB1c2VQYWdlQ29udGV4dCgpO1xuICAgIGludmFyaWFudChwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9jdW1lbnRDb250ZXh0KSwgcGFnZUNvbnRleHQpO1xuICAgIGNvbnN0IHsgaW1hZ2VSZXNvdXJjZXNQYXRoLCBsaW5rU2VydmljZSwgb25HZXRBbm5vdGF0aW9uc0Vycm9yOiBvbkdldEFubm90YXRpb25zRXJyb3JQcm9wcywgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3M6IG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzUHJvcHMsIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3I6IG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcywgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzOiBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcywgcGFnZSwgcGRmLCByZW5kZXJGb3Jtcywgcm90YXRlLCBzY2FsZSA9IDEsIH0gPSBtZXJnZWRQcm9wcztcbiAgICBpbnZhcmlhbnQocGRmLCAnQXR0ZW1wdGVkIHRvIGxvYWQgcGFnZSBhbm5vdGF0aW9ucywgYnV0IG5vIGRvY3VtZW50IHdhcyBzcGVjaWZpZWQuIFdyYXAgPFBhZ2UgLz4gaW4gYSA8RG9jdW1lbnQgLz4gb3IgcGFzcyBleHBsaWNpdCBgcGRmYCBwcm9wLicpO1xuICAgIGludmFyaWFudChwYWdlLCAnQXR0ZW1wdGVkIHRvIGxvYWQgcGFnZSBhbm5vdGF0aW9ucywgYnV0IG5vIHBhZ2Ugd2FzIHNwZWNpZmllZC4nKTtcbiAgICBpbnZhcmlhbnQobGlua1NlcnZpY2UsICdBdHRlbXB0ZWQgdG8gbG9hZCBwYWdlIGFubm90YXRpb25zLCBidXQgbm8gbGlua1NlcnZpY2Ugd2FzIHNwZWNpZmllZC4nKTtcbiAgICBjb25zdCBbYW5ub3RhdGlvbnNTdGF0ZSwgYW5ub3RhdGlvbnNEaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IGFubm90YXRpb25zLCBlcnJvcjogYW5ub3RhdGlvbnNFcnJvciB9ID0gYW5ub3RhdGlvbnNTdGF0ZTtcbiAgICBjb25zdCBsYXllckVsZW1lbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgd2FybmluZyhwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5nZXRQcm9wZXJ0eVZhbHVlKCctLXJlYWN0LXBkZi1hbm5vdGF0aW9uLWxheWVyJyksIDEwKSA9PT0gMSwgJ0Fubm90YXRpb25MYXllciBzdHlsZXMgbm90IGZvdW5kLiBSZWFkIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS93b2p0ZWttYWovcmVhY3QtcGRmI3N1cHBvcnQtZm9yLWFubm90YXRpb25zJyk7XG4gICAgZnVuY3Rpb24gb25Mb2FkU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcykge1xuICAgICAgICAgICAgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3NQcm9wcyhhbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Mb2FkRXJyb3IoKSB7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnNFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBhbm5vdGF0aW9uc0Vycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25HZXRBbm5vdGF0aW9uc0Vycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzKGFubm90YXRpb25zRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0QW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIGFubm90YXRpb25zRGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVzZXRBbm5vdGF0aW9ucywgW2Fubm90YXRpb25zRGlzcGF0Y2gsIHBhZ2VdKTtcbiAgICBmdW5jdGlvbiBsb2FkQW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gbWFrZUNhbmNlbGxhYmxlKHBhZ2UuZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0QW5ub3RhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGFubm90YXRpb25zRGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0QW5ub3RhdGlvbnMgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uc0Rpc3BhdGNoKHsgdHlwZTogJ1JFSkVDVCcsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbFJ1bm5pbmdUYXNrKHJ1bm5pbmdUYXNrKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KGxvYWRBbm5vdGF0aW9ucywgW2Fubm90YXRpb25zRGlzcGF0Y2gsIHBhZ2UsIHJlbmRlckZvcm1zXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGFubm90YXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvbkxvYWRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZFN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFthbm5vdGF0aW9uc10pO1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3NQcm9wcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVuZGVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgYCR7ZXJyb3J9YCk7XG4gICAgICAgIGlmIChvblJlbmRlckFubm90YXRpb25MYXllckVycm9yUHJvcHMpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcyhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSB1c2VNZW1vKCgpID0+IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZSwgcm90YXRpb246IHJvdGF0ZSB9KSwgW3BhZ2UsIHJvdGF0ZSwgc2NhbGVdKTtcbiAgICBmdW5jdGlvbiByZW5kZXJBbm5vdGF0aW9uTGF5ZXIoKSB7XG4gICAgICAgIGlmICghcGRmIHx8ICFwYWdlIHx8ICFsaW5rU2VydmljZSB8fCAhYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGxheWVyIH0gPSBsYXllckVsZW1lbnQ7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9uZWRWaWV3cG9ydCA9IHZpZXdwb3J0LmNsb25lKHsgZG9udEZsaXA6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25MYXllclBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcjogbnVsbCwgLy8gVE9ETzogSW1wbGVtZW50IHRoaXNcbiAgICAgICAgICAgIGFubm90YXRpb25DYW52YXNNYXA6IG51bGwsIC8vIFRPRE86IEltcGxlbWVudCB0aGlzXG4gICAgICAgICAgICBkaXY6IGxheWVyLFxuICAgICAgICAgICAgbDEwbjogbnVsbCwgLy8gVE9ETzogSW1wbGVtZW50IHRoaXNcbiAgICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgICB2aWV3cG9ydDogY2xvbmVkVmlld3BvcnQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbmRlclBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwZGYuYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICAgICAgICBkaXY6IGxheWVyLFxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3BkZi5qcy9pc3N1ZXMvMTcwMjlcbiAgICAgICAgICAgIGRvd25sb2FkTWFuYWdlcjogbnVsbCxcbiAgICAgICAgICAgIGltYWdlUmVzb3VyY2VzUGF0aCxcbiAgICAgICAgICAgIGxpbmtTZXJ2aWNlLFxuICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgIHJlbmRlckZvcm1zLFxuICAgICAgICAgICAgdmlld3BvcnQ6IGNsb25lZFZpZXdwb3J0LFxuICAgICAgICB9O1xuICAgICAgICBsYXllci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBwZGZqcy5Bbm5vdGF0aW9uTGF5ZXIoYW5ub3RhdGlvbkxheWVyUGFyYW1ldGVycykucmVuZGVyKHJlbmRlclBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgLy8gSW50ZW50aW9uYWwgaW1tZWRpYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICBvblJlbmRlclN1Y2Nlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDYW5jZWwgcnVubmluZyB0YXNrP1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVuZGVyQW5ub3RhdGlvbkxheWVyLCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFthbm5vdGF0aW9ucywgaW1hZ2VSZXNvdXJjZXNQYXRoLCBsaW5rU2VydmljZSwgcGFnZSwgcmVuZGVyRm9ybXMsIHZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdyZWFjdC1wZGZfX1BhZ2VfX2Fubm90YXRpb25zJywgJ2Fubm90YXRpb25MYXllcicpLCByZWY6IGxheWVyRWxlbWVudCB9KSk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwibWFrZUNhbmNlbGxhYmxlIiwiY2xzeCIsImludmFyaWFudCIsIndhcm5pbmciLCJwZGZqcyIsInVzZURvY3VtZW50Q29udGV4dCIsInVzZVBhZ2VDb250ZXh0IiwidXNlUmVzb2x2ZXIiLCJjYW5jZWxSdW5uaW5nVGFzayIsIkFubm90YXRpb25MYXllciIsImRvY3VtZW50Q29udGV4dCIsInBhZ2VDb250ZXh0IiwibWVyZ2VkUHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbWFnZVJlc291cmNlc1BhdGgiLCJsaW5rU2VydmljZSIsIm9uR2V0QW5ub3RhdGlvbnNFcnJvciIsIm9uR2V0QW5ub3RhdGlvbnNFcnJvclByb3BzIiwib25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3MiLCJvbkdldEFubm90YXRpb25zU3VjY2Vzc1Byb3BzIiwib25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvciIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3JQcm9wcyIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2VzcyIsIm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2Vzc1Byb3BzIiwicGFnZSIsInBkZiIsInJlbmRlckZvcm1zIiwicm90YXRlIiwic2NhbGUiLCJhbm5vdGF0aW9uc1N0YXRlIiwiYW5ub3RhdGlvbnNEaXNwYXRjaCIsInZhbHVlIiwiYW5ub3RhdGlvbnMiLCJlcnJvciIsImFubm90YXRpb25zRXJyb3IiLCJsYXllckVsZW1lbnQiLCJwYXJzZUludCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJkb2N1bWVudCIsImJvZHkiLCJnZXRQcm9wZXJ0eVZhbHVlIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZEVycm9yIiwidG9TdHJpbmciLCJyZXNldEFubm90YXRpb25zIiwidHlwZSIsImxvYWRBbm5vdGF0aW9ucyIsImNhbmNlbGxhYmxlIiwiZ2V0QW5ub3RhdGlvbnMiLCJydW5uaW5nVGFzayIsInByb21pc2UiLCJ0aGVuIiwibmV4dEFubm90YXRpb25zIiwiY2F0Y2giLCJ1bmRlZmluZWQiLCJvblJlbmRlclN1Y2Nlc3MiLCJvblJlbmRlckVycm9yIiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInJvdGF0aW9uIiwicmVuZGVyQW5ub3RhdGlvbkxheWVyIiwiY3VycmVudCIsImxheWVyIiwiY2xvbmVkVmlld3BvcnQiLCJjbG9uZSIsImRvbnRGbGlwIiwiYW5ub3RhdGlvbkxheWVyUGFyYW1ldGVycyIsImFjY2Vzc2liaWxpdHlNYW5hZ2VyIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsImRpdiIsImwxMG4iLCJyZW5kZXJQYXJhbWV0ZXJzIiwiYW5ub3RhdGlvblN0b3JhZ2UiLCJkb3dubG9hZE1hbmFnZXIiLCJpbm5lckhUTUwiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/PageCanvas.js":
/*!************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/PageCanvas.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var merge_refs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! merge-refs */ \"(ssr)/./node_modules/merge-refs/dist/esm/index.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _StructTree_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../StructTree.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/StructTree.js\");\n/* harmony import */ var _shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\nconst ANNOTATION_MODE = _pdfjs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].AnnotationMode;\nfunction PageCanvas(props) {\n    const pageContext = (0,_shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pageContext, \"Unable to find Page context.\");\n    const mergedProps = Object.assign(Object.assign({}, pageContext), props);\n    const { _className, canvasBackground, devicePixelRatio = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.getDevicePixelRatio)(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale } = mergedProps;\n    const { canvasRef } = props;\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(page, \"Attempted to render page canvas, but no page was specified.\");\n    const canvasElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    /**\n     * Called when a page is rendered successfully.\n     */ function onRenderSuccess() {\n        if (!page) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onRenderSuccessProps) {\n            onRenderSuccessProps((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.makePageCallback)(page, scale));\n        }\n    }\n    /**\n     * Called when a page fails to render.\n     */ function onRenderError(error) {\n        if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.isCancelException)(error)) {\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_2__(false, error.toString());\n        if (onRenderErrorProps) {\n            onRenderErrorProps(error);\n        }\n    }\n    const renderViewport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>page.getViewport({\n            scale: scale * devicePixelRatio,\n            rotation: rotate\n        }), [\n        devicePixelRatio,\n        page,\n        rotate,\n        scale\n    ]);\n    const viewport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function drawPageOnCanvas() {\n        if (!page) {\n            return;\n        }\n        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n        page.cleanup();\n        const { current: canvas } = canvasElement;\n        if (!canvas) {\n            return;\n        }\n        canvas.width = renderViewport.width;\n        canvas.height = renderViewport.height;\n        canvas.style.width = `${Math.floor(viewport.width)}px`;\n        canvas.style.height = `${Math.floor(viewport.height)}px`;\n        canvas.style.visibility = \"hidden\";\n        const renderContext = {\n            annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,\n            canvasContext: canvas.getContext(\"2d\", {\n                alpha: false\n            }),\n            viewport: renderViewport\n        };\n        if (canvasBackground) {\n            renderContext.background = canvasBackground;\n        }\n        const cancellable = page.render(renderContext);\n        const runningTask = cancellable;\n        cancellable.promise.then(()=>{\n            canvas.style.visibility = \"\";\n            onRenderSuccess();\n        }).catch(onRenderError);\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(drawPageOnCanvas, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        canvasBackground,\n        canvasElement,\n        devicePixelRatio,\n        page,\n        renderForms,\n        renderViewport,\n        viewport\n    ]);\n    const cleanup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const { current: canvas } = canvasElement;\n        /**\n         * Zeroing the width and height cause most browsers to release graphics\n         * resources immediately, which can greatly reduce memory consumption.\n         */ if (canvas) {\n            canvas.width = 0;\n            canvas.height = 0;\n        }\n    }, [\n        canvasElement\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>cleanup, [\n        cleanup\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\", {\n        className: `${_className}__canvas`,\n        dir: \"ltr\",\n        ref: (0,merge_refs__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(canvasRef, canvasElement),\n        style: {\n            display: \"block\",\n            userSelect: \"none\"\n        }\n    }, renderTextLayer ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_StructTree_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], null) : null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvUGFnZUNhbnZhcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7NkRBQ3VFO0FBQ3BDO0FBQ0k7QUFDVDtBQUNFO0FBQ1U7QUFDcUI7QUFDbUQ7QUFDbEgsTUFBTWUsa0JBQWtCUCxpREFBS0EsQ0FBQ1EsY0FBYztBQUM3QixTQUFTQyxXQUFXQyxLQUFLO0lBQ3BDLE1BQU1DLGNBQWNULDJFQUFjQTtJQUNsQ0osMERBQVNBLENBQUNhLGFBQWE7SUFDdkIsTUFBTUMsY0FBY0MsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCxjQUFjRDtJQUNsRSxNQUFNLEVBQUVLLFVBQVUsRUFBRUMsZ0JBQWdCLEVBQUVDLG1CQUFtQmIscUVBQW1CQSxFQUFFLEVBQUVjLGVBQWVDLGtCQUFrQixFQUFFQyxpQkFBaUJDLG9CQUFvQixFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsZUFBZSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRyxHQUFHZDtJQUNqTixNQUFNLEVBQUVlLFNBQVMsRUFBRSxHQUFHakI7SUFDdEJaLDBEQUFTQSxDQUFDd0IsTUFBTTtJQUNoQixNQUFNTSxnQkFBZ0JoQyw2Q0FBTUEsQ0FBQztJQUM3Qjs7S0FFQyxHQUNELFNBQVN3QjtRQUNMLElBQUksQ0FBQ0UsTUFBTTtZQUNQLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsSUFBSUQsc0JBQXNCO1lBQ3RCQSxxQkFBcUJmLGtFQUFnQkEsQ0FBQ2dCLE1BQU1JO1FBQ2hEO0lBQ0o7SUFDQTs7S0FFQyxHQUNELFNBQVNSLGNBQWNXLEtBQUs7UUFDeEIsSUFBSXhCLG1FQUFpQkEsQ0FBQ3dCLFFBQVE7WUFDMUI7UUFDSjtRQUNBOUIsb0NBQU9BLENBQUMsT0FBTzhCLE1BQU1DLFFBQVE7UUFDN0IsSUFBSVgsb0JBQW9CO1lBQ3BCQSxtQkFBbUJVO1FBQ3ZCO0lBQ0o7SUFDQSxNQUFNRSxpQkFBaUJwQyw4Q0FBT0EsQ0FBQyxJQUFNMkIsS0FBS1UsV0FBVyxDQUFDO1lBQUVOLE9BQU9BLFFBQVFUO1lBQWtCZ0IsVUFBVVI7UUFBTyxJQUFJO1FBQUNSO1FBQWtCSztRQUFNRztRQUFRQztLQUFNO0lBQ3JKLE1BQU1RLFdBQVd2Qyw4Q0FBT0EsQ0FBQyxJQUFNMkIsS0FBS1UsV0FBVyxDQUFDO1lBQUVOO1lBQU9PLFVBQVVSO1FBQU8sSUFBSTtRQUFDSDtRQUFNRztRQUFRQztLQUFNO0lBQ25HLFNBQVNTO1FBQ0wsSUFBSSxDQUFDYixNQUFNO1lBQ1A7UUFDSjtRQUNBLDBGQUEwRjtRQUMxRkEsS0FBS2MsT0FBTztRQUNaLE1BQU0sRUFBRUMsU0FBU0MsTUFBTSxFQUFFLEdBQUdWO1FBQzVCLElBQUksQ0FBQ1UsUUFBUTtZQUNUO1FBQ0o7UUFDQUEsT0FBT0MsS0FBSyxHQUFHUixlQUFlUSxLQUFLO1FBQ25DRCxPQUFPRSxNQUFNLEdBQUdULGVBQWVTLE1BQU07UUFDckNGLE9BQU9HLEtBQUssQ0FBQ0YsS0FBSyxHQUFHLENBQUMsRUFBRUcsS0FBS0MsS0FBSyxDQUFDVCxTQUFTSyxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQ3RERCxPQUFPRyxLQUFLLENBQUNELE1BQU0sR0FBRyxDQUFDLEVBQUVFLEtBQUtDLEtBQUssQ0FBQ1QsU0FBU00sTUFBTSxFQUFFLEVBQUUsQ0FBQztRQUN4REYsT0FBT0csS0FBSyxDQUFDRyxVQUFVLEdBQUc7UUFDMUIsTUFBTUMsZ0JBQWdCO1lBQ2xCQyxnQkFBZ0J2QixjQUFjaEIsZ0JBQWdCd0MsWUFBWSxHQUFHeEMsZ0JBQWdCeUMsTUFBTTtZQUNuRkMsZUFBZVgsT0FBT1ksVUFBVSxDQUFDLE1BQU07Z0JBQUVDLE9BQU87WUFBTTtZQUN0RGpCLFVBQVVIO1FBQ2Q7UUFDQSxJQUFJZixrQkFBa0I7WUFDbEI2QixjQUFjTyxVQUFVLEdBQUdwQztRQUMvQjtRQUNBLE1BQU1xQyxjQUFjL0IsS0FBS2dDLE1BQU0sQ0FBQ1Q7UUFDaEMsTUFBTVUsY0FBY0Y7UUFDcEJBLFlBQVlHLE9BQU8sQ0FDZEMsSUFBSSxDQUFDO1lBQ05uQixPQUFPRyxLQUFLLENBQUNHLFVBQVUsR0FBRztZQUMxQnhCO1FBQ0osR0FDS3NDLEtBQUssQ0FBQ3hDO1FBQ1gsT0FBTyxJQUFNZixtRUFBaUJBLENBQUNvRDtJQUNuQztJQUNBN0QsZ0RBQVNBLENBQUN5QyxrQkFDVixtRUFBbUU7SUFDbkUsdURBQXVEO0lBQ3ZEO1FBQ0luQjtRQUNBWTtRQUNBWDtRQUNBSztRQUNBQztRQUNBUTtRQUNBRztLQUNIO0lBQ0QsTUFBTUUsVUFBVTNDLGtEQUFXQSxDQUFDO1FBQ3hCLE1BQU0sRUFBRTRDLFNBQVNDLE1BQU0sRUFBRSxHQUFHVjtRQUM1Qjs7O1NBR0MsR0FDRCxJQUFJVSxRQUFRO1lBQ1JBLE9BQU9DLEtBQUssR0FBRztZQUNmRCxPQUFPRSxNQUFNLEdBQUc7UUFDcEI7SUFDSixHQUFHO1FBQUNaO0tBQWM7SUFDbEJsQyxnREFBU0EsQ0FBQyxJQUFNMEMsU0FBUztRQUFDQTtLQUFRO0lBQ2xDLHFCQUFRNUMsZ0RBQW1CLENBQUMsVUFBVTtRQUFFb0UsV0FBVyxDQUFDLEVBQUU3QyxXQUFXLFFBQVEsQ0FBQztRQUFFOEMsS0FBSztRQUFPQyxLQUFLakUsc0RBQVNBLENBQUM4QixXQUFXQztRQUFnQmEsT0FBTztZQUNqSXNCLFNBQVM7WUFDVEMsWUFBWTtRQUNoQjtJQUFFLEdBQUd4QyxnQ0FBa0JoQyxnREFBbUIsQ0FBQ1Msc0RBQVVBLEVBQUUsUUFBUTtBQUN2RSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9QYWdlL1BhZ2VDYW52YXMuanM/NWI2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1lcmdlUmVmcyBmcm9tICdtZXJnZS1yZWZzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgcGRmanMgZnJvbSAnLi4vcGRmanMuanMnO1xuaW1wb3J0IFN0cnVjdFRyZWUgZnJvbSAnLi4vU3RydWN0VHJlZS5qcyc7XG5pbXBvcnQgdXNlUGFnZUNvbnRleHQgZnJvbSAnLi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzJztcbmltcG9ydCB7IGNhbmNlbFJ1bm5pbmdUYXNrLCBnZXREZXZpY2VQaXhlbFJhdGlvLCBpc0NhbmNlbEV4Y2VwdGlvbiwgbWFrZVBhZ2VDYWxsYmFjaywgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuY29uc3QgQU5OT1RBVElPTl9NT0RFID0gcGRmanMuQW5ub3RhdGlvbk1vZGU7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlQ2FudmFzKHByb3BzKSB7XG4gICAgY29uc3QgcGFnZUNvbnRleHQgPSB1c2VQYWdlQ29udGV4dCgpO1xuICAgIGludmFyaWFudChwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFnZUNvbnRleHQpLCBwcm9wcyk7XG4gICAgY29uc3QgeyBfY2xhc3NOYW1lLCBjYW52YXNCYWNrZ3JvdW5kLCBkZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpLCBvblJlbmRlckVycm9yOiBvblJlbmRlckVycm9yUHJvcHMsIG9uUmVuZGVyU3VjY2Vzczogb25SZW5kZXJTdWNjZXNzUHJvcHMsIHBhZ2UsIHJlbmRlckZvcm1zLCByZW5kZXJUZXh0TGF5ZXIsIHJvdGF0ZSwgc2NhbGUsIH0gPSBtZXJnZWRQcm9wcztcbiAgICBjb25zdCB7IGNhbnZhc1JlZiB9ID0gcHJvcHM7XG4gICAgaW52YXJpYW50KHBhZ2UsICdBdHRlbXB0ZWQgdG8gcmVuZGVyIHBhZ2UgY2FudmFzLCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIGlzIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblJlbmRlclN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25SZW5kZXJTdWNjZXNzUHJvcHMpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyU3VjY2Vzc1Byb3BzKG1ha2VQYWdlQ2FsbGJhY2socGFnZSwgc2NhbGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgZmFpbHMgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQ2FuY2VsRXhjZXB0aW9uKGVycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25SZW5kZXJFcnJvclByb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckVycm9yUHJvcHMoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclZpZXdwb3J0ID0gdXNlTWVtbygoKSA9PiBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IHNjYWxlICogZGV2aWNlUGl4ZWxSYXRpbywgcm90YXRpb246IHJvdGF0ZSB9KSwgW2RldmljZVBpeGVsUmF0aW8sIHBhZ2UsIHJvdGF0ZSwgc2NhbGVdKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHVzZU1lbW8oKCkgPT4gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlLCByb3RhdGlvbjogcm90YXRlIH0pLCBbcGFnZSwgcm90YXRlLCBzY2FsZV0pO1xuICAgIGZ1bmN0aW9uIGRyYXdQYWdlT25DYW52YXMoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZXMgdGhlIGNhbnZhcyB3aWxsIGJlIHJlLXJlbmRlcmVkIGZyb20gc2NyYXRjaC4gT3RoZXJ3aXNlIGFsbCBmb3JtIGRhdGEgd2lsbCBzdGF5LlxuICAgICAgICBwYWdlLmNsZWFudXAoKTtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiBjYW52YXMgfSA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gcmVuZGVyVmlld3BvcnQud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZW5kZXJWaWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke01hdGguZmxvb3Iodmlld3BvcnQud2lkdGgpfXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke01hdGguZmxvb3Iodmlld3BvcnQuaGVpZ2h0KX1weGA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbnN0IHJlbmRlckNvbnRleHQgPSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uTW9kZTogcmVuZGVyRm9ybXMgPyBBTk5PVEFUSU9OX01PREUuRU5BQkxFX0ZPUk1TIDogQU5OT1RBVElPTl9NT0RFLkVOQUJMRSxcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IGZhbHNlIH0pLFxuICAgICAgICAgICAgdmlld3BvcnQ6IHJlbmRlclZpZXdwb3J0LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2FudmFzQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgcmVuZGVyQ29udGV4dC5iYWNrZ3JvdW5kID0gY2FudmFzQmFja2dyb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9IHBhZ2UucmVuZGVyKHJlbmRlckNvbnRleHQpO1xuICAgICAgICBjb25zdCBydW5uaW5nVGFzayA9IGNhbmNlbGxhYmxlO1xuICAgICAgICBjYW5jZWxsYWJsZS5wcm9taXNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICAgICAgb25SZW5kZXJTdWNjZXNzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gob25SZW5kZXJFcnJvcik7XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxSdW5uaW5nVGFzayhydW5uaW5nVGFzayk7XG4gICAgfVxuICAgIHVzZUVmZmVjdChkcmF3UGFnZU9uQ2FudmFzLCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAgY2FudmFzQmFja2dyb3VuZCxcbiAgICAgICAgY2FudmFzRWxlbWVudCxcbiAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgcGFnZSxcbiAgICAgICAgcmVuZGVyRm9ybXMsXG4gICAgICAgIHJlbmRlclZpZXdwb3J0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICBdKTtcbiAgICBjb25zdCBjbGVhbnVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGNhbnZhcyB9ID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFplcm9pbmcgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2F1c2UgbW9zdCBicm93c2VycyB0byByZWxlYXNlIGdyYXBoaWNzXG4gICAgICAgICAqIHJlc291cmNlcyBpbW1lZGlhdGVseSwgd2hpY2ggY2FuIGdyZWF0bHkgcmVkdWNlIG1lbW9yeSBjb25zdW1wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgIH0sIFtjYW52YXNFbGVtZW50XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IGNsZWFudXAsIFtjbGVhbnVwXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgY2xhc3NOYW1lOiBgJHtfY2xhc3NOYW1lfV9fY2FudmFzYCwgZGlyOiBcImx0clwiLCByZWY6IG1lcmdlUmVmcyhjYW52YXNSZWYsIGNhbnZhc0VsZW1lbnQpLCBzdHlsZToge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgfSB9LCByZW5kZXJUZXh0TGF5ZXIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFN0cnVjdFRyZWUsIG51bGwpIDogbnVsbCkpO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwibWVyZ2VSZWZzIiwiaW52YXJpYW50Iiwid2FybmluZyIsInBkZmpzIiwiU3RydWN0VHJlZSIsInVzZVBhZ2VDb250ZXh0IiwiY2FuY2VsUnVubmluZ1Rhc2siLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiaXNDYW5jZWxFeGNlcHRpb24iLCJtYWtlUGFnZUNhbGxiYWNrIiwiQU5OT1RBVElPTl9NT0RFIiwiQW5ub3RhdGlvbk1vZGUiLCJQYWdlQ2FudmFzIiwicHJvcHMiLCJwYWdlQ29udGV4dCIsIm1lcmdlZFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwiX2NsYXNzTmFtZSIsImNhbnZhc0JhY2tncm91bmQiLCJkZXZpY2VQaXhlbFJhdGlvIiwib25SZW5kZXJFcnJvciIsIm9uUmVuZGVyRXJyb3JQcm9wcyIsIm9uUmVuZGVyU3VjY2VzcyIsIm9uUmVuZGVyU3VjY2Vzc1Byb3BzIiwicGFnZSIsInJlbmRlckZvcm1zIiwicmVuZGVyVGV4dExheWVyIiwicm90YXRlIiwic2NhbGUiLCJjYW52YXNSZWYiLCJjYW52YXNFbGVtZW50IiwiZXJyb3IiLCJ0b1N0cmluZyIsInJlbmRlclZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJyb3RhdGlvbiIsInZpZXdwb3J0IiwiZHJhd1BhZ2VPbkNhbnZhcyIsImNsZWFudXAiLCJjdXJyZW50IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJzdHlsZSIsIk1hdGgiLCJmbG9vciIsInZpc2liaWxpdHkiLCJyZW5kZXJDb250ZXh0IiwiYW5ub3RhdGlvbk1vZGUiLCJFTkFCTEVfRk9STVMiLCJFTkFCTEUiLCJjYW52YXNDb250ZXh0IiwiZ2V0Q29udGV4dCIsImFscGhhIiwiYmFja2dyb3VuZCIsImNhbmNlbGxhYmxlIiwicmVuZGVyIiwicnVubmluZ1Rhc2siLCJwcm9taXNlIiwidGhlbiIsImNhdGNoIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRpciIsInJlZiIsImRpc3BsYXkiLCJ1c2VyU2VsZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/PageCanvas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/PageSVG.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/PageSVG.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageSVG)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n\n\n\n\n\n\n\n\nfunction PageSVG() {\n    const pageContext = (0,_shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pageContext, \"Unable to find Page context.\");\n    const { _className, onRenderSuccess: onRenderSuccessProps, onRenderError: onRenderErrorProps, page, rotate, scale } = pageContext;\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(page, \"Attempted to render page SVG, but no page was specified.\");\n    const [svgState, svgDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const { value: svg, error: svgError } = svgState;\n    /**\n     * Called when a page is rendered successfully\n     */ function onRenderSuccess() {\n        if (!page) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onRenderSuccessProps) {\n            onRenderSuccessProps((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.makePageCallback)(page, scale));\n        }\n    }\n    /**\n     * Called when a page fails to render\n     */ function onRenderError() {\n        if (!svgError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if ((0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.isCancelException)(svgError)) {\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_2__(false, svgError.toString());\n        if (onRenderErrorProps) {\n            onRenderErrorProps(svgError);\n        }\n    }\n    const viewport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function resetSVG() {\n        svgDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetSVG, [\n        page,\n        svgDispatch,\n        viewport\n    ]);\n    function renderSVG() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(page.getOperatorList());\n        cancellable.promise.then((operatorList)=>{\n            const svgGfx = new _pdfjs_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SVGGraphics(page.commonObjs, page.objs);\n            svgGfx.getSVG(operatorList, viewport).then((nextSvg)=>{\n                // See https://github.com/mozilla/pdf.js/issues/16745\n                if (!(nextSvg instanceof SVGElement)) {\n                    throw new Error(\"getSVG returned unexpected result.\");\n                }\n                svgDispatch({\n                    type: \"RESOLVE\",\n                    value: nextSvg\n                });\n            }).catch((error)=>{\n                svgDispatch({\n                    type: \"REJECT\",\n                    error\n                });\n            });\n        }).catch((error)=>{\n            svgDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_5__.cancelRunningTask)(cancellable);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(renderSVG, [\n        page,\n        svgDispatch,\n        viewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (svg === undefined) {\n            return;\n        }\n        if (svg === false) {\n            onRenderError();\n            return;\n        }\n        onRenderSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        svg\n    ]);\n    function drawPageOnContainer(element) {\n        if (!element || !svg) {\n            return;\n        }\n        // Append SVG element to the main container, if this hasn't been done already\n        if (!element.firstElementChild) {\n            element.appendChild(svg);\n        }\n        const { width, height } = viewport;\n        svg.setAttribute(\"width\", `${width}`);\n        svg.setAttribute(\"height\", `${height}`);\n    }\n    const { width, height } = viewport;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: `${_className}__svg`,\n        // Note: This cannot be shortened, as we need this function to be called with each render.\n        ref: (ref)=>drawPageOnContainer(ref),\n        style: {\n            display: \"block\",\n            backgroundColor: \"white\",\n            overflow: \"hidden\",\n            width,\n            height,\n            userSelect: \"none\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvUGFnZVNWRy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBa0Q7QUFDSztBQUNoQjtBQUNUO0FBQ0U7QUFDK0I7QUFDTjtBQUNtQztBQUM3RSxTQUFTWTtJQUNwQixNQUFNQyxjQUFjTiwyRUFBY0E7SUFDbENILDBEQUFTQSxDQUFDUyxhQUFhO0lBQ3ZCLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxpQkFBaUJDLG9CQUFvQixFQUFFQyxlQUFlQyxrQkFBa0IsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRyxHQUFHUjtJQUN2SFQsMERBQVNBLENBQUNlLE1BQU07SUFDaEIsTUFBTSxDQUFDRyxVQUFVQyxZQUFZLEdBQUdmLHdFQUFXQTtJQUMzQyxNQUFNLEVBQUVnQixPQUFPQyxHQUFHLEVBQUVDLE9BQU9DLFFBQVEsRUFBRSxHQUFHTDtJQUN4Qzs7S0FFQyxHQUNELFNBQVNQO1FBQ0wsSUFBSSxDQUFDSSxNQUFNO1lBQ1AsK0NBQStDO1lBQy9DO1FBQ0o7UUFDQSxJQUFJSCxzQkFBc0I7WUFDdEJBLHFCQUFxQkwsa0VBQWdCQSxDQUFDUSxNQUFNRTtRQUNoRDtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTSjtRQUNMLElBQUksQ0FBQ1UsVUFBVTtZQUNYLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsSUFBSWpCLG1FQUFpQkEsQ0FBQ2lCLFdBQVc7WUFDN0I7UUFDSjtRQUNBdEIsb0NBQU9BLENBQUMsT0FBT3NCLFNBQVNDLFFBQVE7UUFDaEMsSUFBSVYsb0JBQW9CO1lBQ3BCQSxtQkFBbUJTO1FBQ3ZCO0lBQ0o7SUFDQSxNQUFNRSxXQUFXM0IsOENBQU9BLENBQUMsSUFBTWlCLEtBQUtXLFdBQVcsQ0FBQztZQUFFVDtZQUFPVSxVQUFVWDtRQUFPLElBQUk7UUFBQ0Q7UUFBTUM7UUFBUUM7S0FBTTtJQUNuRyxTQUFTVztRQUNMVCxZQUFZO1lBQUVVLE1BQU07UUFBUTtJQUNoQztJQUNBaEMsZ0RBQVNBLENBQUMrQixVQUFVO1FBQUNiO1FBQU1JO1FBQWFNO0tBQVM7SUFDakQsU0FBU0s7UUFDTCxJQUFJLENBQUNmLE1BQU07WUFDUDtRQUNKO1FBQ0EsTUFBTWdCLGNBQWNoQyxvRUFBZUEsQ0FBQ2dCLEtBQUtpQixlQUFlO1FBQ3hERCxZQUFZRSxPQUFPLENBQ2RDLElBQUksQ0FBQyxDQUFDQztZQUNQLE1BQU1DLFNBQVMsSUFBSWxDLGlEQUFLQSxDQUFDbUMsV0FBVyxDQUFDdEIsS0FBS3VCLFVBQVUsRUFBRXZCLEtBQUt3QixJQUFJO1lBQy9ESCxPQUNLSSxNQUFNLENBQUNMLGNBQWNWLFVBQ3JCUyxJQUFJLENBQUMsQ0FBQ087Z0JBQ1AscURBQXFEO2dCQUNyRCxJQUFJLENBQUVBLENBQUFBLG1CQUFtQkMsVUFBUyxHQUFJO29CQUNsQyxNQUFNLElBQUlDLE1BQU07Z0JBQ3BCO2dCQUNBeEIsWUFBWTtvQkFBRVUsTUFBTTtvQkFBV1QsT0FBT3FCO2dCQUFRO1lBQ2xELEdBQ0tHLEtBQUssQ0FBQyxDQUFDdEI7Z0JBQ1JILFlBQVk7b0JBQUVVLE1BQU07b0JBQVVQO2dCQUFNO1lBQ3hDO1FBQ0osR0FDS3NCLEtBQUssQ0FBQyxDQUFDdEI7WUFDUkgsWUFBWTtnQkFBRVUsTUFBTTtnQkFBVVA7WUFBTTtRQUN4QztRQUNBLE9BQU8sSUFBTWpCLG1FQUFpQkEsQ0FBQzBCO0lBQ25DO0lBQ0FsQyxnREFBU0EsQ0FBQ2lDLFdBQVc7UUFBQ2Y7UUFBTUk7UUFBYU07S0FBUztJQUNsRDVCLGdEQUFTQSxDQUFDO1FBQ04sSUFBSXdCLFFBQVF3QixXQUFXO1lBQ25CO1FBQ0o7UUFDQSxJQUFJeEIsUUFBUSxPQUFPO1lBQ2ZSO1lBQ0E7UUFDSjtRQUNBRjtJQUNKLEdBQ0EsbUVBQW1FO0lBQ25FLHVEQUF1RDtJQUN2RDtRQUFDVTtLQUFJO0lBQ0wsU0FBU3lCLG9CQUFvQkMsT0FBTztRQUNoQyxJQUFJLENBQUNBLFdBQVcsQ0FBQzFCLEtBQUs7WUFDbEI7UUFDSjtRQUNBLDZFQUE2RTtRQUM3RSxJQUFJLENBQUMwQixRQUFRQyxpQkFBaUIsRUFBRTtZQUM1QkQsUUFBUUUsV0FBVyxDQUFDNUI7UUFDeEI7UUFDQSxNQUFNLEVBQUU2QixLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHMUI7UUFDMUJKLElBQUkrQixZQUFZLENBQUMsU0FBUyxDQUFDLEVBQUVGLE1BQU0sQ0FBQztRQUNwQzdCLElBQUkrQixZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUVELE9BQU8sQ0FBQztJQUMxQztJQUNBLE1BQU0sRUFBRUQsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBRzFCO0lBQzFCLHFCQUFRN0IsZ0RBQW1CLENBQUMsT0FBTztRQUFFMEQsV0FBVyxDQUFDLEVBQUU1QyxXQUFXLEtBQUssQ0FBQztRQUNoRSwwRkFBMEY7UUFDMUY2QyxLQUFLLENBQUNBLE1BQVFULG9CQUFvQlM7UUFBTUMsT0FBTztZQUMzQ0MsU0FBUztZQUNUQyxpQkFBaUI7WUFDakJDLFVBQVU7WUFDVlQ7WUFDQUM7WUFDQVMsWUFBWTtRQUNoQjtJQUFFO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFnZS9QYWdlU1ZHLmpzPzE3ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgcGRmanMgZnJvbSAnLi4vcGRmanMuanMnO1xuaW1wb3J0IHVzZVBhZ2VDb250ZXh0IGZyb20gJy4uL3NoYXJlZC9ob29rcy91c2VQYWdlQ29udGV4dC5qcyc7XG5pbXBvcnQgdXNlUmVzb2x2ZXIgZnJvbSAnLi4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzJztcbmltcG9ydCB7IGNhbmNlbFJ1bm5pbmdUYXNrLCBpc0NhbmNlbEV4Y2VwdGlvbiwgbWFrZVBhZ2VDYWxsYmFjayB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlU1ZHKCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZXh0ID0gdXNlUGFnZUNvbnRleHQoKTtcbiAgICBpbnZhcmlhbnQocGFnZUNvbnRleHQsICdVbmFibGUgdG8gZmluZCBQYWdlIGNvbnRleHQuJyk7XG4gICAgY29uc3QgeyBfY2xhc3NOYW1lLCBvblJlbmRlclN1Y2Nlc3M6IG9uUmVuZGVyU3VjY2Vzc1Byb3BzLCBvblJlbmRlckVycm9yOiBvblJlbmRlckVycm9yUHJvcHMsIHBhZ2UsIHJvdGF0ZSwgc2NhbGUsIH0gPSBwYWdlQ29udGV4dDtcbiAgICBpbnZhcmlhbnQocGFnZSwgJ0F0dGVtcHRlZCB0byByZW5kZXIgcGFnZSBTVkcsIGJ1dCBubyBwYWdlIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgY29uc3QgW3N2Z1N0YXRlLCBzdmdEaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHN2ZywgZXJyb3I6IHN2Z0Vycm9yIH0gPSBzdmdTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgcmVuZGVyZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25SZW5kZXJTdWNjZXNzKCkge1xuICAgICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmVuZGVyU3VjY2Vzc1Byb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlclN1Y2Nlc3NQcm9wcyhtYWtlUGFnZUNhbGxiYWNrKHBhZ2UsIHNjYWxlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIGZhaWxzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyRXJyb3IoKSB7XG4gICAgICAgIGlmICghc3ZnRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ2FuY2VsRXhjZXB0aW9uKHN2Z0Vycm9yKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIHN2Z0Vycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25SZW5kZXJFcnJvclByb3BzKSB7XG4gICAgICAgICAgICBvblJlbmRlckVycm9yUHJvcHMoc3ZnRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gdXNlTWVtbygoKSA9PiBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUsIHJvdGF0aW9uOiByb3RhdGUgfSksIFtwYWdlLCByb3RhdGUsIHNjYWxlXSk7XG4gICAgZnVuY3Rpb24gcmVzZXRTVkcoKSB7XG4gICAgICAgIHN2Z0Rpc3BhdGNoKHsgdHlwZTogJ1JFU0VUJyB9KTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KHJlc2V0U1ZHLCBbcGFnZSwgc3ZnRGlzcGF0Y2gsIHZpZXdwb3J0XSk7XG4gICAgZnVuY3Rpb24gcmVuZGVyU1ZHKCkge1xuICAgICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9IG1ha2VDYW5jZWxsYWJsZShwYWdlLmdldE9wZXJhdG9yTGlzdCgpKTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG9wZXJhdG9yTGlzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ZnR2Z4ID0gbmV3IHBkZmpzLlNWR0dyYXBoaWNzKHBhZ2UuY29tbW9uT2JqcywgcGFnZS5vYmpzKTtcbiAgICAgICAgICAgIHN2Z0dmeFxuICAgICAgICAgICAgICAgIC5nZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydClcbiAgICAgICAgICAgICAgICAudGhlbigobmV4dFN2ZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9wZGYuanMvaXNzdWVzLzE2NzQ1XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dFN2ZyBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0U1ZHIHJldHVybmVkIHVuZXhwZWN0ZWQgcmVzdWx0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdmdEaXNwYXRjaCh7IHR5cGU6ICdSRVNPTFZFJywgdmFsdWU6IG5leHRTdmcgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzdmdEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc3ZnRGlzcGF0Y2goeyB0eXBlOiAnUkVKRUNUJywgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUnVubmluZ1Rhc2soY2FuY2VsbGFibGUpO1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVuZGVyU1ZHLCBbcGFnZSwgc3ZnRGlzcGF0Y2gsIHZpZXdwb3J0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2ZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN2ZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblJlbmRlclN1Y2Nlc3MoKTtcbiAgICB9LCBcbiAgICAvLyBPbW1pdHRlZCBjYWxsYmFja3Mgc28gdGhleSBhcmUgbm90IGNhbGxlZCBldmVyeSB0aW1lIHRoZXkgY2hhbmdlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtzdmddKTtcbiAgICBmdW5jdGlvbiBkcmF3UGFnZU9uQ29udGFpbmVyKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFzdmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgU1ZHIGVsZW1lbnQgdG8gdGhlIG1haW4gY29udGFpbmVyLCBpZiB0aGlzIGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeVxuICAgICAgICBpZiAoIWVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHZpZXdwb3J0O1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGAke3dpZHRofWApO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHtoZWlnaHR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmlld3BvcnQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgJHtfY2xhc3NOYW1lfV9fc3ZnYCwgXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgY2Fubm90IGJlIHNob3J0ZW5lZCwgYXMgd2UgbmVlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGVhY2ggcmVuZGVyLlxuICAgICAgICByZWY6IChyZWYpID0+IGRyYXdQYWdlT25Db250YWluZXIocmVmKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgfSB9KSk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwibWFrZUNhbmNlbGxhYmxlIiwiaW52YXJpYW50Iiwid2FybmluZyIsInBkZmpzIiwidXNlUGFnZUNvbnRleHQiLCJ1c2VSZXNvbHZlciIsImNhbmNlbFJ1bm5pbmdUYXNrIiwiaXNDYW5jZWxFeGNlcHRpb24iLCJtYWtlUGFnZUNhbGxiYWNrIiwiUGFnZVNWRyIsInBhZ2VDb250ZXh0IiwiX2NsYXNzTmFtZSIsIm9uUmVuZGVyU3VjY2VzcyIsIm9uUmVuZGVyU3VjY2Vzc1Byb3BzIiwib25SZW5kZXJFcnJvciIsIm9uUmVuZGVyRXJyb3JQcm9wcyIsInBhZ2UiLCJyb3RhdGUiLCJzY2FsZSIsInN2Z1N0YXRlIiwic3ZnRGlzcGF0Y2giLCJ2YWx1ZSIsInN2ZyIsImVycm9yIiwic3ZnRXJyb3IiLCJ0b1N0cmluZyIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJyb3RhdGlvbiIsInJlc2V0U1ZHIiwidHlwZSIsInJlbmRlclNWRyIsImNhbmNlbGxhYmxlIiwiZ2V0T3BlcmF0b3JMaXN0IiwicHJvbWlzZSIsInRoZW4iLCJvcGVyYXRvckxpc3QiLCJzdmdHZngiLCJTVkdHcmFwaGljcyIsImNvbW1vbk9ianMiLCJvYmpzIiwiZ2V0U1ZHIiwibmV4dFN2ZyIsIlNWR0VsZW1lbnQiLCJFcnJvciIsImNhdGNoIiwidW5kZWZpbmVkIiwiZHJhd1BhZ2VPbkNvbnRhaW5lciIsImVsZW1lbnQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImFwcGVuZENoaWxkIiwid2lkdGgiLCJoZWlnaHQiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVmIiwic3R5bGUiLCJkaXNwbGF5IiwiYmFja2dyb3VuZENvbG9yIiwib3ZlcmZsb3ciLCJ1c2VyU2VsZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/PageSVG.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/TextLayer.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/TextLayer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TextLayer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/hooks/usePageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\n\nfunction isTextItem(item) {\n    return \"str\" in item;\n}\nfunction TextLayer() {\n    const pageContext = (0,_shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pageContext, \"Unable to find Page context.\");\n    const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale } = pageContext;\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(page, \"Attempted to load page text content, but no page was specified.\");\n    const [textContentState, textContentDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n    const { value: textContent, error: textContentError } = textContentState;\n    const layerElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const endElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    warning__WEBPACK_IMPORTED_MODULE_3__(parseInt(window.getComputedStyle(document.body).getPropertyValue(\"--react-pdf-text-layer\"), 10) === 1, \"TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer\");\n    /**\n     * Called when a page text content is read successfully\n     */ function onLoadSuccess() {\n        if (!textContent) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetTextSuccess) {\n            onGetTextSuccess(textContent);\n        }\n    }\n    /**\n     * Called when a page text content failed to read successfully\n     */ function onLoadError() {\n        if (!textContentError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, textContentError.toString());\n        if (onGetTextError) {\n            onGetTextError(textContentError);\n        }\n    }\n    function resetTextContent() {\n        textContentDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetTextContent, [\n        page,\n        textContentDispatch\n    ]);\n    function loadTextContent() {\n        if (!page) {\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(page.getTextContent());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextTextContent)=>{\n            textContentDispatch({\n                type: \"RESOLVE\",\n                value: nextTextContent\n            });\n        }).catch((error)=>{\n            textContentDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_7__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadTextContent, [\n        page,\n        textContentDispatch\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (textContent === undefined) {\n            return;\n        }\n        if (textContent === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        textContent\n    ]);\n    /**\n     * Called when a text layer is rendered successfully\n     */ const onRenderSuccess = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (onRenderTextLayerSuccess) {\n            onRenderTextLayerSuccess();\n        }\n    }, [\n        onRenderTextLayerSuccess\n    ]);\n    /**\n     * Called when a text layer failed to render successfully\n     */ const onRenderError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((error)=>{\n        warning__WEBPACK_IMPORTED_MODULE_3__(false, error.toString());\n        if (onRenderTextLayerError) {\n            onRenderTextLayerError(error);\n        }\n    }, [\n        onRenderTextLayerError\n    ]);\n    function onMouseDown() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.add(\"active\");\n    }\n    function onMouseUp() {\n        const end = endElement.current;\n        if (!end) {\n            return;\n        }\n        end.classList.remove(\"active\");\n    }\n    const viewport = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>page.getViewport({\n            scale,\n            rotation: rotate\n        }), [\n        page,\n        rotate,\n        scale\n    ]);\n    function renderTextLayer() {\n        if (!page || !textContent) {\n            return;\n        }\n        const { current: layer } = layerElement;\n        if (!layer) {\n            return;\n        }\n        layer.innerHTML = \"\";\n        const textContentSource = page.streamTextContent({\n            includeMarkedContent: true\n        });\n        const parameters = {\n            container: layer,\n            textContentSource,\n            viewport\n        };\n        const cancellable = _pdfjs_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].renderTextLayer(parameters);\n        const runningTask = cancellable;\n        cancellable.promise.then(()=>{\n            const end = document.createElement(\"div\");\n            end.className = \"endOfContent\";\n            layer.append(end);\n            endElement.current = end;\n            const layerChildren = layer.querySelectorAll('[role=\"presentation\"]');\n            if (customTextRenderer) {\n                let index = 0;\n                textContent.items.forEach((item, itemIndex)=>{\n                    if (!isTextItem(item)) {\n                        return;\n                    }\n                    const child = layerChildren[index];\n                    if (!child) {\n                        return;\n                    }\n                    const content = customTextRenderer(Object.assign({\n                        pageIndex,\n                        pageNumber,\n                        itemIndex\n                    }, item));\n                    child.innerHTML = content;\n                    index += item.str && item.hasEOL ? 2 : 1;\n                });\n            }\n            // Intentional immediate callback\n            onRenderSuccess();\n        }).catch(onRenderError);\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_7__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(renderTextLayer, [\n        customTextRenderer,\n        onRenderError,\n        onRenderSuccess,\n        page,\n        pageIndex,\n        pageNumber,\n        textContent,\n        viewport\n    ]);\n    return(// eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"react-pdf__Page__textContent\", \"textLayer\"),\n        onMouseUp: onMouseUp,\n        onMouseDown: onMouseDown,\n        ref: layerElement\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvVGV4dExheWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7NkRBQ3dGO0FBQ2pDO0FBQy9CO0FBQ2U7QUFDVDtBQUNFO0FBQytCO0FBQ047QUFDRjtBQUN2RCxTQUFTYyxXQUFXQyxJQUFJO0lBQ3BCLE9BQU8sU0FBU0E7QUFDcEI7QUFDZSxTQUFTQztJQUNwQixNQUFNQyxjQUFjTiwyRUFBY0E7SUFDbENILDBEQUFTQSxDQUFDUyxhQUFhO0lBQ3ZCLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUVDLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUVDLHNCQUFzQixFQUFFQyx3QkFBd0IsRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUcsR0FBR1Y7SUFDaEtULDBEQUFTQSxDQUFDZSxNQUFNO0lBQ2hCLE1BQU0sQ0FBQ0ssa0JBQWtCQyxvQkFBb0IsR0FBR2pCLHdFQUFXQTtJQUMzRCxNQUFNLEVBQUVrQixPQUFPQyxXQUFXLEVBQUVDLE9BQU9DLGdCQUFnQixFQUFFLEdBQUdMO0lBQ3hELE1BQU1NLGVBQWU3Qiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNOEIsYUFBYTlCLDZDQUFNQTtJQUN6Qkksb0NBQU9BLENBQUMyQixTQUFTQyxPQUFPQyxnQkFBZ0IsQ0FBQ0MsU0FBU0MsSUFBSSxFQUFFQyxnQkFBZ0IsQ0FBQywyQkFBMkIsUUFBUSxHQUFHO0lBQy9HOztLQUVDLEdBQ0QsU0FBU0M7UUFDTCxJQUFJLENBQUNYLGFBQWE7WUFDZCwrQ0FBK0M7WUFDL0M7UUFDSjtRQUNBLElBQUlYLGtCQUFrQjtZQUNsQkEsaUJBQWlCVztRQUNyQjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxTQUFTWTtRQUNMLElBQUksQ0FBQ1Ysa0JBQWtCO1lBQ25CLCtDQUErQztZQUMvQztRQUNKO1FBQ0F4QixvQ0FBT0EsQ0FBQyxPQUFPd0IsaUJBQWlCVyxRQUFR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TyxDQUFDLENBQUNwRSxNQUFNcUU7b0JBQzdCLElBQUksQ0FBQ3RFLFdBQVdDLE9BQU87d0JBQ25CO29CQUNKO29CQUNBLE1BQU1zRSxRQUFRTixhQUFhLENBQUNFLE1BQU07b0JBQ2xDLElBQUksQ0FBQ0ksT0FBTzt3QkFDUjtvQkFDSjtvQkFDQSxNQUFNQyxVQUFVcEUsbUJBQW1CcUUsT0FBT0MsTUFBTSxDQUFDO3dCQUFFaEU7d0JBQy9DQzt3QkFDQTJEO29CQUFVLEdBQUdyRTtvQkFDakJzRSxNQUFNZixTQUFTLEdBQUdnQjtvQkFDbEJMLFNBQVNsRSxLQUFLMEUsR0FBRyxJQUFJMUUsS0FBSzJFLE1BQU0sR0FBRyxJQUFJO2dCQUMzQztZQUNKO1lBQ0EsaUNBQWlDO1lBQ2pDbEM7UUFDSixHQUNLRixLQUFLLENBQUNHO1FBQ1gsT0FBTyxJQUFNNUMsbUVBQWlCQSxDQUFDcUM7SUFDbkM7SUFDQS9DLHNEQUFlQSxDQUFDaUUsaUJBQWlCO1FBQzdCbEQ7UUFDQXVDO1FBQ0FEO1FBQ0FqQztRQUNBQztRQUNBQztRQUNBTTtRQUNBa0M7S0FDSDtJQUNELE9BQ0EsbUVBQW1FO2tCQUNuRWpFLGdEQUFtQixDQUFDLE9BQU87UUFBRTZFLFdBQVd0RSxnREFBSUEsQ0FBQyxnQ0FBZ0M7UUFBY3dELFdBQVdBO1FBQVdMLGFBQWFBO1FBQWFpQyxLQUFLekQ7SUFBYTtBQUNqSyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9QYWdlL1RleHRMYXllci5qcz83OGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBwZGZqcyBmcm9tICcuLi9wZGZqcy5qcyc7XG5pbXBvcnQgdXNlUGFnZUNvbnRleHQgZnJvbSAnLi4vc2hhcmVkL2hvb2tzL3VzZVBhZ2VDb250ZXh0LmpzJztcbmltcG9ydCB1c2VSZXNvbHZlciBmcm9tICcuLi9zaGFyZWQvaG9va3MvdXNlUmVzb2x2ZXIuanMnO1xuaW1wb3J0IHsgY2FuY2VsUnVubmluZ1Rhc2sgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuZnVuY3Rpb24gaXNUZXh0SXRlbShpdGVtKSB7XG4gICAgcmV0dXJuICdzdHInIGluIGl0ZW07XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUZXh0TGF5ZXIoKSB7XG4gICAgY29uc3QgcGFnZUNvbnRleHQgPSB1c2VQYWdlQ29udGV4dCgpO1xuICAgIGludmFyaWFudChwYWdlQ29udGV4dCwgJ1VuYWJsZSB0byBmaW5kIFBhZ2UgY29udGV4dC4nKTtcbiAgICBjb25zdCB7IGN1c3RvbVRleHRSZW5kZXJlciwgb25HZXRUZXh0RXJyb3IsIG9uR2V0VGV4dFN1Y2Nlc3MsIG9uUmVuZGVyVGV4dExheWVyRXJyb3IsIG9uUmVuZGVyVGV4dExheWVyU3VjY2VzcywgcGFnZSwgcGFnZUluZGV4LCBwYWdlTnVtYmVyLCByb3RhdGUsIHNjYWxlLCB9ID0gcGFnZUNvbnRleHQ7XG4gICAgaW52YXJpYW50KHBhZ2UsICdBdHRlbXB0ZWQgdG8gbG9hZCBwYWdlIHRleHQgY29udGVudCwgYnV0IG5vIHBhZ2Ugd2FzIHNwZWNpZmllZC4nKTtcbiAgICBjb25zdCBbdGV4dENvbnRlbnRTdGF0ZSwgdGV4dENvbnRlbnREaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHRleHRDb250ZW50LCBlcnJvcjogdGV4dENvbnRlbnRFcnJvciB9ID0gdGV4dENvbnRlbnRTdGF0ZTtcbiAgICBjb25zdCBsYXllckVsZW1lbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZW5kRWxlbWVudCA9IHVzZVJlZigpO1xuICAgIHdhcm5pbmcocGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1yZWFjdC1wZGYtdGV4dC1sYXllcicpLCAxMCkgPT09IDEsICdUZXh0TGF5ZXIgc3R5bGVzIG5vdCBmb3VuZC4gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vd29qdGVrbWFqL3JlYWN0LXBkZiNzdXBwb3J0LWZvci10ZXh0LWxheWVyJyk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWdlIHRleHQgY29udGVudCBpcyByZWFkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uTG9hZFN1Y2Nlc3MoKSB7XG4gICAgICAgIGlmICghdGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uR2V0VGV4dFN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIG9uR2V0VGV4dFN1Y2Nlc3ModGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFnZSB0ZXh0IGNvbnRlbnQgZmFpbGVkIHRvIHJlYWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Mb2FkRXJyb3IoKSB7XG4gICAgICAgIGlmICghdGV4dENvbnRlbnRFcnJvcikge1xuICAgICAgICAgICAgLy8gSW1wb3NzaWJsZSwgYnV0IFR5cGVTY3JpcHQgZG9lc24ndCBrbm93IHRoYXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCB0ZXh0Q29udGVudEVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25HZXRUZXh0RXJyb3IpIHtcbiAgICAgICAgICAgIG9uR2V0VGV4dEVycm9yKHRleHRDb250ZW50RXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHRleHRDb250ZW50RGlzcGF0Y2goeyB0eXBlOiAnUkVTRVQnIH0pO1xuICAgIH1cbiAgICB1c2VFZmZlY3QocmVzZXRUZXh0Q29udGVudCwgW3BhZ2UsIHRleHRDb250ZW50RGlzcGF0Y2hdKTtcbiAgICBmdW5jdGlvbiBsb2FkVGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gbWFrZUNhbmNlbGxhYmxlKHBhZ2UuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgIGNhbmNlbGxhYmxlLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChuZXh0VGV4dENvbnRlbnQpID0+IHtcbiAgICAgICAgICAgIHRleHRDb250ZW50RGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0VGV4dENvbnRlbnQgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudERpc3BhdGNoKHsgdHlwZTogJ1JFSkVDVCcsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFJ1bm5pbmdUYXNrKHJ1bm5pbmdUYXNrKTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KGxvYWRUZXh0Q29udGVudCwgW3BhZ2UsIHRleHRDb250ZW50RGlzcGF0Y2hdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodGV4dENvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9uTG9hZEVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25Mb2FkU3VjY2VzcygpO1xuICAgIH0sIFxuICAgIC8vIE9tbWl0dGVkIGNhbGxiYWNrcyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhleSBjaGFuZ2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW3RleHRDb250ZW50XSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0ZXh0IGxheWVyIGlzIHJlbmRlcmVkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuICAgIGNvbnN0IG9uUmVuZGVyU3VjY2VzcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKG9uUmVuZGVyVGV4dExheWVyU3VjY2Vzcykge1xuICAgICAgICAgICAgb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW5kZXJUZXh0TGF5ZXJTdWNjZXNzXSk7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSB0ZXh0IGxheWVyIGZhaWxlZCB0byByZW5kZXIgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG4gICAgY29uc3Qgb25SZW5kZXJFcnJvciA9IHVzZUNhbGxiYWNrKChlcnJvcikgPT4ge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9uUmVuZGVyVGV4dExheWVyRXJyb3IpIHtcbiAgICAgICAgICAgIG9uUmVuZGVyVGV4dExheWVyRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgW29uUmVuZGVyVGV4dExheWVyRXJyb3JdKTtcbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bigpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZW5kRWxlbWVudC5jdXJyZW50O1xuICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuZC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgICBjb25zdCBlbmQgPSBlbmRFbGVtZW50LmN1cnJlbnQ7XG4gICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW5kLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHVzZU1lbW8oKCkgPT4gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlLCByb3RhdGlvbjogcm90YXRlIH0pLCBbcGFnZSwgcm90YXRlLCBzY2FsZV0pO1xuICAgIGZ1bmN0aW9uIHJlbmRlclRleHRMYXllcigpIHtcbiAgICAgICAgaWYgKCFwYWdlIHx8ICF0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogbGF5ZXIgfSA9IGxheWVyRWxlbWVudDtcbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNvdXJjZSA9IHBhZ2Uuc3RyZWFtVGV4dENvbnRlbnQoeyBpbmNsdWRlTWFya2VkQ29udGVudDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogbGF5ZXIsXG4gICAgICAgICAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICAgICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYW5jZWxsYWJsZSA9IHBkZmpzLnJlbmRlclRleHRMYXllcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbmQuY2xhc3NOYW1lID0gJ2VuZE9mQ29udGVudCc7XG4gICAgICAgICAgICBsYXllci5hcHBlbmQoZW5kKTtcbiAgICAgICAgICAgIGVuZEVsZW1lbnQuY3VycmVudCA9IGVuZDtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyQ2hpbGRyZW4gPSBsYXllci5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInByZXNlbnRhdGlvblwiXScpO1xuICAgICAgICAgICAgaWYgKGN1c3RvbVRleHRSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNUZXh0SXRlbShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbGF5ZXJDaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3VzdG9tVGV4dFJlbmRlcmVyKE9iamVjdC5hc3NpZ24oeyBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUluZGV4IH0sIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gaXRlbS5zdHIgJiYgaXRlbS5oYXNFT0wgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEludGVudGlvbmFsIGltbWVkaWF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgb25SZW5kZXJTdWNjZXNzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gob25SZW5kZXJFcnJvcik7XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxSdW5uaW5nVGFzayhydW5uaW5nVGFzayk7XG4gICAgfVxuICAgIHVzZUxheW91dEVmZmVjdChyZW5kZXJUZXh0TGF5ZXIsIFtcbiAgICAgICAgY3VzdG9tVGV4dFJlbmRlcmVyLFxuICAgICAgICBvblJlbmRlckVycm9yLFxuICAgICAgICBvblJlbmRlclN1Y2Nlc3MsXG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgcGFnZU51bWJlcixcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgIF0pO1xuICAgIHJldHVybiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L25vLXN0YXRpYy1lbGVtZW50LWludGVyYWN0aW9uc1xuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3JlYWN0LXBkZl9fUGFnZV9fdGV4dENvbnRlbnQnLCAndGV4dExheWVyJyksIG9uTW91c2VVcDogb25Nb3VzZVVwLCBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIHJlZjogbGF5ZXJFbGVtZW50IH0pKTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsIm1ha2VDYW5jZWxsYWJsZSIsImNsc3giLCJpbnZhcmlhbnQiLCJ3YXJuaW5nIiwicGRmanMiLCJ1c2VQYWdlQ29udGV4dCIsInVzZVJlc29sdmVyIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJpc1RleHRJdGVtIiwiaXRlbSIsIlRleHRMYXllciIsInBhZ2VDb250ZXh0IiwiY3VzdG9tVGV4dFJlbmRlcmVyIiwib25HZXRUZXh0RXJyb3IiLCJvbkdldFRleHRTdWNjZXNzIiwib25SZW5kZXJUZXh0TGF5ZXJFcnJvciIsIm9uUmVuZGVyVGV4dExheWVyU3VjY2VzcyIsInBhZ2UiLCJwYWdlSW5kZXgiLCJwYWdlTnVtYmVyIiwicm90YXRlIiwic2NhbGUiLCJ0ZXh0Q29udGVudFN0YXRlIiwidGV4dENvbnRlbnREaXNwYXRjaCIsInZhbHVlIiwidGV4dENvbnRlbnQiLCJlcnJvciIsInRleHRDb250ZW50RXJyb3IiLCJsYXllckVsZW1lbnQiLCJlbmRFbGVtZW50IiwicGFyc2VJbnQiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnQiLCJib2R5IiwiZ2V0UHJvcGVydHlWYWx1ZSIsIm9uTG9hZFN1Y2Nlc3MiLCJvbkxvYWRFcnJvciIsInRvU3RyaW5nIiwicmVzZXRUZXh0Q29udGVudCIsInR5cGUiLCJsb2FkVGV4dENvbnRlbnQiLCJjYW5jZWxsYWJsZSIsImdldFRleHRDb250ZW50IiwicnVubmluZ1Rhc2siLCJwcm9taXNlIiwidGhlbiIsIm5leHRUZXh0Q29udGVudCIsImNhdGNoIiwidW5kZWZpbmVkIiwib25SZW5kZXJTdWNjZXNzIiwib25SZW5kZXJFcnJvciIsIm9uTW91c2VEb3duIiwiZW5kIiwiY3VycmVudCIsImNsYXNzTGlzdCIsImFkZCIsIm9uTW91c2VVcCIsInJlbW92ZSIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJyb3RhdGlvbiIsInJlbmRlclRleHRMYXllciIsImxheWVyIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnRTb3VyY2UiLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwicGFyYW1ldGVycyIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmQiLCJsYXllckNoaWxkcmVuIiwicXVlcnlTZWxlY3RvckFsbCIsImluZGV4IiwiaXRlbXMiLCJmb3JFYWNoIiwiaXRlbUluZGV4IiwiY2hpbGQiLCJjb250ZW50IiwiT2JqZWN0IiwiYXNzaWduIiwic3RyIiwiaGFzRU9MIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/TextLayer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/PasswordResponses.js":
/*!**************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/PasswordResponses.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// As defined in https://github.com/mozilla/pdf.js/blob/d9fac3459609a807be6506fb3441b5da4b154d14/src/shared/util.js#L371-L374\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PasswordResponses);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1Bhc3N3b3JkUmVzcG9uc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2SEFBNkg7QUFDN0gsTUFBTUEsb0JBQW9CO0lBQ3RCQyxlQUFlO0lBQ2ZDLG9CQUFvQjtBQUN4QjtBQUNBLGlFQUFlRixpQkFBaUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFzc3dvcmRSZXNwb25zZXMuanM/ZGJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBcyBkZWZpbmVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3BkZi5qcy9ibG9iL2Q5ZmFjMzQ1OTYwOWE4MDdiZTY1MDZmYjM0NDFiNWRhNGIxNTRkMTQvc3JjL3NoYXJlZC91dGlsLmpzI0wzNzEtTDM3NFxuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gICAgTkVFRF9QQVNTV09SRDogMSxcbiAgICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDIsXG59O1xuZXhwb3J0IGRlZmF1bHQgUGFzc3dvcmRSZXNwb25zZXM7XG4iXSwibmFtZXMiOlsiUGFzc3dvcmRSZXNwb25zZXMiLCJORUVEX1BBU1NXT1JEIiwiSU5DT1JSRUNUX1BBU1NXT1JEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/PasswordResponses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Ref.js":
/*!************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Ref.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ref)\n/* harmony export */ });\nclass Ref {\n    constructor({ num, gen }){\n        this.num = num;\n        this.gen = gen;\n    }\n    toString() {\n        let str = `${this.num}R`;\n        if (this.gen !== 0) {\n            str += this.gen;\n        }\n        return str;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1JlZi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsTUFBTUE7SUFDakJDLFlBQVksRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUUsQ0FBRTtRQUN0QixJQUFJLENBQUNELEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLEdBQUcsR0FBR0E7SUFDZjtJQUNBQyxXQUFXO1FBQ1AsSUFBSUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDSCxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLElBQUksSUFBSSxDQUFDQyxHQUFHLEtBQUssR0FBRztZQUNoQkUsT0FBTyxJQUFJLENBQUNGLEdBQUc7UUFDbkI7UUFDQSxPQUFPRTtJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUmVmLmpzPzU2MTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG51bSwgZ2VuIH0pIHtcbiAgICAgICAgdGhpcy5udW0gPSBudW07XG4gICAgICAgIHRoaXMuZ2VuID0gZ2VuO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IGAke3RoaXMubnVtfVJgO1xuICAgICAgICBpZiAodGhpcy5nZW4gIT09IDApIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLmdlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJSZWYiLCJjb25zdHJ1Y3RvciIsIm51bSIsImdlbiIsInRvU3RyaW5nIiwic3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Ref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/StructTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/StructTree.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StructTree)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var make_cancellable_promise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! make-cancellable-promise */ \"(ssr)/./node_modules/make-cancellable-promise/dist/esm/index.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n/* harmony import */ var _StructTreeItem_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./StructTreeItem.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/StructTreeItem.js\");\n/* harmony import */ var _shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/hooks/usePageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\");\n/* harmony import */ var _shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/hooks/useResolver.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n\n\n\n\n\n\n\n\nfunction StructTree() {\n    const pageContext = (0,_shared_hooks_usePageContext_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pageContext, \"Unable to find Page context.\");\n    const { onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps } = pageContext;\n    const [structTreeState, structTreeDispatch] = (0,_shared_hooks_useResolver_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    const { value: structTree, error: structTreeError } = structTreeState;\n    const { customTextRenderer, page } = pageContext;\n    function onLoadSuccess() {\n        if (!structTree) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        if (onGetStructTreeSuccessProps) {\n            onGetStructTreeSuccessProps(structTree);\n        }\n    }\n    function onLoadError() {\n        if (!structTreeError) {\n            // Impossible, but TypeScript doesn't know that\n            return;\n        }\n        warning__WEBPACK_IMPORTED_MODULE_2__(false, structTreeError.toString());\n        if (onGetStructTreeErrorProps) {\n            onGetStructTreeErrorProps(structTreeError);\n        }\n    }\n    function resetAnnotations() {\n        structTreeDispatch({\n            type: \"RESET\"\n        });\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(resetAnnotations, [\n        structTreeDispatch,\n        page\n    ]);\n    function loadStructTree() {\n        if (customTextRenderer) {\n            // TODO: Document why this is necessary\n            return;\n        }\n        if (!page) {\n            return;\n        }\n        const cancellable = (0,make_cancellable_promise__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(page.getStructTree());\n        const runningTask = cancellable;\n        cancellable.promise.then((nextStructTree)=>{\n            structTreeDispatch({\n                type: \"RESOLVE\",\n                value: nextStructTree\n            });\n        }).catch((error)=>{\n            structTreeDispatch({\n                type: \"REJECT\",\n                error\n            });\n        });\n        return ()=>(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_6__.cancelRunningTask)(runningTask);\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(loadStructTree, [\n        customTextRenderer,\n        page,\n        structTreeDispatch\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (structTree === undefined) {\n            return;\n        }\n        if (structTree === false) {\n            onLoadError();\n            return;\n        }\n        onLoadSuccess();\n    }, // Ommitted callbacks so they are not called every time they change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        structTree\n    ]);\n    if (!structTree) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_StructTreeItem_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n        className: \"react-pdf__Page__structTree structTree\",\n        node: structTree\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1N0cnVjdFRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ2M7QUFDaEI7QUFDVDtBQUNtQjtBQUNhO0FBQ047QUFDRjtBQUN2QyxTQUFTUztJQUNwQixNQUFNQyxjQUFjSiwyRUFBY0E7SUFDbENILDBEQUFTQSxDQUFDTyxhQUFhO0lBQ3ZCLE1BQU0sRUFBRUMsc0JBQXNCQyx5QkFBeUIsRUFBRUMsd0JBQXdCQywyQkFBMkIsRUFBRyxHQUFHSjtJQUNsSCxNQUFNLENBQUNLLGlCQUFpQkMsbUJBQW1CLEdBQUdULHdFQUFXQTtJQUN6RCxNQUFNLEVBQUVVLE9BQU9DLFVBQVUsRUFBRUMsT0FBT0MsZUFBZSxFQUFFLEdBQUdMO0lBQ3RELE1BQU0sRUFBRU0sa0JBQWtCLEVBQUVDLElBQUksRUFBRSxHQUFHWjtJQUNyQyxTQUFTYTtRQUNMLElBQUksQ0FBQ0wsWUFBWTtZQUNiLCtDQUErQztZQUMvQztRQUNKO1FBQ0EsSUFBSUosNkJBQTZCO1lBQzdCQSw0QkFBNEJJO1FBQ2hDO0lBQ0o7SUFDQSxTQUFTTTtRQUNMLElBQUksQ0FBQ0osaUJBQWlCO1lBQ2xCLCtDQUErQztZQUMvQztRQUNKO1FBQ0FoQixvQ0FBT0EsQ0FBQyxPQUFPZ0IsZ0JBQWdCSyxRQUFRO1FBQ3ZDLElBQUliLDJCQUEyQjtZQUMzQkEsMEJBQTBCUTtRQUM5QjtJQUNKO0lBQ0EsU0FBU007UUFDTFYsbUJBQW1CO1lBQUVXLE1BQU07UUFBUTtJQUN2QztJQUNBMUIsZ0RBQVNBLENBQUN5QixrQkFBa0I7UUFBQ1Y7UUFBb0JNO0tBQUs7SUFDdEQsU0FBU007UUFDTCxJQUFJUCxvQkFBb0I7WUFDcEIsdUNBQXVDO1lBQ3ZDO1FBQ0o7UUFDQSxJQUFJLENBQUNDLE1BQU07WUFDUDtRQUNKO1FBQ0EsTUFBTU8sY0FBYzNCLG9FQUFlQSxDQUFDb0IsS0FBS1EsYUFBYTtRQUN0RCxNQUFNQyxjQUFjRjtRQUNwQkEsWUFBWUcsT0FBTyxDQUNkQyxJQUFJLENBQUMsQ0FBQ0M7WUFDUGxCLG1CQUFtQjtnQkFBRVcsTUFBTTtnQkFBV1YsT0FBT2lCO1lBQWU7UUFDaEUsR0FDS0MsS0FBSyxDQUFDLENBQUNoQjtZQUNSSCxtQkFBbUI7Z0JBQUVXLE1BQU07Z0JBQVVSO1lBQU07UUFDL0M7UUFDQSxPQUFPLElBQU1YLG1FQUFpQkEsQ0FBQ3VCO0lBQ25DO0lBQ0E5QixnREFBU0EsQ0FBQzJCLGdCQUFnQjtRQUFDUDtRQUFvQkM7UUFBTU47S0FBbUI7SUFDeEVmLGdEQUFTQSxDQUFDO1FBQ04sSUFBSWlCLGVBQWVrQixXQUFXO1lBQzFCO1FBQ0o7UUFDQSxJQUFJbEIsZUFBZSxPQUFPO1lBQ3RCTTtZQUNBO1FBQ0o7UUFDQUQ7SUFDSixHQUNBLG1FQUFtRTtJQUNuRSx1REFBdUQ7SUFDdkQ7UUFBQ0w7S0FBVztJQUNaLElBQUksQ0FBQ0EsWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLHFCQUFPbEIsZ0RBQW1CLENBQUNLLDBEQUFjQSxFQUFFO1FBQUVpQyxXQUFXO1FBQTBDQyxNQUFNckI7SUFBVztBQUN2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9TdHJ1Y3RUcmVlLmpzPzY0MjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgU3RydWN0VHJlZUl0ZW0gZnJvbSAnLi9TdHJ1Y3RUcmVlSXRlbS5qcyc7XG5pbXBvcnQgdXNlUGFnZUNvbnRleHQgZnJvbSAnLi9zaGFyZWQvaG9va3MvdXNlUGFnZUNvbnRleHQuanMnO1xuaW1wb3J0IHVzZVJlc29sdmVyIGZyb20gJy4vc2hhcmVkL2hvb2tzL3VzZVJlc29sdmVyLmpzJztcbmltcG9ydCB7IGNhbmNlbFJ1bm5pbmdUYXNrIH0gZnJvbSAnLi9zaGFyZWQvdXRpbHMuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3RydWN0VHJlZSgpIHtcbiAgICBjb25zdCBwYWdlQ29udGV4dCA9IHVzZVBhZ2VDb250ZXh0KCk7XG4gICAgaW52YXJpYW50KHBhZ2VDb250ZXh0LCAnVW5hYmxlIHRvIGZpbmQgUGFnZSBjb250ZXh0LicpO1xuICAgIGNvbnN0IHsgb25HZXRTdHJ1Y3RUcmVlRXJyb3I6IG9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMsIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3M6IG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcywgfSA9IHBhZ2VDb250ZXh0O1xuICAgIGNvbnN0IFtzdHJ1Y3RUcmVlU3RhdGUsIHN0cnVjdFRyZWVEaXNwYXRjaF0gPSB1c2VSZXNvbHZlcigpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHN0cnVjdFRyZWUsIGVycm9yOiBzdHJ1Y3RUcmVlRXJyb3IgfSA9IHN0cnVjdFRyZWVTdGF0ZTtcbiAgICBjb25zdCB7IGN1c3RvbVRleHRSZW5kZXJlciwgcGFnZSB9ID0gcGFnZUNvbnRleHQ7XG4gICAgZnVuY3Rpb24gb25Mb2FkU3VjY2VzcygpIHtcbiAgICAgICAgaWYgKCFzdHJ1Y3RUcmVlKSB7XG4gICAgICAgICAgICAvLyBJbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkdldFN0cnVjdFRyZWVTdWNjZXNzUHJvcHMpIHtcbiAgICAgICAgICAgIG9uR2V0U3RydWN0VHJlZVN1Y2Nlc3NQcm9wcyhzdHJ1Y3RUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkxvYWRFcnJvcigpIHtcbiAgICAgICAgaWYgKCFzdHJ1Y3RUcmVlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEltcG9zc2libGUsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgc3RydWN0VHJlZUVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcykge1xuICAgICAgICAgICAgb25HZXRTdHJ1Y3RUcmVlRXJyb3JQcm9wcyhzdHJ1Y3RUcmVlRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0QW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIHN0cnVjdFRyZWVEaXNwYXRjaCh7IHR5cGU6ICdSRVNFVCcgfSk7XG4gICAgfVxuICAgIHVzZUVmZmVjdChyZXNldEFubm90YXRpb25zLCBbc3RydWN0VHJlZURpc3BhdGNoLCBwYWdlXSk7XG4gICAgZnVuY3Rpb24gbG9hZFN0cnVjdFRyZWUoKSB7XG4gICAgICAgIGlmIChjdXN0b21UZXh0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IERvY3VtZW50IHdoeSB0aGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhYmxlID0gbWFrZUNhbmNlbGxhYmxlKHBhZ2UuZ2V0U3RydWN0VHJlZSgpKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgY2FuY2VsbGFibGUucHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKG5leHRTdHJ1Y3RUcmVlKSA9PiB7XG4gICAgICAgICAgICBzdHJ1Y3RUcmVlRGlzcGF0Y2goeyB0eXBlOiAnUkVTT0xWRScsIHZhbHVlOiBuZXh0U3RydWN0VHJlZSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHN0cnVjdFRyZWVEaXNwYXRjaCh7IHR5cGU6ICdSRUpFQ1QnLCBlcnJvciB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxSdW5uaW5nVGFzayhydW5uaW5nVGFzayk7XG4gICAgfVxuICAgIHVzZUVmZmVjdChsb2FkU3RydWN0VHJlZSwgW2N1c3RvbVRleHRSZW5kZXJlciwgcGFnZSwgc3RydWN0VHJlZURpc3BhdGNoXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0cnVjdFRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJ1Y3RUcmVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb25Mb2FkRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWRTdWNjZXNzKCk7XG4gICAgfSwgXG4gICAgLy8gT21taXR0ZWQgY2FsbGJhY2tzIHNvIHRoZXkgYXJlIG5vdCBjYWxsZWQgZXZlcnkgdGltZSB0aGV5IGNoYW5nZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbc3RydWN0VHJlZV0pO1xuICAgIGlmICghc3RydWN0VHJlZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RydWN0VHJlZUl0ZW0sIHsgY2xhc3NOYW1lOiBcInJlYWN0LXBkZl9fUGFnZV9fc3RydWN0VHJlZSBzdHJ1Y3RUcmVlXCIsIG5vZGU6IHN0cnVjdFRyZWUgfSk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJtYWtlQ2FuY2VsbGFibGUiLCJpbnZhcmlhbnQiLCJ3YXJuaW5nIiwiU3RydWN0VHJlZUl0ZW0iLCJ1c2VQYWdlQ29udGV4dCIsInVzZVJlc29sdmVyIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJTdHJ1Y3RUcmVlIiwicGFnZUNvbnRleHQiLCJvbkdldFN0cnVjdFRyZWVFcnJvciIsIm9uR2V0U3RydWN0VHJlZUVycm9yUHJvcHMiLCJvbkdldFN0cnVjdFRyZWVTdWNjZXNzIiwib25HZXRTdHJ1Y3RUcmVlU3VjY2Vzc1Byb3BzIiwic3RydWN0VHJlZVN0YXRlIiwic3RydWN0VHJlZURpc3BhdGNoIiwidmFsdWUiLCJzdHJ1Y3RUcmVlIiwiZXJyb3IiLCJzdHJ1Y3RUcmVlRXJyb3IiLCJjdXN0b21UZXh0UmVuZGVyZXIiLCJwYWdlIiwib25Mb2FkU3VjY2VzcyIsIm9uTG9hZEVycm9yIiwidG9TdHJpbmciLCJyZXNldEFubm90YXRpb25zIiwidHlwZSIsImxvYWRTdHJ1Y3RUcmVlIiwiY2FuY2VsbGFibGUiLCJnZXRTdHJ1Y3RUcmVlIiwicnVubmluZ1Rhc2siLCJwcm9taXNlIiwidGhlbiIsIm5leHRTdHJ1Y3RUcmVlIiwiY2F0Y2giLCJ1bmRlZmluZWQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwibm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/StructTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/StructTreeItem.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/StructTreeItem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StructTreeItem)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shared_structTreeUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/structTreeUtils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/structTreeUtils.js\");\n\n\nfunction StructTreeItem({ className, node }) {\n    const attributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_shared_structTreeUtils_js__WEBPACK_IMPORTED_MODULE_1__.getAttributes)(node), [\n        node\n    ]);\n    const children = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!(0,_shared_structTreeUtils_js__WEBPACK_IMPORTED_MODULE_1__.isStructTreeNode)(node)) {\n            return null;\n        }\n        if ((0,_shared_structTreeUtils_js__WEBPACK_IMPORTED_MODULE_1__.isStructTreeNodeWithOnlyContentChild)(node)) {\n            return null;\n        }\n        return node.children.map((child, index)=>{\n            return(// eslint-disable-next-line react/no-array-index-key\n            /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(StructTreeItem, {\n                key: index,\n                node: child\n            }));\n        });\n    }, [\n        node\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", Object.assign({\n        className: className\n    }, attributes), children);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1N0cnVjdFRyZWVJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1QztBQUM4RTtBQUN0RyxTQUFTSyxlQUFlLEVBQUVDLFNBQVMsRUFBRUMsSUFBSSxFQUFFO0lBQ3RELE1BQU1DLGFBQWFQLDhDQUFPQSxDQUFDLElBQU1DLHlFQUFhQSxDQUFDSyxPQUFPO1FBQUNBO0tBQUs7SUFDNUQsTUFBTUUsV0FBV1IsOENBQU9BLENBQUM7UUFDckIsSUFBSSxDQUFDRSw0RUFBZ0JBLENBQUNJLE9BQU87WUFDekIsT0FBTztRQUNYO1FBQ0EsSUFBSUgsZ0dBQW9DQSxDQUFDRyxPQUFPO1lBQzVDLE9BQU87UUFDWDtRQUNBLE9BQU9BLEtBQUtFLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLE9BQU9DO1lBQzdCLE9BQ0Esb0RBQW9EOzBCQUNwRFosZ0RBQW1CLENBQUNLLGdCQUFnQjtnQkFBRVMsS0FBS0Y7Z0JBQU9MLE1BQU1JO1lBQU07UUFDbEU7SUFDSixHQUFHO1FBQUNKO0tBQUs7SUFDVCxxQkFBUVAsZ0RBQW1CLENBQUMsUUFBUWUsT0FBT0MsTUFBTSxDQUFDO1FBQUVWLFdBQVdBO0lBQVUsR0FBR0UsYUFBYUM7QUFDN0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vU3RydWN0VHJlZUl0ZW0uanM/ODg1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldEF0dHJpYnV0ZXMsIGlzU3RydWN0VHJlZU5vZGUsIGlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZCwgfSBmcm9tICcuL3NoYXJlZC9zdHJ1Y3RUcmVlVXRpbHMuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU3RydWN0VHJlZUl0ZW0oeyBjbGFzc05hbWUsIG5vZGUgfSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB1c2VNZW1vKCgpID0+IGdldEF0dHJpYnV0ZXMobm9kZSksIFtub2RlXSk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFpc1N0cnVjdFRyZWVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJ1Y3RUcmVlTm9kZVdpdGhPbmx5Q29udGVudENoaWxkKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RydWN0VHJlZUl0ZW0sIHsga2V5OiBpbmRleCwgbm9kZTogY2hpbGQgfSkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbbm9kZV0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbikpO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsImdldEF0dHJpYnV0ZXMiLCJpc1N0cnVjdFRyZWVOb2RlIiwiaXNTdHJ1Y3RUcmVlTm9kZVdpdGhPbmx5Q29udGVudENoaWxkIiwiU3RydWN0VHJlZUl0ZW0iLCJjbGFzc05hbWUiLCJub2RlIiwiYXR0cmlidXRlcyIsImNoaWxkcmVuIiwibWFwIiwiY2hpbGQiLCJpbmRleCIsImNyZWF0ZUVsZW1lbnQiLCJrZXkiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/StructTreeItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Thumbnail.js":
/*!******************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Thumbnail.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Page.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/Page.js\");\n/* harmony import */ var _shared_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shared/utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* harmony import */ var _shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/hooks/useDocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\n\n\n\n/**\n * Displays a thumbnail of a page. Does not render the annotation layer or the text layer. Does not register itself as a link target, so the user will not be scrolled to a Thumbnail component when clicked on an internal link (e.g. in Table of Contents). When clicked, attempts to navigate to the page clicked (similarly to a link in Outline).\n *\n * Should be placed inside `<Document />`. Alternatively, it can have `pdf` prop passed, which can be obtained from `<Document />`'s `onLoadSuccess` callback function.\n */ const Thumbnail = function Thumbnail(props) {\n    const documentContext = (0,_shared_hooks_useDocumentContext_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n    const mergedProps = Object.assign(Object.assign({}, documentContext), props);\n    const { className, linkService, onItemClick, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf } = mergedProps;\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pdf, \"Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop.\");\n    const pageIndex = (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.isProvided)(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;\n    const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : (0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.isProvided)(pageIndexProps) ? pageIndexProps + 1 : null;\n    function onClick(event) {\n        event.preventDefault();\n        if (!(0,_shared_utils_js__WEBPACK_IMPORTED_MODULE_4__.isProvided)(pageIndex) || !pageNumber) {\n            return;\n        }\n        (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(onItemClick || linkService, \"Either onItemClick callback or linkService must be defined in order to navigate to an outline item.\");\n        if (onItemClick) {\n            onItemClick({\n                pageIndex,\n                pageNumber\n            });\n        } else if (linkService) {\n            linkService.goToPage(pageNumber);\n        }\n    }\n    const { className: classNameProps, onItemClick: onItemClickProps } = props, pageProps = __rest(props, [\n        \"className\",\n        \"onItemClick\"\n    ]);\n    return /* eslint-disable-next-line jsx-a11y/anchor-is-valid */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"react-pdf__Thumbnail\", className),\n        href: pageNumber ? \"#\" : undefined,\n        onClick: onClick\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Page_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], Object.assign({}, pageProps, {\n        _className: \"react-pdf__Thumbnail__page\",\n        _enableRegisterUnregisterPage: false,\n        renderAnnotationLayer: false,\n        renderTextLayer: false\n    })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Thumbnail);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1RodW1ibmFpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OzZEQUNBLElBQUlBLFNBQVMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsTUFBTSxJQUFLLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNoRCxJQUFJQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9SO0FBQ1g7QUFDMEI7QUFDRjtBQUNlO0FBQ1Y7QUFDa0I7QUFDdUI7QUFDdEU7Ozs7Q0FJQyxHQUNELE1BQU1pQixZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsTUFBTUMsa0JBQWtCSCwrRUFBa0JBO0lBQzFDLE1BQU1JLGNBQWNsQixPQUFPbUIsTUFBTSxDQUFDbkIsT0FBT21CLE1BQU0sQ0FBQyxDQUFDLEdBQUdGLGtCQUFrQkQ7SUFDdEUsTUFBTSxFQUFFSSxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXQyxjQUFjLEVBQUVDLFlBQVlDLGVBQWUsRUFBRUMsR0FBRyxFQUFHLEdBQUdUO0lBQzlHUCwwREFBU0EsQ0FBQ2dCLEtBQUs7SUFDZixNQUFNSixZQUFZViw0REFBVUEsQ0FBQ2EsbUJBQW1CQSxrQkFBa0IsSUFBSUYsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUlBLGlCQUFpQjtJQUM5SSxNQUFNQyxhQUFhQyxvQkFBb0IsUUFBUUEsb0JBQW9CLEtBQUssSUFBSUEsa0JBQW1CYiw0REFBVUEsQ0FBQ1csa0JBQWtCQSxpQkFBaUIsSUFBSTtJQUNqSixTQUFTSSxRQUFRQyxLQUFLO1FBQ2xCQSxNQUFNQyxjQUFjO1FBQ3BCLElBQUksQ0FBQ2pCLDREQUFVQSxDQUFDVSxjQUFjLENBQUNFLFlBQVk7WUFDdkM7UUFDSjtRQUNBZCwwREFBU0EsQ0FBQ1csZUFBZUQsYUFBYTtRQUN0QyxJQUFJQyxhQUFhO1lBQ2JBLFlBQVk7Z0JBQ1JDO2dCQUNBRTtZQUNKO1FBQ0osT0FDSyxJQUFJSixhQUFhO1lBQ2xCQSxZQUFZVSxRQUFRLENBQUNOO1FBQ3pCO0lBQ0o7SUFDQSxNQUFNLEVBQUVMLFdBQVdZLGNBQWMsRUFBRVYsYUFBYVcsZ0JBQWdCLEVBQUUsR0FBR2pCLE9BQU9rQixZQUFZdkMsT0FBT3FCLE9BQU87UUFBQztRQUFhO0tBQWM7SUFDbEksT0FDQSxxREFBcUQsaUJBQ3JEUCxnREFBbUIsQ0FBQyxLQUFLO1FBQUVXLFdBQVdWLGdEQUFJQSxDQUFDLHdCQUF3QlU7UUFBWWdCLE1BQU1YLGFBQWEsTUFBTVk7UUFBV1QsU0FBU0E7SUFBUSxpQkFDaEluQixnREFBbUIsQ0FBQ0csZ0RBQUlBLEVBQUVaLE9BQU9tQixNQUFNLENBQUMsQ0FBQyxHQUFHZSxXQUFXO1FBQUVJLFlBQVk7UUFBOEJDLCtCQUErQjtRQUFPQyx1QkFBdUI7UUFBT0MsaUJBQWlCO0lBQU07QUFDdE07QUFDQSxpRUFBZTFCLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vVGh1bWJuYWlsLmpzP2Q4YzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgUGFnZSBmcm9tICcuL1BhZ2UuanMnO1xuaW1wb3J0IHsgaXNQcm92aWRlZCB9IGZyb20gJy4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB1c2VEb2N1bWVudENvbnRleHQgZnJvbSAnLi9zaGFyZWQvaG9va3MvdXNlRG9jdW1lbnRDb250ZXh0LmpzJztcbi8qKlxuICogRGlzcGxheXMgYSB0aHVtYm5haWwgb2YgYSBwYWdlLiBEb2VzIG5vdCByZW5kZXIgdGhlIGFubm90YXRpb24gbGF5ZXIgb3IgdGhlIHRleHQgbGF5ZXIuIERvZXMgbm90IHJlZ2lzdGVyIGl0c2VsZiBhcyBhIGxpbmsgdGFyZ2V0LCBzbyB0aGUgdXNlciB3aWxsIG5vdCBiZSBzY3JvbGxlZCB0byBhIFRodW1ibmFpbCBjb21wb25lbnQgd2hlbiBjbGlja2VkIG9uIGFuIGludGVybmFsIGxpbmsgKGUuZy4gaW4gVGFibGUgb2YgQ29udGVudHMpLiBXaGVuIGNsaWNrZWQsIGF0dGVtcHRzIHRvIG5hdmlnYXRlIHRvIHRoZSBwYWdlIGNsaWNrZWQgKHNpbWlsYXJseSB0byBhIGxpbmsgaW4gT3V0bGluZSkuXG4gKlxuICogU2hvdWxkIGJlIHBsYWNlZCBpbnNpZGUgYDxEb2N1bWVudCAvPmAuIEFsdGVybmF0aXZlbHksIGl0IGNhbiBoYXZlIGBwZGZgIHByb3AgcGFzc2VkLCB3aGljaCBjYW4gYmUgb2J0YWluZWQgZnJvbSBgPERvY3VtZW50IC8+YCdzIGBvbkxvYWRTdWNjZXNzYCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuY29uc3QgVGh1bWJuYWlsID0gZnVuY3Rpb24gVGh1bWJuYWlsKHByb3BzKSB7XG4gICAgY29uc3QgZG9jdW1lbnRDb250ZXh0ID0gdXNlRG9jdW1lbnRDb250ZXh0KCk7XG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvY3VtZW50Q29udGV4dCksIHByb3BzKTtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgbGlua1NlcnZpY2UsIG9uSXRlbUNsaWNrLCBwYWdlSW5kZXg6IHBhZ2VJbmRleFByb3BzLCBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyUHJvcHMsIHBkZiwgfSA9IG1lcmdlZFByb3BzO1xuICAgIGludmFyaWFudChwZGYsICdBdHRlbXB0ZWQgdG8gbG9hZCBhIHRodW1ibmFpbCwgYnV0IG5vIGRvY3VtZW50IHdhcyBzcGVjaWZpZWQuIFdyYXAgPFRodW1ibmFpbCAvPiBpbiBhIDxEb2N1bWVudCAvPiBvciBwYXNzIGV4cGxpY2l0IGBwZGZgIHByb3AuJyk7XG4gICAgY29uc3QgcGFnZUluZGV4ID0gaXNQcm92aWRlZChwYWdlTnVtYmVyUHJvcHMpID8gcGFnZU51bWJlclByb3BzIC0gMSA6IHBhZ2VJbmRleFByb3BzICE9PSBudWxsICYmIHBhZ2VJbmRleFByb3BzICE9PSB2b2lkIDAgPyBwYWdlSW5kZXhQcm9wcyA6IG51bGw7XG4gICAgY29uc3QgcGFnZU51bWJlciA9IHBhZ2VOdW1iZXJQcm9wcyAhPT0gbnVsbCAmJiBwYWdlTnVtYmVyUHJvcHMgIT09IHZvaWQgMCA/IHBhZ2VOdW1iZXJQcm9wcyA6IChpc1Byb3ZpZGVkKHBhZ2VJbmRleFByb3BzKSA/IHBhZ2VJbmRleFByb3BzICsgMSA6IG51bGwpO1xuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCFpc1Byb3ZpZGVkKHBhZ2VJbmRleCkgfHwgIXBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnZhcmlhbnQob25JdGVtQ2xpY2sgfHwgbGlua1NlcnZpY2UsICdFaXRoZXIgb25JdGVtQ2xpY2sgY2FsbGJhY2sgb3IgbGlua1NlcnZpY2UgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIG5hdmlnYXRlIHRvIGFuIG91dGxpbmUgaXRlbS4nKTtcbiAgICAgICAgaWYgKG9uSXRlbUNsaWNrKSB7XG4gICAgICAgICAgICBvbkl0ZW1DbGljayh7XG4gICAgICAgICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5rU2VydmljZSkge1xuICAgICAgICAgICAgbGlua1NlcnZpY2UuZ29Ub1BhZ2UocGFnZU51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3BzLCBvbkl0ZW1DbGljazogb25JdGVtQ2xpY2tQcm9wcyB9ID0gcHJvcHMsIHBhZ2VQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiY2xhc3NOYW1lXCIsIFwib25JdGVtQ2xpY2tcIl0pO1xuICAgIHJldHVybiAoXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1pcy12YWxpZCAqL1xuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdyZWFjdC1wZGZfX1RodW1ibmFpbCcsIGNsYXNzTmFtZSksIGhyZWY6IHBhZ2VOdW1iZXIgPyAnIycgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG9uQ2xpY2sgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlLCBPYmplY3QuYXNzaWduKHt9LCBwYWdlUHJvcHMsIHsgX2NsYXNzTmFtZTogXCJyZWFjdC1wZGZfX1RodW1ibmFpbF9fcGFnZVwiLCBfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZTogZmFsc2UsIHJlbmRlckFubm90YXRpb25MYXllcjogZmFsc2UsIHJlbmRlclRleHRMYXllcjogZmFsc2UgfSkpKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgVGh1bWJuYWlsO1xuIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiUmVhY3QiLCJjbHN4IiwiaW52YXJpYW50IiwiUGFnZSIsImlzUHJvdmlkZWQiLCJ1c2VEb2N1bWVudENvbnRleHQiLCJUaHVtYm5haWwiLCJwcm9wcyIsImRvY3VtZW50Q29udGV4dCIsIm1lcmdlZFByb3BzIiwiYXNzaWduIiwiY2xhc3NOYW1lIiwibGlua1NlcnZpY2UiLCJvbkl0ZW1DbGljayIsInBhZ2VJbmRleCIsInBhZ2VJbmRleFByb3BzIiwicGFnZU51bWJlciIsInBhZ2VOdW1iZXJQcm9wcyIsInBkZiIsIm9uQ2xpY2siLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiZ29Ub1BhZ2UiLCJjbGFzc05hbWVQcm9wcyIsIm9uSXRlbUNsaWNrUHJvcHMiLCJwYWdlUHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsInVuZGVmaW5lZCIsIl9jbGFzc05hbWUiLCJfZW5hYmxlUmVnaXN0ZXJVbnJlZ2lzdGVyUGFnZSIsInJlbmRlckFubm90YXRpb25MYXllciIsInJlbmRlclRleHRMYXllciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Thumbnail.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js":
/*!**************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/pdfjs.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist */ \"(ssr)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.js\");\n\nconst pdfjs =  true ? pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__, 2)));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pdfjs);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3BkZmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQztBQUMxQyxNQUFNQyxRQUFTLEtBQXdCRCxHQUFHQSx1Q0FBc0IsR0FBR0Esd01BQVdBO0FBQzlFLGlFQUFlQyxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3BkZmpzLmpzP2Q5MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGRmanNNb2R1bGUgZnJvbSAncGRmanMtZGlzdCc7XG5jb25zdCBwZGZqcyA9ICgnZGVmYXVsdCcgaW4gcGRmanNNb2R1bGUgPyBwZGZqc01vZHVsZVsnZGVmYXVsdCddIDogcGRmanNNb2R1bGUpO1xuZXhwb3J0IGRlZmF1bHQgcGRmanM7XG4iXSwibmFtZXMiOlsicGRmanNNb2R1bGUiLCJwZGZqcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HEADING_PATTERN: () => (/* binding */ HEADING_PATTERN),\n/* harmony export */   PDF_ROLE_TO_HTML_ROLE: () => (/* binding */ PDF_ROLE_TO_HTML_ROLE)\n/* harmony export */ });\n// From pdfjs-dist/lib/web/struct_tree_layer_builder.js\nconst PDF_ROLE_TO_HTML_ROLE = {\n    // Document level structure types\n    Document: null,\n    DocumentFragment: null,\n    // Grouping level structure types\n    Part: \"group\",\n    Sect: \"group\",\n    Div: \"group\",\n    Aside: \"note\",\n    NonStruct: \"none\",\n    // Block level structure types\n    P: null,\n    // H<n>,\n    H: \"heading\",\n    Title: null,\n    FENote: \"note\",\n    // Sub-block level structure type\n    Sub: \"group\",\n    // General inline level structure types\n    Lbl: null,\n    Span: null,\n    Em: null,\n    Strong: null,\n    Link: \"link\",\n    Annot: \"note\",\n    Form: \"form\",\n    // Ruby and Warichu structure types\n    Ruby: null,\n    RB: null,\n    RT: null,\n    RP: null,\n    Warichu: null,\n    WT: null,\n    WP: null,\n    // List standard structure types\n    L: \"list\",\n    LI: \"listitem\",\n    LBody: null,\n    // Table standard structure types\n    Table: \"table\",\n    TR: \"row\",\n    TH: \"columnheader\",\n    TD: \"cell\",\n    THead: \"columnheader\",\n    TBody: null,\n    TFoot: null,\n    // Standard structure type Caption\n    Caption: null,\n    // Standard structure type Figure\n    Figure: \"figure\",\n    // Standard structure type Formula\n    Formula: null,\n    // standard structure type Artifact\n    Artifact: null\n};\nconst HEADING_PATTERN = /^H(\\d+)$/;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx1REFBdUQ7QUFDaEQsTUFBTUEsd0JBQXdCO0lBQ2pDLGlDQUFpQztJQUNqQ0MsVUFBVTtJQUNWQyxrQkFBa0I7SUFDbEIsaUNBQWlDO0lBQ2pDQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLFdBQVc7SUFDWCw4QkFBOEI7SUFDOUJDLEdBQUc7SUFDSCxRQUFRO0lBQ1JDLEdBQUc7SUFDSEMsT0FBTztJQUNQQyxRQUFRO0lBQ1IsaUNBQWlDO0lBQ2pDQyxLQUFLO0lBQ0wsdUNBQXVDO0lBQ3ZDQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsSUFBSTtJQUNKQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxNQUFNO0lBQ04sbUNBQW1DO0lBQ25DQyxNQUFNO0lBQ05DLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLFNBQVM7SUFDVEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0osZ0NBQWdDO0lBQ2hDQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsT0FBTztJQUNQLGlDQUFpQztJQUNqQ0MsT0FBTztJQUNQQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsT0FBTztJQUNQLGtDQUFrQztJQUNsQ0MsU0FBUztJQUNULGlDQUFpQztJQUNqQ0MsUUFBUTtJQUNSLGtDQUFrQztJQUNsQ0MsU0FBUztJQUNULG1DQUFtQztJQUNuQ0MsVUFBVTtBQUNkLEVBQUU7QUFDSyxNQUFNQyxrQkFBa0IsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9zaGFyZWQvY29uc3RhbnRzLmpzPzZmZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnJvbSBwZGZqcy1kaXN0L2xpYi93ZWIvc3RydWN0X3RyZWVfbGF5ZXJfYnVpbGRlci5qc1xuZXhwb3J0IGNvbnN0IFBERl9ST0xFX1RPX0hUTUxfUk9MRSA9IHtcbiAgICAvLyBEb2N1bWVudCBsZXZlbCBzdHJ1Y3R1cmUgdHlwZXNcbiAgICBEb2N1bWVudDogbnVsbCwgLy8gVGhlcmUncyBhIFwiZG9jdW1lbnRcIiByb2xlLCBidXQgaXQgZG9lc24ndCBtYWtlIHNlbnNlIGhlcmUuXG4gICAgRG9jdW1lbnRGcmFnbWVudDogbnVsbCxcbiAgICAvLyBHcm91cGluZyBsZXZlbCBzdHJ1Y3R1cmUgdHlwZXNcbiAgICBQYXJ0OiAnZ3JvdXAnLFxuICAgIFNlY3Q6ICdncm91cCcsIC8vIFhYWDogVGhlcmUncyBhIFwic2VjdGlvblwiIHJvbGUsIGJ1dCBpdCdzIGFic3RyYWN0LlxuICAgIERpdjogJ2dyb3VwJyxcbiAgICBBc2lkZTogJ25vdGUnLFxuICAgIE5vblN0cnVjdDogJ25vbmUnLFxuICAgIC8vIEJsb2NrIGxldmVsIHN0cnVjdHVyZSB0eXBlc1xuICAgIFA6IG51bGwsXG4gICAgLy8gSDxuPixcbiAgICBIOiAnaGVhZGluZycsXG4gICAgVGl0bGU6IG51bGwsXG4gICAgRkVOb3RlOiAnbm90ZScsXG4gICAgLy8gU3ViLWJsb2NrIGxldmVsIHN0cnVjdHVyZSB0eXBlXG4gICAgU3ViOiAnZ3JvdXAnLFxuICAgIC8vIEdlbmVyYWwgaW5saW5lIGxldmVsIHN0cnVjdHVyZSB0eXBlc1xuICAgIExibDogbnVsbCxcbiAgICBTcGFuOiBudWxsLFxuICAgIEVtOiBudWxsLFxuICAgIFN0cm9uZzogbnVsbCxcbiAgICBMaW5rOiAnbGluaycsXG4gICAgQW5ub3Q6ICdub3RlJyxcbiAgICBGb3JtOiAnZm9ybScsXG4gICAgLy8gUnVieSBhbmQgV2FyaWNodSBzdHJ1Y3R1cmUgdHlwZXNcbiAgICBSdWJ5OiBudWxsLFxuICAgIFJCOiBudWxsLFxuICAgIFJUOiBudWxsLFxuICAgIFJQOiBudWxsLFxuICAgIFdhcmljaHU6IG51bGwsXG4gICAgV1Q6IG51bGwsXG4gICAgV1A6IG51bGwsXG4gICAgLy8gTGlzdCBzdGFuZGFyZCBzdHJ1Y3R1cmUgdHlwZXNcbiAgICBMOiAnbGlzdCcsXG4gICAgTEk6ICdsaXN0aXRlbScsXG4gICAgTEJvZHk6IG51bGwsXG4gICAgLy8gVGFibGUgc3RhbmRhcmQgc3RydWN0dXJlIHR5cGVzXG4gICAgVGFibGU6ICd0YWJsZScsXG4gICAgVFI6ICdyb3cnLFxuICAgIFRIOiAnY29sdW1uaGVhZGVyJyxcbiAgICBURDogJ2NlbGwnLFxuICAgIFRIZWFkOiAnY29sdW1uaGVhZGVyJyxcbiAgICBUQm9keTogbnVsbCxcbiAgICBURm9vdDogbnVsbCxcbiAgICAvLyBTdGFuZGFyZCBzdHJ1Y3R1cmUgdHlwZSBDYXB0aW9uXG4gICAgQ2FwdGlvbjogbnVsbCxcbiAgICAvLyBTdGFuZGFyZCBzdHJ1Y3R1cmUgdHlwZSBGaWd1cmVcbiAgICBGaWd1cmU6ICdmaWd1cmUnLFxuICAgIC8vIFN0YW5kYXJkIHN0cnVjdHVyZSB0eXBlIEZvcm11bGFcbiAgICBGb3JtdWxhOiBudWxsLFxuICAgIC8vIHN0YW5kYXJkIHN0cnVjdHVyZSB0eXBlIEFydGlmYWN0XG4gICAgQXJ0aWZhY3Q6IG51bGwsXG59O1xuZXhwb3J0IGNvbnN0IEhFQURJTkdfUEFUVEVSTiA9IC9eSChcXGQrKSQvO1xuIl0sIm5hbWVzIjpbIlBERl9ST0xFX1RPX0hUTUxfUk9MRSIsIkRvY3VtZW50IiwiRG9jdW1lbnRGcmFnbWVudCIsIlBhcnQiLCJTZWN0IiwiRGl2IiwiQXNpZGUiLCJOb25TdHJ1Y3QiLCJQIiwiSCIsIlRpdGxlIiwiRkVOb3RlIiwiU3ViIiwiTGJsIiwiU3BhbiIsIkVtIiwiU3Ryb25nIiwiTGluayIsIkFubm90IiwiRm9ybSIsIlJ1YnkiLCJSQiIsIlJUIiwiUlAiLCJXYXJpY2h1IiwiV1QiLCJXUCIsIkwiLCJMSSIsIkxCb2R5IiwiVGFibGUiLCJUUiIsIlRIIiwiVEQiLCJUSGVhZCIsIlRCb2R5IiwiVEZvb3QiLCJDYXB0aW9uIiwiRmlndXJlIiwiRm9ybXVsYSIsIkFydGlmYWN0IiwiSEVBRElOR19QQVRURVJOIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useCachedValue.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/hooks/useCachedValue.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useCachedValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nfunction useCachedValue(getter) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const currentValue = ref.current;\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(currentValue)) {\n        return ()=>currentValue;\n    }\n    return ()=>{\n        const value = getter();\n        ref.current = value;\n        return value;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VDYWNoZWRWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7NkRBQytCO0FBQ1M7QUFDekIsU0FBU0UsZUFBZUMsTUFBTTtJQUN6QyxNQUFNQyxNQUFNSiw2Q0FBTUE7SUFDbEIsTUFBTUssZUFBZUQsSUFBSUUsT0FBTztJQUNoQyxJQUFJTCxvREFBU0EsQ0FBQ0ksZUFBZTtRQUN6QixPQUFPLElBQU1BO0lBQ2pCO0lBQ0EsT0FBTztRQUNILE1BQU1FLFFBQVFKO1FBQ2RDLElBQUlFLE9BQU8sR0FBR0M7UUFDZCxPQUFPQTtJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vc2hhcmVkL2hvb2tzL3VzZUNhY2hlZFZhbHVlLmpzPzZkZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlQ2FjaGVkVmFsdWUoZ2V0dGVyKSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gcmVmLmN1cnJlbnQ7XG4gICAgaWYgKGlzRGVmaW5lZChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBjdXJyZW50VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVJlZiIsImlzRGVmaW5lZCIsInVzZUNhY2hlZFZhbHVlIiwiZ2V0dGVyIiwicmVmIiwiY3VycmVudFZhbHVlIiwiY3VycmVudCIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useCachedValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useDocumentContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _DocumentContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../DocumentContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/DocumentContext.js\");\n\n\nfunction useDocumentContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_DocumentContext_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VEb2N1bWVudENvbnRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1DO0FBQ29CO0FBQ3hDLFNBQVNFO0lBQ3BCLE9BQU9GLGlEQUFVQSxDQUFDQywyREFBZUE7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vc2hhcmVkL2hvb2tzL3VzZURvY3VtZW50Q29udGV4dC5qcz85MTM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRG9jdW1lbnRDb250ZXh0IGZyb20gJy4uLy4uL0RvY3VtZW50Q29udGV4dC5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VEb2N1bWVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoRG9jdW1lbnRDb250ZXh0KTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VDb250ZXh0IiwiRG9jdW1lbnRDb250ZXh0IiwidXNlRG9jdW1lbnRDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useOutlineContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/hooks/useOutlineContext.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useOutlineContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _OutlineContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../OutlineContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/OutlineContext.js\");\n\n\nfunction useOutlineContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_OutlineContext_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VPdXRsaW5lQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDa0I7QUFDdEMsU0FBU0U7SUFDcEIsT0FBT0YsaURBQVVBLENBQUNDLDBEQUFjQTtBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9zaGFyZWQvaG9va3MvdXNlT3V0bGluZUNvbnRleHQuanM/NTE1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE91dGxpbmVDb250ZXh0IGZyb20gJy4uLy4uL091dGxpbmVDb250ZXh0LmpzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZU91dGxpbmVDb250ZXh0KCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KE91dGxpbmVDb250ZXh0KTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VDb250ZXh0IiwiT3V0bGluZUNvbnRleHQiLCJ1c2VPdXRsaW5lQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useOutlineContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js":
/*!************************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ usePageContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _PageContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../PageContext.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/PageContext.js\");\n\n\nfunction usePageContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_PageContext_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VQYWdlQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUM7QUFDWTtBQUNoQyxTQUFTRTtJQUNwQixPQUFPRixpREFBVUEsQ0FBQ0MsdURBQVdBO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VQYWdlQ29udGV4dC5qcz8yN2JmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUGFnZUNvbnRleHQgZnJvbSAnLi4vLi4vUGFnZUNvbnRleHQuanMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlUGFnZUNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoUGFnZUNvbnRleHQpO1xufVxuIl0sIm5hbWVzIjpbInVzZUNvbnRleHQiLCJQYWdlQ29udGV4dCIsInVzZVBhZ2VDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useResolver)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction reducer(state, action) {\n    switch(action.type){\n        case \"RESOLVE\":\n            return {\n                value: action.value,\n                error: undefined\n            };\n        case \"REJECT\":\n            return {\n                value: false,\n                error: action.error\n            };\n        case \"RESET\":\n            return {\n                value: undefined,\n                error: undefined\n            };\n        default:\n            return state;\n    }\n}\nfunction useResolver() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, {\n        value: undefined,\n        error: undefined\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9ob29rcy91c2VSZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtQztBQUNuQyxTQUFTQyxRQUFRQyxLQUFLLEVBQUVDLE1BQU07SUFDMUIsT0FBUUEsT0FBT0MsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPO2dCQUFFQyxPQUFPRixPQUFPRSxLQUFLO2dCQUFFQyxPQUFPQztZQUFVO1FBQ25ELEtBQUs7WUFDRCxPQUFPO2dCQUFFRixPQUFPO2dCQUFPQyxPQUFPSCxPQUFPRyxLQUFLO1lBQUM7UUFDL0MsS0FBSztZQUNELE9BQU87Z0JBQUVELE9BQU9FO2dCQUFXRCxPQUFPQztZQUFVO1FBQ2hEO1lBQ0ksT0FBT0w7SUFDZjtBQUNKO0FBQ2UsU0FBU007SUFDcEIsT0FBT1IsaURBQVVBLENBQUVDLFNBQVU7UUFBRUksT0FBT0U7UUFBV0QsT0FBT0M7SUFBVTtBQUN0RSIsInNvdXJjZXMiOlsid2VicGFjazovL2RhdGEtYm90Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9zaGFyZWQvaG9va3MvdXNlUmVzb2x2ZXIuanM/MGM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWR1Y2VyIH0gZnJvbSAncmVhY3QnO1xuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdSRVNPTFZFJzpcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBhY3Rpb24udmFsdWUsIGVycm9yOiB1bmRlZmluZWQgfTtcbiAgICAgICAgY2FzZSAnUkVKRUNUJzpcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSwgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICAgICAgICBjYXNlICdSRVNFVCc6XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBlcnJvcjogdW5kZWZpbmVkIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlUmVzb2x2ZXIoKSB7XG4gICAgcmV0dXJuIHVzZVJlZHVjZXIoKHJlZHVjZXIpLCB7IHZhbHVlOiB1bmRlZmluZWQsIGVycm9yOiB1bmRlZmluZWQgfSk7XG59XG4iXSwibmFtZXMiOlsidXNlUmVkdWNlciIsInJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJ2YWx1ZSIsImVycm9yIiwidW5kZWZpbmVkIiwidXNlUmVzb2x2ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/propTypes.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/propTypes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventProps: () => (/* binding */ eventProps),\n/* harmony export */   isClassName: () => (/* binding */ isClassName),\n/* harmony export */   isFile: () => (/* binding */ isFile),\n/* harmony export */   isLinkService: () => (/* binding */ isLinkService),\n/* harmony export */   isLinkTarget: () => (/* binding */ isLinkTarget),\n/* harmony export */   isPage: () => (/* binding */ isPage),\n/* harmony export */   isPageIndex: () => (/* binding */ isPageIndex),\n/* harmony export */   isPageNumber: () => (/* binding */ isPageNumber),\n/* harmony export */   isPdf: () => (/* binding */ isPdf),\n/* harmony export */   isRef: () => (/* binding */ isRef),\n/* harmony export */   isRenderMode: () => (/* binding */ isRenderMode),\n/* harmony export */   isRotate: () => (/* binding */ isRotate)\n/* harmony export */ });\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var make_event_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! make-event-props */ \"(ssr)/./node_modules/make-event-props/dist/esm/index.js\");\n/* harmony import */ var _pdfjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pdfjs.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/pdfjs.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\");\n/* harmony import */ var _LinkService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../LinkService.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/LinkService.js\");\n\n\n\n\n\nconst { PDFDataRangeTransport } = _pdfjs_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nconst eventProps = (()=>{\n    const result = {};\n    make_event_props__WEBPACK_IMPORTED_MODULE_1__.allEvents.forEach((eventName)=>{\n        result[eventName] = prop_types__WEBPACK_IMPORTED_MODULE_2__.func;\n    });\n    return result;\n})();\nconst isTypedArray = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType([\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Int8Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Uint8Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Uint8ClampedArray),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Int16Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Uint16Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Int32Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Uint32Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Float32Array),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Float64Array)\n]);\nconst fileTypes = [\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.string,\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(ArrayBuffer),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.shape({\n        data: prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType([\n            prop_types__WEBPACK_IMPORTED_MODULE_2__.string,\n            prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(ArrayBuffer),\n            prop_types__WEBPACK_IMPORTED_MODULE_2__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2__.number.isRequired),\n            isTypedArray\n        ]).isRequired\n    }),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.shape({\n        range: prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(PDFDataRangeTransport).isRequired\n    }),\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.shape({\n        url: prop_types__WEBPACK_IMPORTED_MODULE_2__.string.isRequired\n    })\n];\nif (typeof Blob !== \"undefined\") {\n    fileTypes.push(prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(Blob));\n}\nconst isClassName = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType([\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.string,\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2__.string)\n]);\nconst isFile = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType(fileTypes);\nconst isLinkService = prop_types__WEBPACK_IMPORTED_MODULE_2__.instanceOf(_LinkService_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nconst isLinkTarget = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOf([\n    \"_self\",\n    \"_blank\",\n    \"_parent\",\n    \"_top\"\n]);\nconst isPage = prop_types__WEBPACK_IMPORTED_MODULE_2__.shape({\n    commonObjs: prop_types__WEBPACK_IMPORTED_MODULE_2__.shape({}).isRequired,\n    getAnnotations: prop_types__WEBPACK_IMPORTED_MODULE_2__.func.isRequired,\n    getTextContent: prop_types__WEBPACK_IMPORTED_MODULE_2__.func.isRequired,\n    getViewport: prop_types__WEBPACK_IMPORTED_MODULE_2__.func.isRequired,\n    render: prop_types__WEBPACK_IMPORTED_MODULE_2__.func.isRequired\n});\nconst isPageIndex = function isPageIndex(props, propName, componentName) {\n    const { [propName]: pageIndex, pageNumber, pdf } = props;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pdf)) {\n        return null;\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pageIndex)) {\n        if (typeof pageIndex !== \"number\") {\n            return new Error(`\\`${propName}\\` of type \\`${typeof pageIndex}\\` supplied to \\`${componentName}\\`, expected \\`number\\`.`);\n        }\n        if (pageIndex < 0) {\n            return new Error(`Expected \\`${propName}\\` to be greater or equal to 0.`);\n        }\n        const { numPages } = pdf;\n        if (pageIndex + 1 > numPages) {\n            return new Error(`Expected \\`${propName}\\` to be less or equal to ${numPages - 1}.`);\n        }\n    } else if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pageNumber)) {\n        return new Error(`\\`${propName}\\` not supplied. Either pageIndex or pageNumber must be supplied to \\`${componentName}\\`.`);\n    }\n    // Everything is fine\n    return null;\n};\nconst isPageNumber = function isPageNumber(props, propName, componentName) {\n    const { [propName]: pageNumber, pageIndex, pdf } = props;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pdf)) {\n        return null;\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pageNumber)) {\n        if (typeof pageNumber !== \"number\") {\n            return new Error(`\\`${propName}\\` of type \\`${typeof pageNumber}\\` supplied to \\`${componentName}\\`, expected \\`number\\`.`);\n        }\n        if (pageNumber < 1) {\n            return new Error(`Expected \\`${propName}\\` to be greater or equal to 1.`);\n        }\n        const { numPages } = pdf;\n        if (pageNumber > numPages) {\n            return new Error(`Expected \\`${propName}\\` to be less or equal to ${numPages}.`);\n        }\n    } else if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.isDefined)(pageIndex)) {\n        return new Error(`\\`${propName}\\` not supplied. Either pageIndex or pageNumber must be supplied to \\`${componentName}\\`.`);\n    }\n    // Everything is fine\n    return null;\n};\nconst isPdf = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType([\n    // Ideally, this would be `PropTypes.instanceOf(PDFDocumentProxy)`, but it can't be imported.\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.any,\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOf([\n        false\n    ])\n]);\nconst isRef = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOfType([\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.func,\n    prop_types__WEBPACK_IMPORTED_MODULE_2__.exact({\n        current: prop_types__WEBPACK_IMPORTED_MODULE_2__.any\n    })\n]);\nconst isRenderMode = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOf([\n    \"canvas\",\n    \"custom\",\n    \"none\",\n    \"svg\"\n]);\nconst isRotate = prop_types__WEBPACK_IMPORTED_MODULE_2__.oneOf([\n    0,\n    90,\n    180,\n    270\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9wcm9wVHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDVTtBQUNiO0FBQ087QUFDSztBQUM1QyxNQUFNLEVBQUVLLHFCQUFxQixFQUFFLEdBQUdILGlEQUFLQTtBQUNoQyxNQUFNSSxhQUFhLENBQUM7SUFDdkIsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCTix1REFBU0EsQ0FBQ08sT0FBTyxDQUFDLENBQUNDO1FBQ2ZGLE1BQU0sQ0FBQ0UsVUFBVSxHQUFHVCw0Q0FBYztJQUN0QztJQUNBLE9BQU9PO0FBQ1gsS0FBSztBQUNMLE1BQU1JLGVBQWVYLGlEQUFtQixDQUFDO0lBQ3JDQSxrREFBb0IsQ0FBQ2M7SUFDckJkLGtEQUFvQixDQUFDZTtJQUNyQmYsa0RBQW9CLENBQUNnQjtJQUNyQmhCLGtEQUFvQixDQUFDaUI7SUFDckJqQixrREFBb0IsQ0FBQ2tCO0lBQ3JCbEIsa0RBQW9CLENBQUNtQjtJQUNyQm5CLGtEQUFvQixDQUFDb0I7SUFDckJwQixrREFBb0IsQ0FBQ3FCO0lBQ3JCckIsa0RBQW9CLENBQUNzQjtDQUN4QjtBQUNELE1BQU1DLFlBQVk7SUFDZHZCLDhDQUFnQjtJQUNoQkEsa0RBQW9CLENBQUN5QjtJQUNyQnpCLDZDQUFlLENBQUM7UUFDWjJCLE1BQU0zQixpREFBbUIsQ0FBQztZQUN0QkEsOENBQWdCO1lBQ2hCQSxrREFBb0IsQ0FBQ3lCO1lBQ3JCekIsK0NBQWlCLENBQUNBLDhDQUFnQixDQUFDOEIsVUFBVTtZQUM3Q25CO1NBQ0gsRUFBRW1CLFVBQVU7SUFDakI7SUFDQTlCLDZDQUFlLENBQUM7UUFDWitCLE9BQU8vQixrREFBb0IsQ0FBQ0ssdUJBQXVCeUIsVUFBVTtJQUNqRTtJQUNBOUIsNkNBQWUsQ0FBQztRQUNaZ0MsS0FBS2hDLDhDQUFnQixDQUFDOEIsVUFBVTtJQUNwQztDQUNIO0FBQ0QsSUFBSSxPQUFPRyxTQUFT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QUM1QixPQUFPLElBQUlHLE1BQU0sQ0FBQyxFQUFFLEVBQUVMLFNBQVMsc0VBQXNFLEVBQUVDLGNBQWMsR0FBRyxDQUFDO0lBQzdIO0lBQ0EscUJBQXFCO0lBQ3JCLE9BQU87QUFDWCxFQUFFO0FBQ0ssTUFBTU8sUUFBUXhELGlEQUFtQixDQUFDO0lBQ3JDLDZGQUE2RjtJQUM3RkEsMkNBQWE7SUFDYkEsNkNBQWUsQ0FBQztRQUFDO0tBQU07Q0FDMUIsRUFBRTtBQUNJLE1BQU0wRCxRQUFRMUQsaURBQW1CLENBQUM7SUFDckNBLDRDQUFjO0lBQ2RBLDZDQUFlLENBQUM7UUFDWjRELFNBQVM1RCwyQ0FBYTtJQUMxQjtDQUNILEVBQUU7QUFDSSxNQUFNNkQsZUFBZTdELDZDQUFlLENBQUM7SUFBQztJQUFVO0lBQVU7SUFBUTtDQUFNLEVBQUU7QUFDMUUsTUFBTThELFdBQVc5RCw2Q0FBZSxDQUFDO0lBQUM7SUFBRztJQUFJO0lBQUs7Q0FBSSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9wcm9wVHlwZXMuanM/MzRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYWxsRXZlbnRzIH0gZnJvbSAnbWFrZS1ldmVudC1wcm9wcyc7XG5pbXBvcnQgcGRmanMgZnJvbSAnLi4vcGRmanMuanMnO1xuaW1wb3J0IHsgaXNEZWZpbmVkIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgTGlua1NlcnZpY2UgZnJvbSAnLi4vTGlua1NlcnZpY2UuanMnO1xuY29uc3QgeyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgfSA9IHBkZmpzO1xuZXhwb3J0IGNvbnN0IGV2ZW50UHJvcHMgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGFsbEV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgcmVzdWx0W2V2ZW50TmFtZV0gPSBQcm9wVHlwZXMuZnVuYztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSkoKTtcbmNvbnN0IGlzVHlwZWRBcnJheSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKEludDhBcnJheSksXG4gICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoVWludDhBcnJheSksXG4gICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoVWludDhDbGFtcGVkQXJyYXkpLFxuICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKEludDE2QXJyYXkpLFxuICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKFVpbnQxNkFycmF5KSxcbiAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihJbnQzMkFycmF5KSxcbiAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihVaW50MzJBcnJheSksXG4gICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoRmxvYXQzMkFycmF5KSxcbiAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihGbG9hdDY0QXJyYXkpLFxuXSk7XG5jb25zdCBmaWxlVHlwZXMgPSBbXG4gICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihBcnJheUJ1ZmZlciksXG4gICAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZGF0YTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICAgICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoQXJyYXlCdWZmZXIpLFxuICAgICAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkKSxcbiAgICAgICAgICAgIGlzVHlwZWRBcnJheSxcbiAgICAgICAgXSkuaXNSZXF1aXJlZCxcbiAgICB9KSxcbiAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICByYW5nZTogUHJvcFR5cGVzLmluc3RhbmNlT2YoUERGRGF0YVJhbmdlVHJhbnNwb3J0KS5pc1JlcXVpcmVkLFxuICAgIH0pLFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIHVybDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIH0pLFxuXTtcbmlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmaWxlVHlwZXMucHVzaChQcm9wVHlwZXMuaW5zdGFuY2VPZihCbG9iKSk7XG59XG5leHBvcnQgY29uc3QgaXNDbGFzc05hbWUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuXSk7XG5leHBvcnQgY29uc3QgaXNGaWxlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShmaWxlVHlwZXMpO1xuZXhwb3J0IGNvbnN0IGlzTGlua1NlcnZpY2UgPSBQcm9wVHlwZXMuaW5zdGFuY2VPZihMaW5rU2VydmljZSk7XG5leHBvcnQgY29uc3QgaXNMaW5rVGFyZ2V0ID0gUHJvcFR5cGVzLm9uZU9mKFsnX3NlbGYnLCAnX2JsYW5rJywgJ19wYXJlbnQnLCAnX3RvcCddKTtcbmV4cG9ydCBjb25zdCBpc1BhZ2UgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGNvbW1vbk9ianM6IFByb3BUeXBlcy5zaGFwZSh7fSkuaXNSZXF1aXJlZCxcbiAgICBnZXRBbm5vdGF0aW9uczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRUZXh0Q29udGVudDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRWaWV3cG9ydDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG59KTtcbmV4cG9ydCBjb25zdCBpc1BhZ2VJbmRleCA9IGZ1bmN0aW9uIGlzUGFnZUluZGV4KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGNvbnN0IHsgW3Byb3BOYW1lXTogcGFnZUluZGV4LCBwYWdlTnVtYmVyLCBwZGYgfSA9IHByb3BzO1xuICAgIGlmICghaXNEZWZpbmVkKHBkZikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0RlZmluZWQocGFnZUluZGV4KSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhZ2VJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYFxcYCR7cHJvcE5hbWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgcGFnZUluZGV4fVxcYCBzdXBwbGllZCB0byBcXGAke2NvbXBvbmVudE5hbWV9XFxgLCBleHBlY3RlZCBcXGBudW1iZXJcXGAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2VJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEV4cGVjdGVkIFxcYCR7cHJvcE5hbWV9XFxgIHRvIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG51bVBhZ2VzIH0gPSBwZGY7XG4gICAgICAgIGlmIChwYWdlSW5kZXggKyAxID4gbnVtUGFnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEV4cGVjdGVkIFxcYCR7cHJvcE5hbWV9XFxgIHRvIGJlIGxlc3Mgb3IgZXF1YWwgdG8gJHtudW1QYWdlcyAtIDF9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0RlZmluZWQocGFnZU51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgXFxgJHtwcm9wTmFtZX1cXGAgbm90IHN1cHBsaWVkLiBFaXRoZXIgcGFnZUluZGV4IG9yIHBhZ2VOdW1iZXIgbXVzdCBiZSBzdXBwbGllZCB0byBcXGAke2NvbXBvbmVudE5hbWV9XFxgLmApO1xuICAgIH1cbiAgICAvLyBFdmVyeXRoaW5nIGlzIGZpbmVcbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnQgY29uc3QgaXNQYWdlTnVtYmVyID0gZnVuY3Rpb24gaXNQYWdlTnVtYmVyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGNvbnN0IHsgW3Byb3BOYW1lXTogcGFnZU51bWJlciwgcGFnZUluZGV4LCBwZGYgfSA9IHByb3BzO1xuICAgIGlmICghaXNEZWZpbmVkKHBkZikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0RlZmluZWQocGFnZU51bWJlcikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWdlTnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgXFxgJHtwcm9wTmFtZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiBwYWdlTnVtYmVyfVxcYCBzdXBwbGllZCB0byBcXGAke2NvbXBvbmVudE5hbWV9XFxgLCBleHBlY3RlZCBcXGBudW1iZXJcXGAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZ2VOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBFeHBlY3RlZCBcXGAke3Byb3BOYW1lfVxcYCB0byBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBudW1QYWdlcyB9ID0gcGRmO1xuICAgICAgICBpZiAocGFnZU51bWJlciA+IG51bVBhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBFeHBlY3RlZCBcXGAke3Byb3BOYW1lfVxcYCB0byBiZSBsZXNzIG9yIGVxdWFsIHRvICR7bnVtUGFnZXN9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0RlZmluZWQocGFnZUluZGV4KSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBcXGAke3Byb3BOYW1lfVxcYCBub3Qgc3VwcGxpZWQuIEVpdGhlciBwYWdlSW5kZXggb3IgcGFnZU51bWJlciBtdXN0IGJlIHN1cHBsaWVkIHRvIFxcYCR7Y29tcG9uZW50TmFtZX1cXGAuYCk7XG4gICAgfVxuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgZmluZVxuICAgIHJldHVybiBudWxsO1xufTtcbmV4cG9ydCBjb25zdCBpc1BkZiA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIC8vIElkZWFsbHksIHRoaXMgd291bGQgYmUgYFByb3BUeXBlcy5pbnN0YW5jZU9mKFBERkRvY3VtZW50UHJveHkpYCwgYnV0IGl0IGNhbid0IGJlIGltcG9ydGVkLlxuICAgIFByb3BUeXBlcy5hbnksXG4gICAgUHJvcFR5cGVzLm9uZU9mKFtmYWxzZV0pLFxuXSk7XG5leHBvcnQgY29uc3QgaXNSZWYgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuZnVuYyxcbiAgICBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgICAgICBjdXJyZW50OiBQcm9wVHlwZXMuYW55LFxuICAgIH0pLFxuXSk7XG5leHBvcnQgY29uc3QgaXNSZW5kZXJNb2RlID0gUHJvcFR5cGVzLm9uZU9mKFsnY2FudmFzJywgJ2N1c3RvbScsICdub25lJywgJ3N2ZyddKTtcbmV4cG9ydCBjb25zdCBpc1JvdGF0ZSA9IFByb3BUeXBlcy5vbmVPZihbMCwgOTAsIDE4MCwgMjcwXSk7XG4iXSwibmFtZXMiOlsiUHJvcFR5cGVzIiwiYWxsRXZlbnRzIiwicGRmanMiLCJpc0RlZmluZWQiLCJMaW5rU2VydmljZSIsIlBERkRhdGFSYW5nZVRyYW5zcG9ydCIsImV2ZW50UHJvcHMiLCJyZXN1bHQiLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwiZnVuYyIsImlzVHlwZWRBcnJheSIsIm9uZU9mVHlwZSIsImluc3RhbmNlT2YiLCJJbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJmaWxlVHlwZXMiLCJzdHJpbmciLCJBcnJheUJ1ZmZlciIsInNoYXBlIiwiZGF0YSIsImFycmF5T2YiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwicmFuZ2UiLCJ1cmwiLCJCbG9iIiwicHVzaCIsImlzQ2xhc3NOYW1lIiwiaXNGaWxlIiwiaXNMaW5rU2VydmljZSIsImlzTGlua1RhcmdldCIsIm9uZU9mIiwiaXNQYWdlIiwiY29tbW9uT2JqcyIsImdldEFubm90YXRpb25zIiwiZ2V0VGV4dENvbnRlbnQiLCJnZXRWaWV3cG9ydCIsInJlbmRlciIsImlzUGFnZUluZGV4IiwicHJvcHMiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJwYWdlSW5kZXgiLCJwYWdlTnVtYmVyIiwicGRmIiwiRXJyb3IiLCJudW1QYWdlcyIsImlzUGFnZU51bWJlciIsImlzUGRmIiwiYW55IiwiaXNSZWYiLCJleGFjdCIsImN1cnJlbnQiLCJpc1JlbmRlck1vZGUiLCJpc1JvdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/propTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/structTreeUtils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/structTreeUtils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getBaseAttributes: () => (/* binding */ getBaseAttributes),\n/* harmony export */   getRoleAttributes: () => (/* binding */ getRoleAttributes),\n/* harmony export */   isPdfRole: () => (/* binding */ isPdfRole),\n/* harmony export */   isStructTreeNode: () => (/* binding */ isStructTreeNode),\n/* harmony export */   isStructTreeNodeWithOnlyContentChild: () => (/* binding */ isStructTreeNodeWithOnlyContentChild)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/react-pdf/dist/esm/shared/constants.js\");\n\nfunction isPdfRole(role) {\n    return role in _constants_js__WEBPACK_IMPORTED_MODULE_0__.PDF_ROLE_TO_HTML_ROLE;\n}\nfunction isStructTreeNode(node) {\n    return \"children\" in node;\n}\nfunction isStructTreeNodeWithOnlyContentChild(node) {\n    if (!isStructTreeNode(node)) {\n        return false;\n    }\n    return node.children.length === 1 && 0 in node.children && \"id\" in node.children[0];\n}\nfunction getRoleAttributes(node) {\n    const attributes = {};\n    if (isStructTreeNode(node)) {\n        const { role } = node;\n        const matches = role.match(_constants_js__WEBPACK_IMPORTED_MODULE_0__.HEADING_PATTERN);\n        if (matches) {\n            attributes.role = \"heading\";\n            attributes[\"aria-level\"] = Number(matches[1]);\n        } else if (isPdfRole(role)) {\n            const htmlRole = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PDF_ROLE_TO_HTML_ROLE[role];\n            if (htmlRole) {\n                attributes.role = htmlRole;\n            }\n        }\n    }\n    return attributes;\n}\nfunction getBaseAttributes(node) {\n    const attributes = {};\n    if (isStructTreeNode(node)) {\n        if (node.alt !== undefined) {\n            attributes[\"aria-label\"] = node.alt;\n        }\n        if (node.lang !== undefined) {\n            attributes.lang = node.lang;\n        }\n        if (isStructTreeNodeWithOnlyContentChild(node)) {\n            const [child] = node.children;\n            if (child) {\n                const childAttributes = getBaseAttributes(child);\n                return Object.assign(Object.assign({}, attributes), childAttributes);\n            }\n        }\n    } else {\n        if (\"id\" in node) {\n            attributes[\"aria-owns\"] = node.id;\n        }\n    }\n    return attributes;\n}\nfunction getAttributes(node) {\n    if (!node) {\n        return null;\n    }\n    return Object.assign(Object.assign({}, getRoleAttributes(node)), getBaseAttributes(node));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC9zdHJ1Y3RUcmVlVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3RTtBQUNqRSxTQUFTRSxVQUFVQyxJQUFJO0lBQzFCLE9BQU9BLFFBQVFGLGdFQUFxQkE7QUFDeEM7QUFDTyxTQUFTRyxpQkFBaUJDLElBQUk7SUFDakMsT0FBTyxjQUFjQTtBQUN6QjtBQUNPLFNBQVNDLHFDQUFxQ0QsSUFBSTtJQUNyRCxJQUFJLENBQUNELGlCQUFpQkMsT0FBTztRQUN6QixPQUFPO0lBQ1g7SUFDQSxPQUFPQSxLQUFLRSxRQUFRLENBQUNDLE1BQU0sS0FBSyxLQUFLLEtBQUtILEtBQUtFLFFBQVEsSUFBSSxRQUFRRixLQUFLRSxRQUFRLENBQUMsRUFBRTtBQUN2RjtBQUNPLFNBQVNFLGtCQUFrQkosSUFBSTtJQUNsQyxNQUFNSyxhQUFhLENBQUM7SUFDcEIsSUFBSU4saUJBQWlCQyxPQUFPO1FBQ3hCLE1BQU0sRUFBRUYsSUFBSSxFQUFFLEdBQUdFO1FBQ2pCLE1BQU1NLFVBQVVSLEtBQUtTLEtBQUssQ0FBQ1osMERBQWVBO1FBQzFDLElBQUlXLFNBQVM7WUFDVEQsV0FBV1AsSUFBSSxHQUFHO1lBQ2xCTyxVQUFVLENBQUMsYUFBYSxHQUFHRyxPQUFPRixPQUFPLENBQUMsRUFBRTtRQUNoRCxPQUNLLElBQUlULFVBQVVDLE9BQU87WUFDdEIsTUFBTVcsV0FBV2IsZ0VBQXFCLENBQUNFLEtBQUs7WUFDNUMsSUFBSVcsVUFBVTtnQkFDVkosV0FBV1AsSUFBSSxHQUFHVztZQUN0QjtRQUNKO0lBQ0o7SUFDQSxPQUFPSjtBQUNYO0FBQ08sU0FBU0ssa0JBQWtCVixJQUFJO0lBQ2xDLE1BQU1LLGFBQWEsQ0FBQztJQUNwQixJQUFJTixpQkFBaUJDLE9BQU87UUFDeEIsSUFBSUEsS0FBS1csR0FBRyxLQUFLQyxXQUFXO1lBQ3hCUCxVQUFVLENBQUMsYUFBYSxHQUFHTCxLQUFLVyxHQUFHO1FBQ3ZDO1FBQ0EsSUFBSVgsS0FBS2EsSUFBSSxLQUFLRCxXQUFXO1lBQ3pCUCxXQUFXUSxJQUFJLEdBQUdiLEtBQUthLElBQUk7UUFDL0I7UUFDQSxJQUFJWixxQ0FBcUNELE9BQU87WUFDNUMsTUFBTSxDQUFDYyxNQUFNLEdBQUdkLEtBQUtFLFFBQVE7WUFDN0IsSUFBSVksT0FBTztnQkFDUCxNQUFNQyxrQkFBa0JMLGtCQUFrQkk7Z0JBQzFDLE9BQU9FLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1osYUFBYVU7WUFDeEQ7UUFDSjtJQUNKLE9BQ0s7UUFDRCxJQUFJLFFBQVFmLE1BQU07WUFDZEssVUFBVSxDQUFDLFlBQVksR0FBR0wsS0FBS2tCLEVBQUU7UUFDckM7SUFDSjtJQUNBLE9BQU9iO0FBQ1g7QUFDTyxTQUFTYyxjQUFjbkIsSUFBSTtJQUM5QixJQUFJLENBQUNBLE1BQU07UUFDUCxPQUFPO0lBQ1g7SUFDQSxPQUFPZ0IsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHYixrQkFBa0JKLFFBQVFVLGtCQUFrQlY7QUFDdkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXRhLWJvdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vc2hhcmVkL3N0cnVjdFRyZWVVdGlscy5qcz8zODI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhFQURJTkdfUEFUVEVSTiwgUERGX1JPTEVfVE9fSFRNTF9ST0xFIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGRmUm9sZShyb2xlKSB7XG4gICAgcmV0dXJuIHJvbGUgaW4gUERGX1JPTEVfVE9fSFRNTF9ST0xFO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RydWN0VHJlZU5vZGUobm9kZSkge1xuICAgIHJldHVybiAnY2hpbGRyZW4nIGluIG5vZGU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJ1Y3RUcmVlTm9kZVdpdGhPbmx5Q29udGVudENoaWxkKG5vZGUpIHtcbiAgICBpZiAoIWlzU3RydWN0VHJlZU5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgMCBpbiBub2RlLmNoaWxkcmVuICYmICdpZCcgaW4gbm9kZS5jaGlsZHJlblswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb2xlQXR0cmlidXRlcyhub2RlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChpc1N0cnVjdFRyZWVOb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHsgcm9sZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHJvbGUubWF0Y2goSEVBRElOR19QQVRURVJOKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucm9sZSA9ICdoZWFkaW5nJztcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2FyaWEtbGV2ZWwnXSA9IE51bWJlcihtYXRjaGVzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BkZlJvbGUocm9sZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxSb2xlID0gUERGX1JPTEVfVE9fSFRNTF9ST0xFW3JvbGVdO1xuICAgICAgICAgICAgaWYgKGh0bWxSb2xlKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5yb2xlID0gaHRtbFJvbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZUF0dHJpYnV0ZXMobm9kZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAoaXNTdHJ1Y3RUcmVlTm9kZShub2RlKSkge1xuICAgICAgICBpZiAobm9kZS5hbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1snYXJpYS1sYWJlbCddID0gbm9kZS5hbHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubGFuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmxhbmcgPSBub2RlLmxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZChub2RlKSkge1xuICAgICAgICAgICAgY29uc3QgW2NoaWxkXSA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEF0dHJpYnV0ZXMgPSBnZXRCYXNlQXR0cmlidXRlcyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICgnaWQnIGluIG5vZGUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ2FyaWEtb3ducyddID0gbm9kZS5pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldFJvbGVBdHRyaWJ1dGVzKG5vZGUpKSwgZ2V0QmFzZUF0dHJpYnV0ZXMobm9kZSkpO1xufVxuIl0sIm5hbWVzIjpbIkhFQURJTkdfUEFUVEVSTiIsIlBERl9ST0xFX1RPX0hUTUxfUk9MRSIsImlzUGRmUm9sZSIsInJvbGUiLCJpc1N0cnVjdFRyZWVOb2RlIiwibm9kZSIsImlzU3RydWN0VHJlZU5vZGVXaXRoT25seUNvbnRlbnRDaGlsZCIsImNoaWxkcmVuIiwibGVuZ3RoIiwiZ2V0Um9sZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwibWF0Y2hlcyIsIm1hdGNoIiwiTnVtYmVyIiwiaHRtbFJvbGUiLCJnZXRCYXNlQXR0cmlidXRlcyIsImFsdCIsInVuZGVmaW5lZCIsImxhbmciLCJjaGlsZCIsImNoaWxkQXR0cmlidXRlcyIsIk9iamVjdCIsImFzc2lnbiIsImlkIiwiZ2V0QXR0cmlidXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/structTreeUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/shared/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelRunningTask: () => (/* binding */ cancelRunningTask),\n/* harmony export */   dataURItoByteString: () => (/* binding */ dataURItoByteString),\n/* harmony export */   displayCORSWarning: () => (/* binding */ displayCORSWarning),\n/* harmony export */   displayWorkerWarning: () => (/* binding */ displayWorkerWarning),\n/* harmony export */   getDevicePixelRatio: () => (/* binding */ getDevicePixelRatio),\n/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),\n/* harmony export */   isBlob: () => (/* binding */ isBlob),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isCancelException: () => (/* binding */ isCancelException),\n/* harmony export */   isDataURI: () => (/* binding */ isDataURI),\n/* harmony export */   isDefined: () => (/* binding */ isDefined),\n/* harmony export */   isLocalFileSystem: () => (/* binding */ isLocalFileSystem),\n/* harmony export */   isProvided: () => (/* binding */ isProvided),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   loadFromFile: () => (/* binding */ loadFromFile),\n/* harmony export */   makePageCallback: () => (/* binding */ makePageCallback)\n/* harmony export */ });\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-invariant */ \"(ssr)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! warning */ \"(ssr)/./node_modules/warning/warning.js\");\n\n\n/**\n * Checks if we're running in a browser environment.\n */ const isBrowser = typeof document !== \"undefined\";\n/**\n * Checks whether we're running from a local file system.\n */ const isLocalFileSystem = isBrowser && window.location.protocol === \"file:\";\n/**\n * Checks whether a variable is defined.\n *\n * @param {*} variable Variable to check\n */ function isDefined(variable) {\n    return typeof variable !== \"undefined\";\n}\n/**\n * Checks whether a variable is defined and not null.\n *\n * @param {*} variable Variable to check\n */ function isProvided(variable) {\n    return isDefined(variable) && variable !== null;\n}\n/**\n * Checks whether a variable provided is a string.\n *\n * @param {*} variable Variable to check\n */ function isString(variable) {\n    return typeof variable === \"string\";\n}\n/**\n * Checks whether a variable provided is an ArrayBuffer.\n *\n * @param {*} variable Variable to check\n */ function isArrayBuffer(variable) {\n    return variable instanceof ArrayBuffer;\n}\n/**\n * Checks whether a variable provided is a Blob.\n *\n * @param {*} variable Variable to check\n */ function isBlob(variable) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(isBrowser, \"isBlob can only be used in a browser environment\");\n    return variable instanceof Blob;\n}\n/**\n * Checks whether a variable provided is a data URI.\n *\n * @param {*} variable String to check\n */ function isDataURI(variable) {\n    return isString(variable) && /^data:/.test(variable);\n}\nfunction dataURItoByteString(dataURI) {\n    (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(isDataURI(dataURI), \"Invalid data URI.\");\n    const [headersString = \"\", dataString = \"\"] = dataURI.split(\",\");\n    const headers = headersString.split(\";\");\n    if (headers.indexOf(\"base64\") !== -1) {\n        return atob(dataString);\n    }\n    return unescape(dataString);\n}\nfunction getDevicePixelRatio() {\n    return isBrowser && window.devicePixelRatio || 1;\n}\nconst allowFileAccessFromFilesTip = \"On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.\";\nfunction displayCORSWarning() {\n    warning__WEBPACK_IMPORTED_MODULE_1__(!isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);\n}\nfunction displayWorkerWarning() {\n    warning__WEBPACK_IMPORTED_MODULE_1__(!isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);\n}\nfunction cancelRunningTask(runningTask) {\n    if (runningTask && runningTask.cancel) runningTask.cancel();\n}\nfunction makePageCallback(page, scale) {\n    Object.defineProperty(page, \"width\", {\n        get () {\n            return this.view[2] * scale;\n        },\n        configurable: true\n    });\n    Object.defineProperty(page, \"height\", {\n        get () {\n            return this.view[3] * scale;\n        },\n        configurable: true\n    });\n    Object.defineProperty(page, \"originalWidth\", {\n        get () {\n            return this.view[2];\n        },\n        configurable: true\n    });\n    Object.defineProperty(page, \"originalHeight\", {\n        get () {\n            return this.view[3];\n        },\n        configurable: true\n    });\n    return page;\n}\nfunction isCancelException(error) {\n    return error.name === \"RenderingCancelledException\";\n}\nfunction loadFromFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = ()=>{\n            if (!reader.result) {\n                return reject(new Error(\"Error while reading a file.\"));\n            }\n            resolve(reader.result);\n        };\n        reader.onerror = (event)=>{\n            if (!event.target) {\n                return reject(new Error(\"Error while reading a file.\"));\n            }\n            const { error } = event.target;\n            if (!error) {\n                return reject(new Error(\"Error while reading a file.\"));\n            }\n            switch(error.code){\n                case error.NOT_FOUND_ERR:\n                    return reject(new Error(\"Error while reading a file: File not found.\"));\n                case error.SECURITY_ERR:\n                    return reject(new Error(\"Error while reading a file: Security error.\"));\n                case error.ABORT_ERR:\n                    return reject(new Error(\"Error while reading a file: Aborted.\"));\n                default:\n                    return reject(new Error(\"Error while reading a file.\"));\n            }\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDVDtBQUM5Qjs7Q0FFQyxHQUNNLE1BQU1FLFlBQVksT0FBT0MsYUFBYSxZQUFZO0FBQ3pEOztDQUVDLEdBQ00sTUFBTUMsb0JBQW9CRixhQUFhRyxPQUFPQyxRQUFRLENBQUNDLFFBQVEsS0FBSyxRQUFRO0FBQ25GOzs7O0NBSUMsR0FDTSxTQUFTQyxVQUFVQyxRQUFRO0lBQzlCLE9BQU8sT0FBT0EsYUFBYTtBQUMvQjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxXQUFXRCxRQUFRO0lBQy9CLE9BQU9ELFVBQVVDLGFBQWFBLGFBQWE7QUFDL0M7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0UsU0FBU0YsUUFBUTtJQUM3QixPQUFPLE9BQU9BLGFBQWE7QUFDL0I7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0csY0FBY0gsUUFBUTtJQUNsQyxPQUFPQSxvQkFBb0JJO0FBQy9CO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNDLE9BQU9MLFFBQVE7SUFDM0JULDBEQUFTQSxDQUFDRSxXQUFXO0lBQ3JCLE9BQU9PLG9CQUFvQk07QUFDL0I7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0MsVUFBVVAsUUFBUTtJQUM5QixPQUFPRSxTQUFTRixhQUFhLFNBQVNRLElBQUksQ0FBQ1I7QUFDL0M7QUFDTyxTQUFTUyxvQkFBb0JDLE9BQU87SUFDdkNuQiwwREFBU0EsQ0FBQ2dCLFVBQVVHLFVBQVU7SUFDOUIsTUFBTSxDQUFDQyxnQkFBZ0IsRUFBRSxFQUFFQyxhQUFhLEVBQUUsQ0FBQyxHQUFHRixRQUFRRyxLQUFLLENBQUM7SUFDNUQsTUFBTUMsVUFBVUgsY0FBY0UsS0FBSyxDQUFDO0lBQ3BDLElBQUlDLFFBQVFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRztRQUNsQyxPQUFPQyxLQUFLSjtJQUNoQjtJQUNBLE9BQU9LLFNBQVNMO0FBQ3BCO0FBQ08sU0FBU007SUFDWixPQUFPLGFBQWN0QixPQUFPdUIsZ0JBQWdCLElBQUs7QUFDckQ7QUFDQSxNQUFNQyw4QkFBOEI7QUFDN0IsU0FBU0M7SUFDWjdCLG9DQUFPQSxDQUFDLENBQUNHLG1CQUFtQixDQUFDLG9GQUFvRixFQUFFeUIsNEJBQTRCLENBQUM7QUFDcEo7QUFDTyxTQUFTRTtJQUNaOUIsb0NBQU9BLENBQUMsQ0FBQ0csbUJBQW1CLENBQUMsdUVBQXVFLEVBQUV5Qiw0QkFBNEIsQ0FBQztBQUN2STtBQUNPLFNBQVNHLGtCQUFrQkMsV0FBVztJQUN6QyxJQUFJQSxlQUFlQSxZQUFZQyxNQUFNLEVBQ2pDRCxZQUFZQyxNQUFNO0FBQzFCO0FBQ08sU0FBU0MsaUJBQWlCQyxJQUFJLEVBQUVDLEtBQUs7SUFDeENDLE9BQU9DLGNBQWMsQ0FBQ0gsTUFBTSxTQUFTO1FBQ2pDSTtZQUNJLE9BQU8sSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHSjtRQUMxQjtRQUNBSyxjQUFjO0lBQ2xCO0lBQ0FKLE9BQU9DLGNBQWMsQ0FBQ0gsTUFBTSxVQUFVO1FBQ2xDSTtZQUNJLE9BQU8sSUFBSSxDQUFDQyxJQUFJLENBQUMsRUFBRSxHQUFHSjtRQUMxQjtRQUNBSyxjQUFjO0lBQ2xCO0lBQ0FKLE9BQU9DLGNBQWMsQ0FBQ0gsTUFBTSxpQkFBaUI7UUFDekNJO1lBQ0ksT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBQyxFQUFFO1FBQ3ZCO1FBQ0FDLGNBQWM7SUFDbEI7SUFDQUosT0FBT0MsY0FBYyxDQUFDSCxNQUFNLGtCQUFrQjtRQUMxQ0k7WUFDSSxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDLEVBQUU7UUFDdkI7UUFDQUMsY0FBYztJQUNsQjtJQUNBLE9BQU9OO0FBQ1g7QUFDTyxTQUFTTyxrQkFBa0JDLEtBQUs7SUFDbkMsT0FBT0EsTUFBTUMsSUFBSSxLQUFLO0FBQzFCO0FBQ08sU0FBU0MsYUFBYUMsSUFBSTtJQUM3QixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDekIsTUFBTUMsU0FBUyxJQUFJQztRQUNuQkQsT0FBT0UsTUFBTSxHQUFHO1lBQ1osSUFBSSxDQUFDRixPQUFPRyxNQUFNLEVBQUU7Z0JBQ2hCLE9BQU9KLE9BQU8sSUFBSUssTUFBTTtZQUM1QjtZQUNBTixRQUFRRSxPQUFPRyxNQUFNO1FBQ3pCO1FBQ0FILE9BQU9LLE9BQU8sR0FBRyxDQUFDQztZQUNkLElBQUksQ0FBQ0EsTUFBTUMsTUFBTSxFQUFFO2dCQUNmLE9BQU9SLE9BQU8sSUFBSUssTUFBTTtZQUM1QjtZQUNBLE1BQU0sRUFBRVgsS0FBSyxFQUFFLEdBQUdhLE1BQU1DLE1BQU07WUFDOUIsSUFBSSxDQUFDZCxPQUFPO2dCQUNSLE9BQU9NLE9BQU8sSUFBSUssTUFBTTtZQUM1QjtZQUNBLE9BQVFYLE1BQU1lLElBQUk7Z0JBQ2QsS0FBS2YsTUFBTWdCLGFBQWE7b0JBQ3BCLE9BQU9WLE9BQU8sSUFBSUssTUFBTTtnQkFDNUIsS0FBS1gsTUFBTWlCLFlBQVk7b0JBQ25CLE9BQU9YLE9BQU8sSUFBSUssTUFBTTtnQkFDNUIsS0FBS1gsTUFBTWtCLFNBQVM7b0JBQ2hCLE9BQU9aLE9BQU8sSUFBSUssTUFBTTtnQkFDNUI7b0JBQ0ksT0FBT0wsT0FBTyxJQUFJSyxNQUFNO1lBQ2hDO1FBQ0o7UUFDQUosT0FBT1ksaUJBQWlCLENBQUNoQjtJQUM3QjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF0YS1ib3QvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC91dGlscy5qcz8wNmExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG4vKipcbiAqIENoZWNrcyBpZiB3ZSdyZSBydW5uaW5nIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHdlJ3JlIHJ1bm5pbmcgZnJvbSBhIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5leHBvcnQgY29uc3QgaXNMb2NhbEZpbGVTeXN0ZW0gPSBpc0Jyb3dzZXIgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWZpbmVkKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSAhPT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFyaWFibGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcm92aWRlZCh2YXJpYWJsZSkge1xuICAgIHJldHVybiBpc0RlZmluZWQodmFyaWFibGUpICYmIHZhcmlhYmxlICE9PSBudWxsO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFyaWFibGUgVmFyaWFibGUgdG8gY2hlY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFyaWFibGUgcHJvdmlkZWQgaXMgYW4gQXJyYXlCdWZmZXIuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YXJpYWJsZSkge1xuICAgIHJldHVybiB2YXJpYWJsZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGEgQmxvYi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhcmlhYmxlIFZhcmlhYmxlIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jsb2IodmFyaWFibGUpIHtcbiAgICBpbnZhcmlhbnQoaXNCcm93c2VyLCAnaXNCbG9iIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBicm93c2VyIGVudmlyb25tZW50Jyk7XG4gICAgcmV0dXJuIHZhcmlhYmxlIGluc3RhbmNlb2YgQmxvYjtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSB2YXJpYWJsZSBwcm92aWRlZCBpcyBhIGRhdGEgVVJJLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFyaWFibGUgU3RyaW5nIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFVUkkodmFyaWFibGUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFyaWFibGUpICYmIC9eZGF0YTovLnRlc3QodmFyaWFibGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFVUkl0b0J5dGVTdHJpbmcoZGF0YVVSSSkge1xuICAgIGludmFyaWFudChpc0RhdGFVUkkoZGF0YVVSSSksICdJbnZhbGlkIGRhdGEgVVJJLicpO1xuICAgIGNvbnN0IFtoZWFkZXJzU3RyaW5nID0gJycsIGRhdGFTdHJpbmcgPSAnJ10gPSBkYXRhVVJJLnNwbGl0KCcsJyk7XG4gICAgY29uc3QgaGVhZGVycyA9IGhlYWRlcnNTdHJpbmcuc3BsaXQoJzsnKTtcbiAgICBpZiAoaGVhZGVycy5pbmRleE9mKCdiYXNlNjQnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGF0b2IoZGF0YVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB1bmVzY2FwZShkYXRhU3RyaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAoaXNCcm93c2VyICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxO1xufVxuY29uc3QgYWxsb3dGaWxlQWNjZXNzRnJvbUZpbGVzVGlwID0gJ09uIENocm9taXVtIGJhc2VkIGJyb3dzZXJzLCB5b3UgY2FuIHVzZSAtLWFsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXMgZmxhZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLic7XG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheUNPUlNXYXJuaW5nKCkge1xuICAgIHdhcm5pbmcoIWlzTG9jYWxGaWxlU3lzdGVtLCBgTG9hZGluZyBQREYgYXMgYmFzZTY0IHN0cmluZ3MvVVJMcyBtYXkgbm90IHdvcmsgb24gcHJvdG9jb2xzIG90aGVyIHRoYW4gSFRUUC9IVFRQUy4gJHthbGxvd0ZpbGVBY2Nlc3NGcm9tRmlsZXNUaXB9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheVdvcmtlcldhcm5pbmcoKSB7XG4gICAgd2FybmluZyghaXNMb2NhbEZpbGVTeXN0ZW0sIGBMb2FkaW5nIFBERi5qcyB3b3JrZXIgbWF5IG5vdCB3b3JrIG9uIHByb3RvY29scyBvdGhlciB0aGFuIEhUVFAvSFRUUFMuICR7YWxsb3dGaWxlQWNjZXNzRnJvbUZpbGVzVGlwfWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbFJ1bm5pbmdUYXNrKHJ1bm5pbmdUYXNrKSB7XG4gICAgaWYgKHJ1bm5pbmdUYXNrICYmIHJ1bm5pbmdUYXNrLmNhbmNlbClcbiAgICAgICAgcnVubmluZ1Rhc2suY2FuY2VsKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhZ2VDYWxsYmFjayhwYWdlLCBzY2FsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYWdlLCAnd2lkdGgnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdbMl0gKiBzY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYWdlLCAnaGVpZ2h0Jywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3WzNdICogc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ29yaWdpbmFsV2lkdGgnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdbMl07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ29yaWdpbmFsSGVpZ2h0Jywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3WzNdO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhZ2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDYW5jZWxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubmFtZSA9PT0gJ1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9hZEZyb21GaWxlKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuTk9UX0ZPVU5EX0VSUjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlOiBGaWxlIG5vdCBmb3VuZC4nKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5TRUNVUklUWV9FUlI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZTogU2VjdXJpdHkgZXJyb3IuJykpO1xuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuQUJPUlRfRVJSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGU6IEFib3J0ZWQuJykpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJpbnZhcmlhbnQiLCJ3YXJuaW5nIiwiaXNCcm93c2VyIiwiZG9jdW1lbnQiLCJpc0xvY2FsRmlsZVN5c3RlbSIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJpc0RlZmluZWQiLCJ2YXJpYWJsZSIsImlzUHJvdmlkZWQiLCJpc1N0cmluZyIsImlzQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzQmxvYiIsIkJsb2IiLCJpc0RhdGFVUkkiLCJ0ZXN0IiwiZGF0YVVSSXRvQnl0ZVN0cmluZyIsImRhdGFVUkkiLCJoZWFkZXJzU3RyaW5nIiwiZGF0YVN0cmluZyIsInNwbGl0IiwiaGVhZGVycyIsImluZGV4T2YiLCJhdG9iIiwidW5lc2NhcGUiLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImFsbG93RmlsZUFjY2Vzc0Zyb21GaWxlc1RpcCIsImRpc3BsYXlDT1JTV2FybmluZyIsImRpc3BsYXlXb3JrZXJXYXJuaW5nIiwiY2FuY2VsUnVubmluZ1Rhc2siLCJydW5uaW5nVGFzayIsImNhbmNlbCIsIm1ha2VQYWdlQ2FsbGJhY2siLCJwYWdlIiwic2NhbGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInZpZXciLCJjb25maWd1cmFibGUiLCJpc0NhbmNlbEV4Y2VwdGlvbiIsImVycm9yIiwibmFtZSIsImxvYWRGcm9tRmlsZSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJFcnJvciIsIm9uZXJyb3IiLCJldmVudCIsInRhcmdldCIsImNvZGUiLCJOT1RfRk9VTkRfRVJSIiwiU0VDVVJJVFlfRVJSIiwiQUJPUlRfRVJSIiwicmVhZEFzQXJyYXlCdWZmZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/shared/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/react-pdf/dist/esm/Document.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Document.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\PC HOUSE\Downloads\ai-docs-main (1)\ai-docs-main\node_modules\react-pdf\dist\esm\Document.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ }),

/***/ "(rsc)/./node_modules/react-pdf/dist/esm/Page.js":
/*!*************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\PC HOUSE\Downloads\ai-docs-main (1)\ai-docs-main\node_modules\react-pdf\dist\esm\Page.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ })

};
;